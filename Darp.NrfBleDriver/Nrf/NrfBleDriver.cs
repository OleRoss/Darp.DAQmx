// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace NrfBleDriver
{
    public unsafe partial class TransportLayerT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr @internal;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0transport_layer_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.TransportLayerT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.TransportLayerT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.TransportLayerT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.TransportLayerT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static TransportLayerT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new TransportLayerT(native.ToPointer(), skipVTables);
        }

        internal static TransportLayerT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (TransportLayerT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static TransportLayerT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new TransportLayerT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TransportLayerT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected TransportLayerT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public TransportLayerT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.TransportLayerT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public TransportLayerT(global::NrfBleDriver.TransportLayerT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.TransportLayerT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.TransportLayerT.__Internal*) __Instance) = *((global::NrfBleDriver.TransportLayerT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Internal
        {
            get
            {
                return ((__Internal*)__Instance)->@internal;
            }

            set
            {
                ((__Internal*)__Instance)->@internal = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class DataLinkLayerT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr @internal;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0data_link_layer_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.DataLinkLayerT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.DataLinkLayerT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.DataLinkLayerT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.DataLinkLayerT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static DataLinkLayerT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DataLinkLayerT(native.ToPointer(), skipVTables);
        }

        internal static DataLinkLayerT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (DataLinkLayerT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static DataLinkLayerT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DataLinkLayerT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DataLinkLayerT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected DataLinkLayerT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public DataLinkLayerT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.DataLinkLayerT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public DataLinkLayerT(global::NrfBleDriver.DataLinkLayerT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.DataLinkLayerT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.DataLinkLayerT.__Internal*) __Instance) = *((global::NrfBleDriver.DataLinkLayerT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Internal
        {
            get
            {
                return ((__Internal*)__Instance)->@internal;
            }

            set
            {
                ((__Internal*)__Instance)->@internal = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class AdapterT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr @internal;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0adapter_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.AdapterT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.AdapterT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.AdapterT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.AdapterT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static AdapterT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new AdapterT(native.ToPointer(), skipVTables);
        }

        internal static AdapterT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (AdapterT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static AdapterT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new AdapterT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private AdapterT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected AdapterT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public AdapterT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.AdapterT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public AdapterT(global::NrfBleDriver.AdapterT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.AdapterT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.AdapterT.__Internal*) __Instance) = *((global::NrfBleDriver.AdapterT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Internal
        {
            get
            {
                return ((__Internal*)__Instance)->@internal;
            }

            set
            {
                ((__Internal*)__Instance)->@internal = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class PhysicalLayerT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr @internal;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0physical_layer_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.PhysicalLayerT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.PhysicalLayerT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.PhysicalLayerT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.PhysicalLayerT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PhysicalLayerT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new PhysicalLayerT(native.ToPointer(), skipVTables);
        }

        internal static PhysicalLayerT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PhysicalLayerT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PhysicalLayerT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PhysicalLayerT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PhysicalLayerT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PhysicalLayerT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PhysicalLayerT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.PhysicalLayerT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PhysicalLayerT(global::NrfBleDriver.PhysicalLayerT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.PhysicalLayerT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.PhysicalLayerT.__Internal*) __Instance) = *((global::NrfBleDriver.PhysicalLayerT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Internal
        {
            get
            {
                return ((__Internal*)__Instance)->@internal;
            }

            set
            {
                ((__Internal*)__Instance)->@internal = (__IntPtr) value;
            }
        }
    }

    /// <summary>Common API SVC numbers.</summary>
    public enum BLE_COMMON_SVCS
    {
        /// <summary>Enable and initialize the BLE stack</summary>
        SD_BLE_ENABLE = 96,
        /// <summary>Get an event from the pending events queue.</summary>
        SD_BLE_EVT_GET = 97,
        /// <summary>Add a Vendor Specific UUID.</summary>
        SD_BLE_UUID_VS_ADD = 98,
        /// <summary>Decode UUID bytes.</summary>
        SD_BLE_UUID_DECODE = 99,
        /// <summary>Encode UUID bytes.</summary>
        SD_BLE_UUID_ENCODE = 100,
        /// <summary>Get the local version information (company ID, Link Layer Version, Link Layer Subversion).</summary>
        SD_BLE_VERSION_GET = 101,
        /// <summary>User Memory Reply.</summary>
        SD_BLE_USER_MEM_REPLY = 102,
        /// <summary>Set a BLE option.</summary>
        SD_BLE_OPT_SET = 103,
        /// <summary>Get a BLE option.</summary>
        SD_BLE_OPT_GET = 104,
        /// <summary>Add a configuration to the BLE stack.</summary>
        SD_BLE_CFG_SET = 105
    }

    /// <summary>BLE Module Independent Event IDs.</summary>
    public enum BLE_COMMON_EVTS
    {
        /// <summary>User Memory request.</summary>
        BLE_EVT_USER_MEM_REQUEST = 1,
        /// <summary>User Memory release.</summary>
        BLE_EVT_USER_MEM_RELEASE = 2
    }

    /// <summary>BLE Connection Configuration IDs.</summary>
    /// <remarks>IDs that uniquely identify a connection configuration.</remarks>
    public enum BLE_CONN_CFGS
    {
        /// <summary>BLE GAP specific connection configuration.</summary>
        BLE_CONN_CFG_GAP = 32,
        /// <summary>BLE GATTC specific connection configuration.</summary>
        BLE_CONN_CFG_GATTC = 33,
        /// <summary>BLE GATTS specific connection configuration.</summary>
        BLE_CONN_CFG_GATTS = 34,
        /// <summary>BLE GATT specific connection configuration.</summary>
        BLE_CONN_CFG_GATT = 35,
        /// <summary>BLE L2CAP specific connection configuration.</summary>
        BLE_CONN_CFG_L2CAP = 36
    }

    /// <summary>BLE Common Configuration IDs.</summary>
    /// <remarks>IDs that uniquely identify a common configuration.</remarks>
    public enum BLE_COMMON_CFGS
    {
        /// <summary>Vendor specific UUID configuration</summary>
        BLE_COMMON_CFG_VS_UUID = 1
    }

    /// <summary>
    /// <para>Common Option IDs.</para>
    /// <para>IDs that uniquely identify a common option.</para>
    /// </summary>
    public enum BLE_COMMON_OPTS
    {
        /// <summary>PA and LNA options</summary>
        BLE_COMMON_OPT_PA_LNA = 1,
        /// <summary>Extended connection events option</summary>
        BLE_COMMON_OPT_CONN_EVT_EXT = 2
    }

    /// <summary>User Memory Block.</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for events not associated with a specific function module.</summary>
    /// <summary>BLE Event header.</summary>
    /// <summary>Common BLE Event type, wrapping the module specific event reports.</summary>
    /// <summary>Version Information.</summary>
    /// <summary>Configuration parameters for the PA and LNA.</summary>
    /// <summary>PA&amp;LNA GPIO toggle configuration</summary>
    /// <remarks>
    /// <para>This option configures the SoftDevice to toggle pins when the radio is active for use with a power amplifier and/or</para>
    /// <para>a low noise amplifier.</para>
    /// <para>Toggling the pins is achieved by using two PPI channels and a GPIOTE channel. The hardware channel IDs are provided</para>
    /// <para>by the application and should be regarded as reserved as long as any PA/LNA toggling is enabled.</para>
    /// <para>is not supported for this option.</para>
    /// <para>Setting this option while the radio is in use (i.e. any of the roles are active) may have undefined consequences</para>
    /// <para>and must be avoided by the application.</para>
    /// </remarks>
    /// <summary>Configuration of extended BLE connection events.</summary>
    /// <remarks>
    /// <para>When enabled the SoftDevice will dynamically extend the connection event when possible.</para>
    /// <para>The connection event length is controlled by the connection configuration as set byThe connection event can be extended if there is time to send another packet pair before the start of the next connection interval,</para>
    /// <para>and if there are no conflicts with other BLE roles requesting radio time.</para>
    /// <para>is not supported for this option.</para>
    /// </remarks>
    /// <summary>Option structure for common options.</summary>
    /// <summary>Common BLE Option type, wrapping the module specific options.</summary>
    /// <summary>BLE connection configuration type, wrapping the module specific configurations, set with</summary>
    /// <remarks>
    /// <para>Connection configurations don't have to be set.</para>
    /// <para>In the case that no configurations has been set, or fewer connection configurations has been set than enabled connections,</para>
    /// <para>the default connection configuration will be automatically added for the remaining connections.</para>
    /// <para>When creating connections with the default configuration,should be used in</para>
    /// <para>place ofSeeand</para>
    /// <para>s</para>
    /// </remarks>
    /// <summary>Configuration of Vendor Specific UUIDs, set with</summary>
    /// <remarks>::NRF_ERROR_INVALID_PARAM Too many UUIDs configured.</remarks>
    /// <summary>Common BLE Configuration type, wrapping the common configurations.</summary>
    /// <summary>BLE Configuration type, wrapping the module specific configurations.</summary>
    /// <summary>User Memory Block.</summary>
    public unsafe partial class BleUserMemBlockT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr p_mem;
            internal ushort len;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_user_mem_block_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleUserMemBlockT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleUserMemBlockT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleUserMemBlockT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleUserMemBlockT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleUserMemBlockT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleUserMemBlockT(native.ToPointer(), skipVTables);
        }

        internal static BleUserMemBlockT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleUserMemBlockT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleUserMemBlockT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleUserMemBlockT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleUserMemBlockT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleUserMemBlockT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleUserMemBlockT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleUserMemBlockT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleUserMemBlockT(global::NrfBleDriver.BleUserMemBlockT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleUserMemBlockT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleUserMemBlockT.__Internal*) __Instance) = *((global::NrfBleDriver.BleUserMemBlockT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Pointer to the start of the user memory block.</summary>
        public byte* PMem
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_mem;
            }

            set
            {
                ((__Internal*)__Instance)->p_mem = (__IntPtr) value;
            }
        }

        /// <summary>Length in bytes of the user memory block.</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleEvtUserMemRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte type;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_evt_user_mem_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtUserMemRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtUserMemRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleEvtUserMemRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleEvtUserMemRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleEvtUserMemRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleEvtUserMemRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleEvtUserMemRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleEvtUserMemRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleEvtUserMemRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleEvtUserMemRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleEvtUserMemRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleEvtUserMemRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleEvtUserMemRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtUserMemRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleEvtUserMemRequestT(global::NrfBleDriver.BleEvtUserMemRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtUserMemRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleEvtUserMemRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleEvtUserMemRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>User memory type, see</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleEvtUserMemReleaseT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal byte type;
            internal global::NrfBleDriver.BleUserMemBlockT.__Internal mem_block;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_evt_user_mem_release_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtUserMemReleaseT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtUserMemReleaseT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleEvtUserMemReleaseT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleEvtUserMemReleaseT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleEvtUserMemReleaseT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleEvtUserMemReleaseT(native.ToPointer(), skipVTables);
        }

        internal static BleEvtUserMemReleaseT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleEvtUserMemReleaseT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleEvtUserMemReleaseT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleEvtUserMemReleaseT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleEvtUserMemReleaseT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleEvtUserMemReleaseT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleEvtUserMemReleaseT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtUserMemReleaseT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleEvtUserMemReleaseT(global::NrfBleDriver.BleEvtUserMemReleaseT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtUserMemReleaseT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleEvtUserMemReleaseT.__Internal*) __Instance) = *((global::NrfBleDriver.BleEvtUserMemReleaseT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>User memory type, see</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>User memory block</summary>
        public global::NrfBleDriver.BleUserMemBlockT MemBlock
        {
            get
            {
                return global::NrfBleDriver.BleUserMemBlockT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->mem_block));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->mem_block = *(global::NrfBleDriver.BleUserMemBlockT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for events not associated with a specific function module.</summary>
    public unsafe partial class BleCommonEvtT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal global::NrfBleDriver.BleCommonEvtT.Params.__Internal @params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_common_evt_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Params
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::NrfBleDriver.BleEvtUserMemRequestT.__Internal user_mem_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleEvtUserMemReleaseT.__Internal user_mem_release;

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-params>@ble_common_evt_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Params.__Internal __instance;
            internal Params.__Internal __Instance => __instance;

            internal static Params __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Params(native.ToPointer(), skipVTables);
            }

            internal static Params __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Params(native, skipVTables);
            }

            private Params(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Params(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleCommonEvtT.Params.__Internal*) native;
            }

            public Params(global::NrfBleDriver.BleCommonEvtT.Params __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>User Memory Request Event Parameters.</summary>
            public global::NrfBleDriver.BleEvtUserMemRequestT UserMemRequest
            {
                get
                {
                    return global::NrfBleDriver.BleEvtUserMemRequestT.__CreateInstance(__instance.user_mem_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.user_mem_request = *(global::NrfBleDriver.BleEvtUserMemRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>User Memory Release Event Parameters.</summary>
            public global::NrfBleDriver.BleEvtUserMemReleaseT UserMemRelease
            {
                get
                {
                    return global::NrfBleDriver.BleEvtUserMemReleaseT.__CreateInstance(__instance.user_mem_release);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.user_mem_release = *(global::NrfBleDriver.BleEvtUserMemReleaseT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonEvtT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonEvtT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleCommonEvtT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleCommonEvtT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleCommonEvtT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleCommonEvtT(native.ToPointer(), skipVTables);
        }

        internal static BleCommonEvtT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleCommonEvtT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleCommonEvtT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleCommonEvtT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleCommonEvtT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleCommonEvtT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleCommonEvtT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleCommonEvtT(global::NrfBleDriver.BleCommonEvtT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleCommonEvtT.__Internal*) __Instance) = *((global::NrfBleDriver.BleCommonEvtT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle on which this event occurred.</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>Event parameter union.</summary>
        public global::NrfBleDriver.BleCommonEvtT.Params @params
        {
            get
            {
                return global::NrfBleDriver.BleCommonEvtT.Params.__CreateInstance(((__Internal*)__Instance)->@params);
            }

            set
            {
                ((__Internal*)__Instance)->@params = value.__Instance;
            }
        }
    }

    /// <summary>BLE Event header.</summary>
    public unsafe partial class BleEvtHdrT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal ushort evt_id;
            internal ushort evt_len;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_evt_hdr_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtHdrT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtHdrT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleEvtHdrT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleEvtHdrT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleEvtHdrT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleEvtHdrT(native.ToPointer(), skipVTables);
        }

        internal static BleEvtHdrT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleEvtHdrT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleEvtHdrT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleEvtHdrT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleEvtHdrT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleEvtHdrT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleEvtHdrT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtHdrT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleEvtHdrT(global::NrfBleDriver.BleEvtHdrT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtHdrT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleEvtHdrT.__Internal*) __Instance) = *((global::NrfBleDriver.BleEvtHdrT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Value from a BLE_&gt;_EVT series.</summary>
        public ushort EvtId
        {
            get
            {
                return ((__Internal*)__Instance)->evt_id;
            }

            set
            {
                ((__Internal*)__Instance)->evt_id = value;
            }
        }

        /// <summary>Length in octets including this header.</summary>
        public ushort EvtLen
        {
            get
            {
                return ((__Internal*)__Instance)->evt_len;
            }

            set
            {
                ((__Internal*)__Instance)->evt_len = value;
            }
        }
    }

    /// <summary>Common BLE Event type, wrapping the module specific event reports.</summary>
    public unsafe partial class BleEvtT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleEvtHdrT.__Internal header;
            internal global::NrfBleDriver.BleEvtT.Evt.__Internal evt;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_evt_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Evt
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::NrfBleDriver.BleCommonEvtT.__Internal common_evt;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtT.__Internal gap_evt;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtT.__Internal gattc_evt;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattsEvtT.__Internal gatts_evt;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtT.__Internal l2cap_evt;

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-evt>@ble_evt_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Evt.__Internal __instance;
            internal Evt.__Internal __Instance => __instance;

            internal static Evt __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Evt(native.ToPointer(), skipVTables);
            }

            internal static Evt __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Evt(native, skipVTables);
            }

            private Evt(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Evt(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleEvtT.Evt.__Internal*) native;
            }

            public Evt(global::NrfBleDriver.BleEvtT.Evt __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>Common Event, evt_id in BLE_EVT_* series.</summary>
            public global::NrfBleDriver.BleCommonEvtT CommonEvt
            {
                get
                {
                    return global::NrfBleDriver.BleCommonEvtT.__CreateInstance(__instance.common_evt);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.common_evt = *(global::NrfBleDriver.BleCommonEvtT.__Internal*) value.__Instance;
                }
            }

            /// <summary>GAP originated event, evt_id in BLE_GAP_EVT_* series.</summary>
            public global::NrfBleDriver.BleGapEvtT GapEvt
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtT.__CreateInstance(__instance.gap_evt);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.gap_evt = *(global::NrfBleDriver.BleGapEvtT.__Internal*) value.__Instance;
                }
            }

            /// <summary>GATT client originated event, evt_id in BLE_GATTC_EVT* series.</summary>
            public global::NrfBleDriver.BleGattcEvtT GattcEvt
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtT.__CreateInstance(__instance.gattc_evt);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.gattc_evt = *(global::NrfBleDriver.BleGattcEvtT.__Internal*) value.__Instance;
                }
            }

            /// <summary>GATT server originated event, evt_id in BLE_GATTS_EVT* series.</summary>
            public global::NrfBleDriver.BleGattsEvtT GattsEvt
            {
                get
                {
                    return global::NrfBleDriver.BleGattsEvtT.__CreateInstance(__instance.gatts_evt);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.gatts_evt = *(global::NrfBleDriver.BleGattsEvtT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP originated event, evt_id in BLE_L2CAP_EVT* series.</summary>
            public global::NrfBleDriver.BleL2capEvtT L2capEvt
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtT.__CreateInstance(__instance.l2cap_evt);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.l2cap_evt = *(global::NrfBleDriver.BleL2capEvtT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleEvtT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleEvtT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleEvtT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleEvtT(native.ToPointer(), skipVTables);
        }

        internal static BleEvtT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleEvtT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleEvtT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleEvtT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleEvtT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleEvtT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleEvtT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleEvtT(global::NrfBleDriver.BleEvtT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleEvtT.__Internal*) __Instance) = *((global::NrfBleDriver.BleEvtT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Event header.</summary>
        public global::NrfBleDriver.BleEvtHdrT Header
        {
            get
            {
                return global::NrfBleDriver.BleEvtHdrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->header));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->header = *(global::NrfBleDriver.BleEvtHdrT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Event union.</summary>
        public global::NrfBleDriver.BleEvtT.Evt evt
        {
            get
            {
                return global::NrfBleDriver.BleEvtT.Evt.__CreateInstance(((__Internal*)__Instance)->evt);
            }

            set
            {
                ((__Internal*)__Instance)->evt = value.__Instance;
            }
        }
    }

    /// <summary>Version Information.</summary>
    public unsafe partial class BleVersionT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 6)]
        public partial struct __Internal
        {
            internal byte version_number;
            internal ushort company_id;
            internal ushort subversion_number;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_version_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleVersionT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleVersionT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleVersionT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleVersionT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleVersionT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleVersionT(native.ToPointer(), skipVTables);
        }

        internal static BleVersionT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleVersionT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleVersionT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleVersionT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleVersionT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleVersionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleVersionT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleVersionT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleVersionT(global::NrfBleDriver.BleVersionT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleVersionT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleVersionT.__Internal*) __Instance) = *((global::NrfBleDriver.BleVersionT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Link Layer Version number. See https://www.bluetooth.org/en-us/specification/assigned-numbers/link-layer for assigned values.</summary>
        public byte VersionNumber
        {
            get
            {
                return ((__Internal*)__Instance)->version_number;
            }

            set
            {
                ((__Internal*)__Instance)->version_number = value;
            }
        }

        /// <summary>Company ID, Nordic Semiconductor's company ID is 89 (0x0059) (https://www.bluetooth.org/apps/content/Default.aspx?doc_id=49708).</summary>
        public ushort CompanyId
        {
            get
            {
                return ((__Internal*)__Instance)->company_id;
            }

            set
            {
                ((__Internal*)__Instance)->company_id = value;
            }
        }

        /// <summary>Link Layer Sub Version number, corresponds to the SoftDevice Config ID or Firmware ID (FWID).</summary>
        public ushort SubversionNumber
        {
            get
            {
                return ((__Internal*)__Instance)->subversion_number;
            }

            set
            {
                ((__Internal*)__Instance)->subversion_number = value;
            }
        }
    }

    /// <summary>Configuration parameters for the PA and LNA.</summary>
    public unsafe partial class BlePaLnaCfgT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte enable;

            [FieldOffset(0)]
            internal byte active_high;

            [FieldOffset(0)]
            internal byte gpio_pin;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_pa_lna_cfg_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BlePaLnaCfgT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BlePaLnaCfgT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BlePaLnaCfgT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BlePaLnaCfgT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BlePaLnaCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BlePaLnaCfgT(native.ToPointer(), skipVTables);
        }

        internal static BlePaLnaCfgT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BlePaLnaCfgT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BlePaLnaCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BlePaLnaCfgT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BlePaLnaCfgT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BlePaLnaCfgT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BlePaLnaCfgT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BlePaLnaCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BlePaLnaCfgT(global::NrfBleDriver.BlePaLnaCfgT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BlePaLnaCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BlePaLnaCfgT.__Internal*) __Instance) = *((global::NrfBleDriver.BlePaLnaCfgT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Enable toggling for this amplifier</summary>
        public byte Enable
        {
            get
            {
                return ((__Internal*)__Instance)->enable;
            }

            set
            {
                ((__Internal*)__Instance)->enable = value;
            }
        }

        /// <summary>Set the pin to be active high</summary>
        public byte ActiveHigh
        {
            get
            {
                return ((__Internal*)__Instance)->active_high;
            }

            set
            {
                ((__Internal*)__Instance)->active_high = value;
            }
        }

        /// <summary>The GPIO pin to toggle for this amplifier</summary>
        public byte GpioPin
        {
            get
            {
                return ((__Internal*)__Instance)->gpio_pin;
            }

            set
            {
                ((__Internal*)__Instance)->gpio_pin = value;
            }
        }
    }

    /// <summary>PA&amp;LNA GPIO toggle configuration</summary>
    /// <remarks>
    /// <para>This option configures the SoftDevice to toggle pins when the radio is active for use with a power amplifier and/or</para>
    /// <para>a low noise amplifier.</para>
    /// <para>Toggling the pins is achieved by using two PPI channels and a GPIOTE channel. The hardware channel IDs are provided</para>
    /// <para>by the application and should be regarded as reserved as long as any PA/LNA toggling is enabled.</para>
    /// <para>is not supported for this option.</para>
    /// <para>Setting this option while the radio is in use (i.e. any of the roles are active) may have undefined consequences</para>
    /// <para>and must be avoided by the application.</para>
    /// </remarks>
    public unsafe partial class BleCommonOptPaLnaT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 5)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BlePaLnaCfgT.__Internal pa_cfg;
            internal global::NrfBleDriver.BlePaLnaCfgT.__Internal lna_cfg;
            internal byte ppi_ch_id_set;
            internal byte ppi_ch_id_clr;
            internal byte gpiote_ch_id;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_common_opt_pa_lna_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonOptPaLnaT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonOptPaLnaT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleCommonOptPaLnaT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleCommonOptPaLnaT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleCommonOptPaLnaT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleCommonOptPaLnaT(native.ToPointer(), skipVTables);
        }

        internal static BleCommonOptPaLnaT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleCommonOptPaLnaT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleCommonOptPaLnaT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleCommonOptPaLnaT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleCommonOptPaLnaT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleCommonOptPaLnaT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleCommonOptPaLnaT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonOptPaLnaT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleCommonOptPaLnaT(global::NrfBleDriver.BleCommonOptPaLnaT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonOptPaLnaT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleCommonOptPaLnaT.__Internal*) __Instance) = *((global::NrfBleDriver.BleCommonOptPaLnaT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Power Amplifier configuration</summary>
        public global::NrfBleDriver.BlePaLnaCfgT PaCfg
        {
            get
            {
                return global::NrfBleDriver.BlePaLnaCfgT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->pa_cfg));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->pa_cfg = *(global::NrfBleDriver.BlePaLnaCfgT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Low Noise Amplifier configuration</summary>
        public global::NrfBleDriver.BlePaLnaCfgT LnaCfg
        {
            get
            {
                return global::NrfBleDriver.BlePaLnaCfgT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->lna_cfg));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->lna_cfg = *(global::NrfBleDriver.BlePaLnaCfgT.__Internal*) value.__Instance;
            }
        }

        /// <summary>PPI channel used for radio pin setting</summary>
        public byte PpiChIdSet
        {
            get
            {
                return ((__Internal*)__Instance)->ppi_ch_id_set;
            }

            set
            {
                ((__Internal*)__Instance)->ppi_ch_id_set = value;
            }
        }

        /// <summary>PPI channel used for radio pin clearing</summary>
        public byte PpiChIdClr
        {
            get
            {
                return ((__Internal*)__Instance)->ppi_ch_id_clr;
            }

            set
            {
                ((__Internal*)__Instance)->ppi_ch_id_clr = value;
            }
        }

        /// <summary>GPIOTE channel used for radio pin toggling</summary>
        public byte GpioteChId
        {
            get
            {
                return ((__Internal*)__Instance)->gpiote_ch_id;
            }

            set
            {
                ((__Internal*)__Instance)->gpiote_ch_id = value;
            }
        }
    }

    /// <summary>Configuration of extended BLE connection events.</summary>
    /// <remarks>
    /// <para>When enabled the SoftDevice will dynamically extend the connection event when possible.</para>
    /// <para>The connection event length is controlled by the connection configuration as set byThe connection event can be extended if there is time to send another packet pair before the start of the next connection interval,</para>
    /// <para>and if there are no conflicts with other BLE roles requesting radio time.</para>
    /// <para>is not supported for this option.</para>
    /// </remarks>
    public unsafe partial class BleCommonOptConnEvtExtT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte enable;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_common_opt_conn_evt_ext_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonOptConnEvtExtT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonOptConnEvtExtT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleCommonOptConnEvtExtT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleCommonOptConnEvtExtT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleCommonOptConnEvtExtT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleCommonOptConnEvtExtT(native.ToPointer(), skipVTables);
        }

        internal static BleCommonOptConnEvtExtT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleCommonOptConnEvtExtT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleCommonOptConnEvtExtT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleCommonOptConnEvtExtT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleCommonOptConnEvtExtT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleCommonOptConnEvtExtT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleCommonOptConnEvtExtT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonOptConnEvtExtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleCommonOptConnEvtExtT(global::NrfBleDriver.BleCommonOptConnEvtExtT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonOptConnEvtExtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleCommonOptConnEvtExtT.__Internal*) __Instance) = *((global::NrfBleDriver.BleCommonOptConnEvtExtT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Enable extended BLE connection events, disabled by default.</summary>
        public byte Enable
        {
            get
            {
                return ((__Internal*)__Instance)->enable;
            }

            set
            {
                ((__Internal*)__Instance)->enable = value;
            }
        }
    }

    /// <summary>Option structure for common options.</summary>
    public unsafe partial struct BleCommonOptT
    {
        [StructLayout(LayoutKind.Explicit, Size = 5)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleCommonOptPaLnaT.__Internal pa_lna;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleCommonOptConnEvtExtT.__Internal conn_evt_ext;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_common_opt_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        private BleCommonOptT.__Internal __instance;
        internal BleCommonOptT.__Internal __Instance => __instance;

        internal static BleCommonOptT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleCommonOptT(native.ToPointer(), skipVTables);
        }

        internal static BleCommonOptT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleCommonOptT(native, skipVTables);
        }

        private BleCommonOptT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private BleCommonOptT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NrfBleDriver.BleCommonOptT.__Internal*) native;
        }

        public BleCommonOptT(global::NrfBleDriver.BleCommonOptT __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>Parameters for controlling PA and LNA pin toggling.</summary>
        public global::NrfBleDriver.BleCommonOptPaLnaT PaLna
        {
            get
            {
                return global::NrfBleDriver.BleCommonOptPaLnaT.__CreateInstance(__instance.pa_lna);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.pa_lna = *(global::NrfBleDriver.BleCommonOptPaLnaT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Parameters for enabling extended connection events.</summary>
        public global::NrfBleDriver.BleCommonOptConnEvtExtT ConnEvtExt
        {
            get
            {
                return global::NrfBleDriver.BleCommonOptConnEvtExtT.__CreateInstance(__instance.conn_evt_ext);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.conn_evt_ext = *(global::NrfBleDriver.BleCommonOptConnEvtExtT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Common BLE Option type, wrapping the module specific options.</summary>
    public unsafe partial struct BleOptT
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleCommonOptT.__Internal common_opt;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptT.__Internal gap_opt;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_opt_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        private BleOptT.__Internal __instance;
        internal BleOptT.__Internal __Instance => __instance;

        internal static BleOptT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleOptT(native.ToPointer(), skipVTables);
        }

        internal static BleOptT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleOptT(native, skipVTables);
        }

        private BleOptT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private BleOptT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NrfBleDriver.BleOptT.__Internal*) native;
        }

        public BleOptT(global::NrfBleDriver.BleOptT __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>COMMON options, opt_id inseries.</summary>
        public global::NrfBleDriver.BleCommonOptT CommonOpt;

        /// <summary>GAP option, opt_id inseries.</summary>
        public global::NrfBleDriver.BleGapOptT GapOpt;
    }

    /// <summary>BLE connection configuration type, wrapping the module specific configurations, set with</summary>
    /// <remarks>
    /// <para>Connection configurations don't have to be set.</para>
    /// <para>In the case that no configurations has been set, or fewer connection configurations has been set than enabled connections,</para>
    /// <para>the default connection configuration will be automatically added for the remaining connections.</para>
    /// <para>When creating connections with the default configuration,should be used in</para>
    /// <para>place ofSeeand</para>
    /// <para>s</para>
    /// </remarks>
    public unsafe partial class BleConnCfgT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 10)]
        public partial struct __Internal
        {
            internal byte conn_cfg_tag;
            internal global::NrfBleDriver.BleConnCfgT.Params.__Internal @params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_conn_cfg_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Params
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapConnCfgT.__Internal gap_conn_cfg;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcConnCfgT.__Internal gattc_conn_cfg;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattsConnCfgT.__Internal gatts_conn_cfg;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattConnCfgT.__Internal gatt_conn_cfg;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capConnCfgT.__Internal l2cap_conn_cfg;

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-params>@ble_conn_cfg_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Params.__Internal __instance;
            internal Params.__Internal __Instance => __instance;

            internal static Params __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Params(native.ToPointer(), skipVTables);
            }

            internal static Params __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Params(native, skipVTables);
            }

            private Params(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Params(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleConnCfgT.Params.__Internal*) native;
            }

            public Params(global::NrfBleDriver.BleConnCfgT.Params __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>GAP connection configuration, cfg_id is</summary>
            public global::NrfBleDriver.BleGapConnCfgT GapConnCfg
            {
                get
                {
                    return global::NrfBleDriver.BleGapConnCfgT.__CreateInstance(__instance.gap_conn_cfg);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.gap_conn_cfg = *(global::NrfBleDriver.BleGapConnCfgT.__Internal*) value.__Instance;
                }
            }

            /// <summary>GATTC connection configuration, cfg_id is</summary>
            public global::NrfBleDriver.BleGattcConnCfgT GattcConnCfg
            {
                get
                {
                    return global::NrfBleDriver.BleGattcConnCfgT.__CreateInstance(__instance.gattc_conn_cfg);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.gattc_conn_cfg = *(global::NrfBleDriver.BleGattcConnCfgT.__Internal*) value.__Instance;
                }
            }

            /// <summary>GATTS connection configuration, cfg_id is</summary>
            public global::NrfBleDriver.BleGattsConnCfgT GattsConnCfg
            {
                get
                {
                    return global::NrfBleDriver.BleGattsConnCfgT.__CreateInstance(__instance.gatts_conn_cfg);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.gatts_conn_cfg = *(global::NrfBleDriver.BleGattsConnCfgT.__Internal*) value.__Instance;
                }
            }

            /// <summary>GATT connection configuration, cfg_id is</summary>
            public global::NrfBleDriver.BleGattConnCfgT GattConnCfg
            {
                get
                {
                    return global::NrfBleDriver.BleGattConnCfgT.__CreateInstance(__instance.gatt_conn_cfg);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.gatt_conn_cfg = *(global::NrfBleDriver.BleGattConnCfgT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP connection configuration, cfg_id is</summary>
            public global::NrfBleDriver.BleL2capConnCfgT L2capConnCfg
            {
                get
                {
                    return global::NrfBleDriver.BleL2capConnCfgT.__CreateInstance(__instance.l2cap_conn_cfg);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.l2cap_conn_cfg = *(global::NrfBleDriver.BleL2capConnCfgT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleConnCfgT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleConnCfgT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleConnCfgT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleConnCfgT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleConnCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleConnCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleConnCfgT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleConnCfgT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleConnCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleConnCfgT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleConnCfgT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleConnCfgT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleConnCfgT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleConnCfgT(global::NrfBleDriver.BleConnCfgT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleConnCfgT.__Internal*) __Instance) = *((global::NrfBleDriver.BleConnCfgT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The application chosen tag it can use with theandcalls to select this configuration when creating a connection.</para>
        /// <para>Must be different for all connection configurations added and not</para>
        /// </summary>
        public byte ConnCfgTag
        {
            get
            {
                return ((__Internal*)__Instance)->conn_cfg_tag;
            }

            set
            {
                ((__Internal*)__Instance)->conn_cfg_tag = value;
            }
        }

        /// <summary>Connection configuration union.</summary>
        public global::NrfBleDriver.BleConnCfgT.Params @params
        {
            get
            {
                return global::NrfBleDriver.BleConnCfgT.Params.__CreateInstance(((__Internal*)__Instance)->@params);
            }

            set
            {
                ((__Internal*)__Instance)->@params = value.__Instance;
            }
        }
    }

    /// <summary>Configuration of Vendor Specific UUIDs, set with</summary>
    /// <remarks>::NRF_ERROR_INVALID_PARAM Too many UUIDs configured.</remarks>
    public unsafe partial class BleCommonCfgVsUuidT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte vs_uuid_count;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_common_cfg_vs_uuid_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonCfgVsUuidT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonCfgVsUuidT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleCommonCfgVsUuidT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleCommonCfgVsUuidT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleCommonCfgVsUuidT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleCommonCfgVsUuidT(native.ToPointer(), skipVTables);
        }

        internal static BleCommonCfgVsUuidT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleCommonCfgVsUuidT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleCommonCfgVsUuidT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleCommonCfgVsUuidT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleCommonCfgVsUuidT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleCommonCfgVsUuidT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleCommonCfgVsUuidT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonCfgVsUuidT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleCommonCfgVsUuidT(global::NrfBleDriver.BleCommonCfgVsUuidT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonCfgVsUuidT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleCommonCfgVsUuidT.__Internal*) __Instance) = *((global::NrfBleDriver.BleCommonCfgVsUuidT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Number of 128-bit Vendor Specific UUID bases to allocate memory for.</para>
        /// <para>Default value isMaximum value is</para>
        /// </summary>
        public byte VsUuidCount
        {
            get
            {
                return ((__Internal*)__Instance)->vs_uuid_count;
            }

            set
            {
                ((__Internal*)__Instance)->vs_uuid_count = value;
            }
        }
    }

    /// <summary>Common BLE Configuration type, wrapping the common configurations.</summary>
    public unsafe partial struct BleCommonCfgT
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleCommonCfgVsUuidT.__Internal vs_uuid_cfg;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_common_cfg_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        private BleCommonCfgT.__Internal __instance;
        internal BleCommonCfgT.__Internal __Instance => __instance;

        internal static BleCommonCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleCommonCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleCommonCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleCommonCfgT(native, skipVTables);
        }

        private BleCommonCfgT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private BleCommonCfgT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NrfBleDriver.BleCommonCfgT.__Internal*) native;
        }

        public BleCommonCfgT(global::NrfBleDriver.BleCommonCfgT __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>Vendor specific UUID configuration, cfg_id is</summary>
        public global::NrfBleDriver.BleCommonCfgVsUuidT VsUuidCfg
        {
            get
            {
                return global::NrfBleDriver.BleCommonCfgVsUuidT.__CreateInstance(__instance.vs_uuid_cfg);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.vs_uuid_cfg = *(global::NrfBleDriver.BleCommonCfgVsUuidT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>BLE Configuration type, wrapping the module specific configurations.</summary>
    public unsafe partial struct BleCfgT
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleConnCfgT.__Internal conn_cfg;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleCommonCfgT.__Internal common_cfg;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapCfgT.__Internal gap_cfg;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGattsCfgT.__Internal gatts_cfg;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_cfg_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        private BleCfgT.__Internal __instance;
        internal BleCfgT.__Internal __Instance => __instance;

        internal static BleCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleCfgT(native, skipVTables);
        }

        private BleCfgT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private BleCfgT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NrfBleDriver.BleCfgT.__Internal*) native;
        }

        public BleCfgT(global::NrfBleDriver.BleCfgT __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>Connection specific configurations, cfg_id inseries.</summary>
        public global::NrfBleDriver.BleConnCfgT ConnCfg
        {
            get
            {
                return global::NrfBleDriver.BleConnCfgT.__CreateInstance(__instance.conn_cfg);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.conn_cfg = *(global::NrfBleDriver.BleConnCfgT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Global common configurations, cfg_id inseries.</summary>
        public global::NrfBleDriver.BleCommonCfgT CommonCfg;

        /// <summary>Global GAP configurations, cfg_id inseries.</summary>
        public global::NrfBleDriver.BleGapCfgT GapCfg;

        /// <summary>Global GATTS configuration, cfg_id inseries.</summary>
        public global::NrfBleDriver.BleGattsCfgT GattsCfg;
    }

    public unsafe partial class ble
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_enable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleEnable(__IntPtr adapter, uint* p_app_ram_base);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_cfg_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleCfgSet(__IntPtr adapter, uint cfg_id, __IntPtr p_cfg, uint app_ram_base);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_evt_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleEvtGet(__IntPtr adapter, byte* p_dest, ushort* p_len);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_uuid_vs_add", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleUuidVsAdd(__IntPtr adapter, __IntPtr p_vs_uuid, byte* p_uuid_type);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_uuid_decode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleUuidDecode(__IntPtr adapter, byte uuid_le_len, byte* p_uuid_le, __IntPtr p_uuid);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_uuid_encode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleUuidEncode(__IntPtr adapter, __IntPtr p_uuid, byte* p_uuid_le_len, byte* p_uuid_le);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_version_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleVersionGet(__IntPtr adapter, __IntPtr p_version);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_user_mem_reply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleUserMemReply(__IntPtr adapter, ushort conn_handle, __IntPtr p_block);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_opt_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleOptSet(__IntPtr adapter, uint opt_id, __IntPtr p_opt);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_opt_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleOptGet(__IntPtr adapter, uint opt_id, __IntPtr p_opt);
        }

        public static uint SdBleEnable(global::NrfBleDriver.AdapterT adapter, ref uint p_app_ram_base)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (uint* __p_app_ram_base1 = &p_app_ram_base)
            {
                var __arg1 = __p_app_ram_base1;
                var __ret = __Internal.SdBleEnable(__arg0, __arg1);
                return __ret;
            }
        }

        public static uint SdBleCfgSet(global::NrfBleDriver.AdapterT adapter, uint cfg_id, global::NrfBleDriver.BleCfgT p_cfg, uint app_ram_base)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var ____arg2 = p_cfg.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var __ret = __Internal.SdBleCfgSet(__arg0, cfg_id, __arg2, app_ram_base);
            return __ret;
        }

        public static uint SdBleEvtGet(global::NrfBleDriver.AdapterT adapter, byte* p_dest, ref ushort p_len)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (ushort* __p_len2 = &p_len)
            {
                var __arg2 = __p_len2;
                var __ret = __Internal.SdBleEvtGet(__arg0, p_dest, __arg2);
                return __ret;
            }
        }

        public static uint SdBleUuidVsAdd(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleUuid128T p_vs_uuid, byte* p_uuid_type)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_vs_uuid is null ? __IntPtr.Zero : p_vs_uuid.__Instance;
            var __ret = __Internal.SdBleUuidVsAdd(__arg0, __arg1, p_uuid_type);
            return __ret;
        }

        public static uint SdBleUuidDecode(global::NrfBleDriver.AdapterT adapter, byte uuid_le_len, byte* p_uuid_le, global::NrfBleDriver.BleUuidT p_uuid)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg3 = p_uuid is null ? __IntPtr.Zero : p_uuid.__Instance;
            var __ret = __Internal.SdBleUuidDecode(__arg0, uuid_le_len, p_uuid_le, __arg3);
            return __ret;
        }

        public static uint SdBleUuidEncode(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleUuidT p_uuid, byte* p_uuid_le_len, byte* p_uuid_le)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_uuid is null ? __IntPtr.Zero : p_uuid.__Instance;
            var __ret = __Internal.SdBleUuidEncode(__arg0, __arg1, p_uuid_le_len, p_uuid_le);
            return __ret;
        }

        public static uint SdBleVersionGet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleVersionT p_version)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_version is null ? __IntPtr.Zero : p_version.__Instance;
            var __ret = __Internal.SdBleVersionGet(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleUserMemReply(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleUserMemBlockT p_block)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_block is null ? __IntPtr.Zero : p_block.__Instance;
            var __ret = __Internal.SdBleUserMemReply(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleOptSet(global::NrfBleDriver.AdapterT adapter, uint opt_id, global::NrfBleDriver.BleOptT p_opt)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var ____arg2 = p_opt.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var __ret = __Internal.SdBleOptSet(__arg0, opt_id, __arg2);
            return __ret;
        }

        public static uint SdBleOptGet(global::NrfBleDriver.AdapterT adapter, uint opt_id, global::NrfBleDriver.BleOptT p_opt)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var ____arg2 = p_opt.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var __ret = __Internal.SdBleOptGet(__arg0, opt_id, __arg2);
            return __ret;
        }
    }

    /// <summary>128 bit UUID values.</summary>
    /// <summary>Bluetooth Low Energy UUID type, encapsulates both 16-bit and 128-bit UUIDs.</summary>
    /// <summary>Data structure.</summary>
    /// <summary>128 bit UUID values.</summary>
    public unsafe partial class BleUuid128T : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal fixed byte uuid128[16];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_uuid128_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleUuid128T> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleUuid128T>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleUuid128T managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleUuid128T managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleUuid128T __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleUuid128T(native.ToPointer(), skipVTables);
        }

        internal static BleUuid128T __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleUuid128T)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleUuid128T __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleUuid128T(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleUuid128T(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleUuid128T(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleUuid128T()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleUuid128T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleUuid128T(global::NrfBleDriver.BleUuid128T __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleUuid128T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleUuid128T.__Internal*) __Instance) = *((global::NrfBleDriver.BleUuid128T.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Little-Endian UUID bytes.</summary>
        public byte[] Uuid128
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->uuid128, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->uuid128[i] = value[i];
                }
            }
        }
    }

    /// <summary>Bluetooth Low Energy UUID type, encapsulates both 16-bit and 128-bit UUIDs.</summary>
    public unsafe partial class BleUuidT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal ushort uuid;
            internal byte type;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_uuid_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleUuidT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleUuidT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleUuidT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleUuidT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleUuidT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleUuidT(native.ToPointer(), skipVTables);
        }

        internal static BleUuidT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleUuidT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleUuidT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleUuidT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleUuidT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleUuidT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleUuidT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleUuidT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleUuidT(global::NrfBleDriver.BleUuidT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleUuidT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleUuidT.__Internal*) __Instance) = *((global::NrfBleDriver.BleUuidT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>16-bit UUID value or octets 12-13 of 128-bit UUID.</summary>
        public ushort Uuid
        {
            get
            {
                return ((__Internal*)__Instance)->uuid;
            }

            set
            {
                ((__Internal*)__Instance)->uuid = value;
            }
        }

        /// <summary>UUID type, seeIf type isthe value of uuid is undefined.</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }
    }

    /// <summary>Data structure.</summary>
    public unsafe partial class BleDataT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr p_data;
            internal ushort len;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_data_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleDataT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleDataT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleDataT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleDataT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleDataT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleDataT(native.ToPointer(), skipVTables);
        }

        internal static BleDataT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleDataT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleDataT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleDataT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleDataT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleDataT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleDataT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleDataT(global::NrfBleDriver.BleDataT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleDataT.__Internal*) __Instance) = *((global::NrfBleDriver.BleDataT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Pointer to the data buffer provided to/from the application.</summary>
        public byte* PData
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_data;
            }

            set
            {
                ((__Internal*)__Instance)->p_data = (__IntPtr) value;
            }
        }

        /// <summary>Length of the data buffer, in bytes.</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }
    }

    /// <summary>GAP API SVC numbers.</summary>
    public enum BLE_GAP_SVCS
    {
        /// <summary>Set own Bluetooth Address.</summary>
        SD_BLE_GAP_ADDR_SET = 108,
        /// <summary>Get own Bluetooth Address.</summary>
        SD_BLE_GAP_ADDR_GET = 109,
        /// <summary>Set active whitelist.</summary>
        SD_BLE_GAP_WHITELIST_SET = 110,
        /// <summary>Set device identity list.</summary>
        SD_BLE_GAP_DEVICE_IDENTITIES_SET = 111,
        /// <summary>Set Privacy settings</summary>
        SD_BLE_GAP_PRIVACY_SET = 112,
        /// <summary>Get Privacy settings</summary>
        SD_BLE_GAP_PRIVACY_GET = 113,
        /// <summary>Set Advertising Data.</summary>
        SD_BLE_GAP_ADV_DATA_SET = 114,
        /// <summary>Start Advertising.</summary>
        SD_BLE_GAP_ADV_START = 115,
        /// <summary>Stop Advertising.</summary>
        SD_BLE_GAP_ADV_STOP = 116,
        /// <summary>Connection Parameter Update.</summary>
        SD_BLE_GAP_CONN_PARAM_UPDATE = 117,
        /// <summary>Disconnect.</summary>
        SD_BLE_GAP_DISCONNECT = 118,
        /// <summary>Set TX Power.</summary>
        SD_BLE_GAP_TX_POWER_SET = 119,
        /// <summary>Set Appearance.</summary>
        SD_BLE_GAP_APPEARANCE_SET = 120,
        /// <summary>Get Appearance.</summary>
        SD_BLE_GAP_APPEARANCE_GET = 121,
        /// <summary>Set PPCP.</summary>
        SD_BLE_GAP_PPCP_SET = 122,
        /// <summary>Get PPCP.</summary>
        SD_BLE_GAP_PPCP_GET = 123,
        /// <summary>Set Device Name.</summary>
        SD_BLE_GAP_DEVICE_NAME_SET = 124,
        /// <summary>Get Device Name.</summary>
        SD_BLE_GAP_DEVICE_NAME_GET = 125,
        /// <summary>Initiate Pairing/Bonding.</summary>
        SD_BLE_GAP_AUTHENTICATE = 126,
        /// <summary>Reply with Security Parameters.</summary>
        SD_BLE_GAP_SEC_PARAMS_REPLY = 127,
        /// <summary>Reply with an authentication key.</summary>
        SD_BLE_GAP_AUTH_KEY_REPLY = 128,
        /// <summary>Reply with an LE Secure Connections DHKey.</summary>
        SD_BLE_GAP_LESC_DHKEY_REPLY = 129,
        /// <summary>Notify of a keypress during an authentication procedure.</summary>
        SD_BLE_GAP_KEYPRESS_NOTIFY = 130,
        /// <summary>Get the local LE Secure Connections OOB data.</summary>
        SD_BLE_GAP_LESC_OOB_DATA_GET = 131,
        /// <summary>Set the remote LE Secure Connections OOB data.</summary>
        SD_BLE_GAP_LESC_OOB_DATA_SET = 132,
        /// <summary>Initiate encryption procedure.</summary>
        SD_BLE_GAP_ENCRYPT = 133,
        /// <summary>Reply with Security Information.</summary>
        SD_BLE_GAP_SEC_INFO_REPLY = 134,
        /// <summary>Obtain connection security level.</summary>
        SD_BLE_GAP_CONN_SEC_GET = 135,
        /// <summary>Start reporting of changes in RSSI.</summary>
        SD_BLE_GAP_RSSI_START = 136,
        /// <summary>Stop reporting of changes in RSSI.</summary>
        SD_BLE_GAP_RSSI_STOP = 137,
        /// <summary>Start Scanning.</summary>
        SD_BLE_GAP_SCAN_START = 138,
        /// <summary>Stop Scanning.</summary>
        SD_BLE_GAP_SCAN_STOP = 139,
        /// <summary>Connect.</summary>
        SD_BLE_GAP_CONNECT = 140,
        /// <summary>Cancel ongoing connection procedure.</summary>
        SD_BLE_GAP_CONNECT_CANCEL = 141,
        /// <summary>Get the last RSSI sample.</summary>
        SD_BLE_GAP_RSSI_GET = 142,
        /// <summary>Initiate or respond to a PHY Update Procedure.</summary>
        SD_BLE_GAP_PHY_UPDATE = 143,
        /// <summary>Initiate or respond to a Data Length Update Procedure.</summary>
        SD_BLE_GAP_DATA_LENGTH_UPDATE = 144
    }

    /// <summary>
    /// <para>GAP Event IDs.</para>
    /// <para>IDs that uniquely identify an event coming from the stack to the application.</para>
    /// </summary>
    public enum BLE_GAP_EVTS
    {
        /// <summary>Connection established.See</summary>
        BLE_GAP_EVT_CONNECTED = 16,
        /// <summary>Disconnected from peer.See</summary>
        BLE_GAP_EVT_DISCONNECTED = 17,
        /// <summary>Connection Parameters updated.See</summary>
        BLE_GAP_EVT_CONN_PARAM_UPDATE = 18,
        /// <summary>Request to provide security parameters.Reply withSee</summary>
        BLE_GAP_EVT_SEC_PARAMS_REQUEST = 19,
        /// <summary>Request to provide security information.Reply withSee</summary>
        BLE_GAP_EVT_SEC_INFO_REQUEST = 20,
        /// <summary>Request to display a passkey to the user.In LESC Numeric Comparison, reply withSee</summary>
        BLE_GAP_EVT_PASSKEY_DISPLAY = 21,
        /// <summary>Notification of a keypress on the remote device.See</summary>
        BLE_GAP_EVT_KEY_PRESSED = 22,
        /// <summary>Request to provide an authentication key.Reply withSee</summary>
        BLE_GAP_EVT_AUTH_KEY_REQUEST = 23,
        /// <summary>Request to calculate an LE Secure Connections DHKey.Reply withSee</summary>
        BLE_GAP_EVT_LESC_DHKEY_REQUEST = 24,
        /// <summary>Authentication procedure completed with status.See</summary>
        BLE_GAP_EVT_AUTH_STATUS = 25,
        /// <summary>Connection security updated.See</summary>
        BLE_GAP_EVT_CONN_SEC_UPDATE = 26,
        /// <summary>Timeout expired.See</summary>
        BLE_GAP_EVT_TIMEOUT = 27,
        /// <summary>RSSI report.See</summary>
        BLE_GAP_EVT_RSSI_CHANGED = 28,
        /// <summary>Advertising report.See</summary>
        BLE_GAP_EVT_ADV_REPORT = 29,
        /// <summary>Security Request.See</summary>
        BLE_GAP_EVT_SEC_REQUEST = 30,
        /// <summary>Connection Parameter Update Request.Reply withSee</summary>
        BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST = 31,
        /// <summary>Scan request report.See</summary>
        BLE_GAP_EVT_SCAN_REQ_REPORT = 32,
        /// <summary>PHY Update Request.Reply withSee</summary>
        BLE_GAP_EVT_PHY_UPDATE_REQUEST = 33,
        /// <summary>PHY Update Procedure is complete.See</summary>
        BLE_GAP_EVT_PHY_UPDATE = 34,
        /// <summary>Data Length Update Request.Reply withSee</summary>
        BLE_GAP_EVT_DATA_LENGTH_UPDATE_REQUEST = 35,
        /// <summary>LL Data Channel PDU payload length updated.See</summary>
        BLE_GAP_EVT_DATA_LENGTH_UPDATE = 36
    }

    /// <summary>
    /// <para>GAP Option IDs.</para>
    /// <para>IDs that uniquely identify a GAP option.</para>
    /// </summary>
    public enum BLE_GAP_OPTS
    {
        /// <summary>Channel Map.</summary>
        BLE_GAP_OPT_CH_MAP = 32,
        /// <summary>Local connection latency.</summary>
        BLE_GAP_OPT_LOCAL_CONN_LATENCY = 33,
        /// <summary>Set passkey.</summary>
        BLE_GAP_OPT_PASSKEY = 34,
        /// <summary>Scan request report.</summary>
        BLE_GAP_OPT_SCAN_REQ_REPORT = 35,
        /// <summary>Compatibility mode.</summary>
        BLE_GAP_OPT_COMPAT_MODE_1 = 36,
        /// <summary>Set Authenticated payload timeout.</summary>
        BLE_GAP_OPT_AUTH_PAYLOAD_TIMEOUT = 37,
        /// <summary>Disable slave latency.</summary>
        BLE_GAP_OPT_SLAVE_LATENCY_DISABLE = 38
    }

    /// <summary>GAP Configuration IDs.</summary>
    /// <remarks>IDs that uniquely identify a GAP configuration.</remarks>
    public enum BLE_GAP_CFGS
    {
        /// <summary>Role count configuration.</summary>
        BLE_GAP_CFG_ROLE_COUNT = 64,
        /// <summary>Device name configuration.</summary>
        BLE_GAP_CFG_DEVICE_NAME = 65
    }

    /// <summary>Bluetooth Low Energy address.</summary>
    /// <summary>GAP connection parameters.</summary>
    /// <remarks>
    /// <para>When ble_conn_params_t is received in an event, both min_conn_interval and</para>
    /// <para>max_conn_interval will be equal to the connection interval set by the central.</para>
    /// <para>If both conn_sup_timeout and max_conn_interval are specified, then the following constraint applies:</para>
    /// <para>conn_sup_timeout * 4 &gt; (1 + slave_latency) * max_conn_interval</para>
    /// <para>that corresponds to the following Bluetooth Spec requirement:</para>
    /// <para>The Supervision_Timeout in milliseconds shall be larger than</para>
    /// <para>(1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given in milliseconds.</para>
    /// </remarks>
    /// <summary>GAP connection security modes.</summary>
    /// <remarks>
    /// <para>Security Mode 0 Level 0: No access permissions at all (this level is not defined by the Bluetooth Core specification).</para>
    /// <para>Security Mode 1 Level 1: No security is needed (aka open link).</para>
    /// <para>Security Mode 1 Level 2: Encrypted link required, MITM protection not necessary.</para>
    /// <para>Security Mode 1 Level 3: MITM protected encrypted link required.</para>
    /// <para>Security Mode 1 Level 4: LESC MITM protected encrypted link using a 128-bit strength encryption key required.</para>
    /// <para>Security Mode 2 Level 1: Signing or encryption required, MITM protection not necessary.</para>
    /// <para>Security Mode 2 Level 2: MITM protected signing required, unless link is MITM protected encrypted.</para>
    /// </remarks>
    /// <summary>GAP connection security status.</summary>
    /// <summary>Identity Resolving Key.</summary>
    /// <summary>Channel mask for RF channels used in advertising.</summary>
    /// <summary>GAP advertising parameters.</summary>
    /// <summary>GAP scanning parameters.</summary>
    /// <summary>Privacy.</summary>
    /// <remarks>
    /// <para>The privacy feature provides a way for the device to avoid being tracked over a period of time.</para>
    /// <para>The privacy feature, when enabled, hides the local device identity and replaces it with a private address</para>
    /// <para>that is automatically refreshed at a specified interval.</para>
    /// <para>If a device still wants to be recognized by other peers, it needs to share it's Identity Resolving Key (IRK).</para>
    /// <para>With this key, a device can generate a random private address that can only be recognized by peers in possession of that key,</para>
    /// <para>and devices can establish connections without revealing their real identities.</para>
    /// <para>Both network privacy (and device privacy (are supported.</para>
    /// <para>If the device IRK is updated, the new IRK becomes the one to be distributed in all</para>
    /// <para>bonding procedures performed afterreturns.</para>
    /// <para>The IRK distributed during bonding procedure is the device IRK that is active whenis called.</para>
    /// </remarks>
    /// <summary>PHY preferences for TX and RX</summary>
    /// <remarks>tx_phys and rx_phys are bit fields. Multiple bits can be set in them to indicate multiple preferred PHYs for each direction.</remarks>
    /// <summary>Keys that can be exchanged during a bonding procedure.</summary>
    /// <summary>GAP security parameters.</summary>
    /// <summary>GAP Encryption Information.</summary>
    /// <summary>GAP Master Identification.</summary>
    /// <summary>GAP Signing Information.</summary>
    /// <summary>GAP LE Secure Connections P-256 Public Key.</summary>
    /// <summary>GAP LE Secure Connections DHKey.</summary>
    /// <summary>GAP LE Secure Connections OOB data.</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event Structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Security levels supported.</summary>
    /// <remarks>See Bluetooth Specification Version 4.2 Volume 3, Part C, Chapter 10, Section 10.2.1.</remarks>
    /// <summary>Encryption Key.</summary>
    /// <summary>Identity Key.</summary>
    /// <summary>Security Keys.</summary>
    /// <summary>Security key set for both local and peer keys.</summary>
    /// <summary>Data Length Update Procedure parameters.</summary>
    /// <summary>Data Length Update Procedure local limitation.</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>GAP event structure.</summary>
    /// <summary>BLE GAP connection configuration parameters, set with</summary>
    /// <remarks>
    /// <para>::NRF_ERROR_CONN_COUNT     The connection count for the connection configurations is zero.</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  One or more of the following is true:</para>
    /// <para>- The sum of conn_count for all connection configurations combined exceeds UINT8_MAX.</para>
    /// <para>- The event length is smaller than</para>
    /// </remarks>
    /// <summary>Configuration of maximum concurrent connections in the different connected roles, set with</summary>
    /// <remarks>
    /// <para>::NRF_ERROR_CONN_COUNT     The sum of periph_role_count and central_role_count is too</para>
    /// <para>large. The maximum supported sum of concurrent connections is</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  central_sec_count is larger than central_role_count.</para>
    /// </remarks>
    /// <summary>Device name and its properties, set with</summary>
    /// <remarks>
    /// <para>If the device name is not configured, the default device name will bethe maximum device name length will bevloc will be set toand the device name</para>
    /// <para>will have no write access.</para>
    /// <para>Ifis more thanand vloc is set tothe attribute table size must be increased to have room for the longer device name (see</para>
    /// <para>and</para>
    /// <para>If vloc is:</para>
    /// <para>- p_value must point to non-volatile memory (flash) or be NULL.</para>
    /// <para>- If p_value is NULL, the device name will initially be empty.</para>
    /// <para>If vloc is:</para>
    /// <para>- p_value cannot be NULL.</para>
    /// <para>- If the device name is writable, p_value must point to volatile memory (RAM).</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  One or more of the following is true:</para>
    /// <para>- Invalid device name location (vloc).</para>
    /// <para>- Invalid device name security mode.</para>
    /// <para>::NRF_ERROR_INVALID_LENGTH One or more of the following is true:</para>
    /// <para>- The device name length is invalid (must be between 0 and- The device name length is too long for the given Attribute Table.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED  Device name security mode is not supported.</para>
    /// </remarks>
    /// <summary>Configuration structure for GAP configurations.</summary>
    /// <summary>
    /// <para>Channel Map option.</para>
    /// <para>Used withto get the current channel map</para>
    /// <para>orto set a new channel map. When setting the</para>
    /// <para>channel map, it applies to all current and future connections. When getting the</para>
    /// <para>current channel map, it applies to a single connection and the connection handle</para>
    /// <para>must be supplied.</para>
    /// </summary>
    /// <remarks>
    /// <para>Setting the channel map may take some time, depending on connection parameters.</para>
    /// <para>The time taken may be different for each connection and the get operation will</para>
    /// <para>return the previous channel map until the new one has taken effect.</para>
    /// <para>After setting the channel map, by spec it can not be set again until at least 1 s has passed.</para>
    /// <para>See Bluetooth Specification Version 4.1 Volume 2, Part E, Section 7.3.46.</para>
    /// <para>::NRF_SUCCESS Get or set successful.</para>
    /// <para>::NRF_ERROR_BUSY Channel map was set again before enough time had passed.</para>
    /// <para>::NRF_ERROR_INVALID_STATE Invalid state to perform operation.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied for get.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED Returned by sd_ble_opt_set in peripheral-only SoftDevices.</para>
    /// </remarks>
    /// <summary>Local connection latency option.</summary>
    /// <remarks>
    /// <para>Local connection latency is a feature which enables the slave to improve</para>
    /// <para>current consumption by ignoring the slave latency set by the peer. The</para>
    /// <para>local connection latency can only be set to a multiple of the slave latency,</para>
    /// <para>and cannot be longer than half of the supervision timeout.</para>
    /// <para>Used withto set the local connection latency. The</para>
    /// <para>is not supported for this option, but the actual</para>
    /// <para>local connection latency (unless set to NULL) is set as a return parameter</para>
    /// <para>when setting the option.</para>
    /// <para>The latency set will be truncated down to the closest slave latency event</para>
    /// <para>multiple, or the nearest multiple before half of the supervision timeout.</para>
    /// <para>The local connection latency is disabled by default, and needs to be enabled for new</para>
    /// <para>connections and whenever the connection is updated.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED Get is not supported.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.</para>
    /// </remarks>
    /// <summary>Disable slave latency</summary>
    /// <remarks>
    /// <para>Used withto temporarily disable slave latency of a peripheral connection (seeAnd to re-enable it again.</para>
    /// <para>When disabled, the peripheral will ignore the slave_latency set by the central.</para>
    /// <para>Shall only be called on peripheral links.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED Get is not supported.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.</para>
    /// </remarks>
    /// <summary>Passkey Option.</summary>
    /// <remarks>
    /// <para>Structure containing the passkey to be used during pairing. This can be used withto make the SoftDevice use a preprogrammed passkey for authentication</para>
    /// <para>instead of generating a random one.</para>
    /// <para>Repeated pairing attempts using the same preprogrammed passkey makes pairing vulnerable to MITM attacks.</para>
    /// <para>is not supported for this option.</para>
    /// </remarks>
    /// <summary>Scan request report option.</summary>
    /// <remarks>
    /// <para>This can be used withto make the SoftDevice send</para>
    /// <para>events.</para>
    /// <para>Due to the limited space reserved for scan request report events,</para>
    /// <para>not all received scan requests will be reported.</para>
    /// <para>If whitelisting is used, only whitelisted requests are reported.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_INVALID_STATE When advertising is ongoing while the option is set.</para>
    /// </remarks>
    /// <summary>Compatibility mode 1 option.</summary>
    /// <remarks>
    /// <para>This can be used withto enable and disable</para>
    /// <para>compatibility mode 1. Compatibility mode 1 is disabled by default.</para>
    /// <para>Compatibility mode 1 enables interoperability with devices that do not support a value of</para>
    /// <para>0 for the WinOffset parameter in the Link Layer CONNECT_IND packet. This applies to a</para>
    /// <para>limited set of legacy peripheral devices from another vendor. Enabling this compatibility</para>
    /// <para>mode will only have an effect if the local device will act as a central device and</para>
    /// <para>initiate a connection to a peripheral device. In that case it may lead to the connection</para>
    /// <para>creation taking up to one connection interval longer to complete for all connections.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_INVALID_STATE When connection creation is ongoing while mode 1 is set.</para>
    /// </remarks>
    /// <summary>Authenticated payload timeout option.</summary>
    /// <remarks>
    /// <para>This can be used withto change the Authenticated payload timeout to a value other</para>
    /// <para>than the default of</para>
    /// <para>The authenticated payload timeout event ::BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD will be generated</para>
    /// <para>if auth_payload_timeout time has elapsed without receiving a packet with a valid MIC on an encrypted</para>
    /// <para>link.</para>
    /// <para>The LE ping procedure will be initiated before the timer expires to give the peer a chance</para>
    /// <para>to reset the timer. In addition the stack will try to prioritize running of LE ping over other</para>
    /// <para>activities to increase chances of finishing LE ping before timer expires. To avoid side-effects</para>
    /// <para>on other activities, it is recommended to use high timeout values.</para>
    /// <para>Recommended timeout &gt; 2*(connInterval * (6 + connSlaveLatency)).</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied. auth_payload_timeout was outside of allowed range.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.</para>
    /// </remarks>
    /// <summary>Option structure for GAP options.</summary>
    /// <summary>Bluetooth Low Energy address.</summary>
    public unsafe partial class BleGapAddrT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 7)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte addr_id_peer;

            [FieldOffset(0)]
            internal byte addr_type;

            [FieldOffset(1)]
            internal fixed byte addr[6];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_addr_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapAddrT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapAddrT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapAddrT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapAddrT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapAddrT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapAddrT(native.ToPointer(), skipVTables);
        }

        internal static BleGapAddrT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapAddrT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapAddrT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapAddrT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapAddrT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapAddrT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapAddrT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapAddrT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapAddrT(global::NrfBleDriver.BleGapAddrT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapAddrT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapAddrT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapAddrT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Only valid for peer addresses.</para>
        /// <para>Reference to peer in device identities list (as set withwhen peer is using privacy.</para>
        /// </summary>
        public byte AddrIdPeer
        {
            get
            {
                return ((__Internal*)__Instance)->addr_id_peer;
            }

            set
            {
                ((__Internal*)__Instance)->addr_id_peer = value;
            }
        }

        /// <summary>See</summary>
        public byte AddrType
        {
            get
            {
                return ((__Internal*)__Instance)->addr_type;
            }

            set
            {
                ((__Internal*)__Instance)->addr_type = value;
            }
        }

        /// <summary>48-bit address, LSB format.</summary>
        public byte[] Addr
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->addr, 6);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 6; i++)
                        ((__Internal*)__Instance)->addr[i] = value[i];
                }
            }
        }
    }

    /// <summary>GAP connection parameters.</summary>
    /// <remarks>
    /// <para>When ble_conn_params_t is received in an event, both min_conn_interval and</para>
    /// <para>max_conn_interval will be equal to the connection interval set by the central.</para>
    /// <para>If both conn_sup_timeout and max_conn_interval are specified, then the following constraint applies:</para>
    /// <para>conn_sup_timeout * 4 &gt; (1 + slave_latency) * max_conn_interval</para>
    /// <para>that corresponds to the following Bluetooth Spec requirement:</para>
    /// <para>The Supervision_Timeout in milliseconds shall be larger than</para>
    /// <para>(1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given in milliseconds.</para>
    /// </remarks>
    public unsafe partial class BleGapConnParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort min_conn_interval;
            internal ushort max_conn_interval;
            internal ushort slave_latency;
            internal ushort conn_sup_timeout;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_conn_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapConnParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapConnParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapConnParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapConnParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGapConnParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapConnParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapConnParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapConnParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapConnParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapConnParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapConnParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapConnParamsT(global::NrfBleDriver.BleGapConnParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapConnParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapConnParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Minimum Connection Interval in 1.25 ms units, see</summary>
        public ushort MinConnInterval
        {
            get
            {
                return ((__Internal*)__Instance)->min_conn_interval;
            }

            set
            {
                ((__Internal*)__Instance)->min_conn_interval = value;
            }
        }

        /// <summary>Maximum Connection Interval in 1.25 ms units, see</summary>
        public ushort MaxConnInterval
        {
            get
            {
                return ((__Internal*)__Instance)->max_conn_interval;
            }

            set
            {
                ((__Internal*)__Instance)->max_conn_interval = value;
            }
        }

        /// <summary>Slave Latency in number of connection events, see</summary>
        public ushort SlaveLatency
        {
            get
            {
                return ((__Internal*)__Instance)->slave_latency;
            }

            set
            {
                ((__Internal*)__Instance)->slave_latency = value;
            }
        }

        /// <summary>Connection Supervision Timeout in 10 ms units, see</summary>
        public ushort ConnSupTimeout
        {
            get
            {
                return ((__Internal*)__Instance)->conn_sup_timeout;
            }

            set
            {
                ((__Internal*)__Instance)->conn_sup_timeout = value;
            }
        }
    }

    /// <summary>GAP connection security modes.</summary>
    /// <remarks>
    /// <para>Security Mode 0 Level 0: No access permissions at all (this level is not defined by the Bluetooth Core specification).</para>
    /// <para>Security Mode 1 Level 1: No security is needed (aka open link).</para>
    /// <para>Security Mode 1 Level 2: Encrypted link required, MITM protection not necessary.</para>
    /// <para>Security Mode 1 Level 3: MITM protected encrypted link required.</para>
    /// <para>Security Mode 1 Level 4: LESC MITM protected encrypted link using a 128-bit strength encryption key required.</para>
    /// <para>Security Mode 2 Level 1: Signing or encryption required, MITM protection not necessary.</para>
    /// <para>Security Mode 2 Level 2: MITM protected signing required, unless link is MITM protected encrypted.</para>
    /// </remarks>
    public unsafe partial class BleGapConnSecModeT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte sm;

            [FieldOffset(0)]
            internal byte lv;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_conn_sec_mode_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnSecModeT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnSecModeT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapConnSecModeT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapConnSecModeT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapConnSecModeT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapConnSecModeT(native.ToPointer(), skipVTables);
        }

        internal static BleGapConnSecModeT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapConnSecModeT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapConnSecModeT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapConnSecModeT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapConnSecModeT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapConnSecModeT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapConnSecModeT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnSecModeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapConnSecModeT(global::NrfBleDriver.BleGapConnSecModeT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnSecModeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapConnSecModeT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapConnSecModeT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Security Mode (1 or 2), 0 for no permissions at all.</summary>
        public byte Sm
        {
            get
            {
                return ((__Internal*)__Instance)->sm;
            }

            set
            {
                ((__Internal*)__Instance)->sm = value;
            }
        }

        /// <summary>Level (1, 2, 3 or 4), 0 for no permissions at all.</summary>
        public byte Lv
        {
            get
            {
                return ((__Internal*)__Instance)->lv;
            }

            set
            {
                ((__Internal*)__Instance)->lv = value;
            }
        }
    }

    /// <summary>GAP connection security status.</summary>
    public unsafe partial class BleGapConnSecT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapConnSecModeT.__Internal sec_mode;
            internal byte encr_key_size;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_conn_sec_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnSecT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnSecT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapConnSecT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapConnSecT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapConnSecT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapConnSecT(native.ToPointer(), skipVTables);
        }

        internal static BleGapConnSecT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapConnSecT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapConnSecT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapConnSecT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapConnSecT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapConnSecT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapConnSecT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnSecT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapConnSecT(global::NrfBleDriver.BleGapConnSecT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnSecT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapConnSecT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapConnSecT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Currently active security mode for this connection.</summary>
        public global::NrfBleDriver.BleGapConnSecModeT SecMode
        {
            get
            {
                return global::NrfBleDriver.BleGapConnSecModeT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sec_mode));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sec_mode = *(global::NrfBleDriver.BleGapConnSecModeT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Length of currently active encryption key, 7 to 16 octets (only applicable for bonding procedures).</summary>
        public byte EncrKeySize
        {
            get
            {
                return ((__Internal*)__Instance)->encr_key_size;
            }

            set
            {
                ((__Internal*)__Instance)->encr_key_size = value;
            }
        }
    }

    /// <summary>Identity Resolving Key.</summary>
    public unsafe partial class BleGapIrkT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal fixed byte irk[16];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_irk_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapIrkT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapIrkT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapIrkT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapIrkT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapIrkT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapIrkT(native.ToPointer(), skipVTables);
        }

        internal static BleGapIrkT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapIrkT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapIrkT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapIrkT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapIrkT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapIrkT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapIrkT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapIrkT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapIrkT(global::NrfBleDriver.BleGapIrkT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapIrkT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapIrkT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapIrkT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Array containing IRK.</summary>
        public byte[] Irk
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->irk, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->irk[i] = value[i];
                }
            }
        }
    }

    /// <summary>Channel mask for RF channels used in advertising.</summary>
    public unsafe partial class BleGapAdvChMaskT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte ch_37_off;

            [FieldOffset(0)]
            internal byte ch_38_off;

            [FieldOffset(0)]
            internal byte ch_39_off;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_adv_ch_mask_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapAdvChMaskT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapAdvChMaskT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapAdvChMaskT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapAdvChMaskT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapAdvChMaskT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapAdvChMaskT(native.ToPointer(), skipVTables);
        }

        internal static BleGapAdvChMaskT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapAdvChMaskT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapAdvChMaskT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapAdvChMaskT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapAdvChMaskT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapAdvChMaskT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapAdvChMaskT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapAdvChMaskT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapAdvChMaskT(global::NrfBleDriver.BleGapAdvChMaskT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapAdvChMaskT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapAdvChMaskT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapAdvChMaskT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Setting this bit to 1 will turn off advertising on channel 37</summary>
        public byte Ch37Off
        {
            get
            {
                return ((__Internal*)__Instance)->ch_37_off;
            }

            set
            {
                ((__Internal*)__Instance)->ch_37_off = value;
            }
        }

        /// <summary>Setting this bit to 1 will turn off advertising on channel 38</summary>
        public byte Ch38Off
        {
            get
            {
                return ((__Internal*)__Instance)->ch_38_off;
            }

            set
            {
                ((__Internal*)__Instance)->ch_38_off = value;
            }
        }

        /// <summary>Setting this bit to 1 will turn off advertising on channel 39</summary>
        public byte Ch39Off
        {
            get
            {
                return ((__Internal*)__Instance)->ch_39_off;
            }

            set
            {
                ((__Internal*)__Instance)->ch_39_off = value;
            }
        }
    }

    /// <summary>GAP advertising parameters.</summary>
    public unsafe partial class BleGapAdvParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal byte type;
            internal __IntPtr p_peer_addr;
            internal byte fp;
            internal ushort interval;
            internal ushort timeout;
            internal global::NrfBleDriver.BleGapAdvChMaskT.__Internal channel_mask;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_adv_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapAdvParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapAdvParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapAdvParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapAdvParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapAdvParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapAdvParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGapAdvParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapAdvParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapAdvParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapAdvParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapAdvParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapAdvParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapAdvParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapAdvParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapAdvParamsT(global::NrfBleDriver.BleGapAdvParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapAdvParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapAdvParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapAdvParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>See</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>
        /// <para>Address of a known peer.</para>
        /// <para>- When privacy is enabled and the local device useaddresses, the device identity list is searched for a matching</para>
        /// <para>entry. If the local IRK for that device identity is set, the local IRK for that device will be used to generate the advertiser address field in the advertise packet.</para>
        /// <para>- If type isthis must be set to the targeted initiator. If the initiator is in the device identity list,</para>
        /// <para>the peer IRK for that device will be used to generate the initiator address field in the ADV_DIRECT_IND packet.</para>
        /// </summary>
        public global::NrfBleDriver.BleGapAddrT PPeerAddr
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGapAddrT.__GetOrCreateInstance(((__Internal*)__Instance)->p_peer_addr, false);
                return __result0;
            }
        }

        /// <summary>Filter Policy, see</summary>
        public byte Fp
        {
            get
            {
                return ((__Internal*)__Instance)->fp;
            }

            set
            {
                ((__Internal*)__Instance)->fp = value;
            }
        }

        /// <summary>
        /// <para>Advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20 ms to 10.24 s), see- If type equalsthis parameter must be set to 0 for high duty cycle directed advertising.</para>
        /// <para>- If type equalsset&lt;= interval&lt;=for low duty cycle advertising.</para>
        /// </summary>
        public ushort Interval
        {
            get
            {
                return ((__Internal*)__Instance)->interval;
            }

            set
            {
                ((__Internal*)__Instance)->interval = value;
            }
        }

        /// <summary>Advertising timeout between 0x0001 and 0x3FFF in seconds, 0x0000 disables timeout. See alsoIf type equalsthis parameter must be set to 0 for High duty cycle directed advertising.</summary>
        public ushort Timeout
        {
            get
            {
                return ((__Internal*)__Instance)->timeout;
            }

            set
            {
                ((__Internal*)__Instance)->timeout = value;
            }
        }

        /// <summary>Advertising channel mask. See</summary>
        public global::NrfBleDriver.BleGapAdvChMaskT ChannelMask
        {
            get
            {
                return global::NrfBleDriver.BleGapAdvChMaskT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->channel_mask));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->channel_mask = *(global::NrfBleDriver.BleGapAdvChMaskT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>GAP scanning parameters.</summary>
    public unsafe partial class BleGapScanParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte active;

            [FieldOffset(0)]
            internal byte use_whitelist;

            [FieldOffset(0)]
            internal byte adv_dir_report;

            [FieldOffset(2)]
            internal ushort interval;

            [FieldOffset(4)]
            internal ushort window;

            [FieldOffset(6)]
            internal ushort timeout;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_scan_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapScanParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapScanParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapScanParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapScanParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapScanParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapScanParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGapScanParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapScanParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapScanParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapScanParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapScanParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapScanParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapScanParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapScanParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapScanParamsT(global::NrfBleDriver.BleGapScanParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapScanParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapScanParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapScanParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>If 1, perform active scanning (scan requests).</summary>
        public byte Active
        {
            get
            {
                return ((__Internal*)__Instance)->active;
            }

            set
            {
                ((__Internal*)__Instance)->active = value;
            }
        }

        /// <summary>If 1, filter advertisers using current active whitelist.</summary>
        public byte UseWhitelist
        {
            get
            {
                return ((__Internal*)__Instance)->use_whitelist;
            }

            set
            {
                ((__Internal*)__Instance)->use_whitelist = value;
            }
        }

        /// <summary>
        /// <para>If 1, also report directed advertisements where the initiator field is set to a private resolvable address,</para>
        /// <para>even if the address did not resolve to an entry in the device identity list. A report will be generated</para>
        /// <para>even if the peer is not in the whitelist.</para>
        /// </summary>
        public byte AdvDirReport
        {
            get
            {
                return ((__Internal*)__Instance)->adv_dir_report;
            }

            set
            {
                ((__Internal*)__Instance)->adv_dir_report = value;
            }
        }

        /// <summary>Scan interval between 0x0004 and 0x4000 in 0.625 ms units (2.5 ms to 10.24 s).</summary>
        public ushort Interval
        {
            get
            {
                return ((__Internal*)__Instance)->interval;
            }

            set
            {
                ((__Internal*)__Instance)->interval = value;
            }
        }

        /// <summary>Scan window between 0x0004 and 0x4000 in 0.625 ms units (2.5 ms to 10.24 s).</summary>
        public ushort Window
        {
            get
            {
                return ((__Internal*)__Instance)->window;
            }

            set
            {
                ((__Internal*)__Instance)->window = value;
            }
        }

        /// <summary>Scan timeout between 0x0001 and 0xFFFF in seconds, 0x0000 disables timeout.</summary>
        public ushort Timeout
        {
            get
            {
                return ((__Internal*)__Instance)->timeout;
            }

            set
            {
                ((__Internal*)__Instance)->timeout = value;
            }
        }
    }

    /// <summary>Privacy.</summary>
    /// <remarks>
    /// <para>The privacy feature provides a way for the device to avoid being tracked over a period of time.</para>
    /// <para>The privacy feature, when enabled, hides the local device identity and replaces it with a private address</para>
    /// <para>that is automatically refreshed at a specified interval.</para>
    /// <para>If a device still wants to be recognized by other peers, it needs to share it's Identity Resolving Key (IRK).</para>
    /// <para>With this key, a device can generate a random private address that can only be recognized by peers in possession of that key,</para>
    /// <para>and devices can establish connections without revealing their real identities.</para>
    /// <para>Both network privacy (and device privacy (are supported.</para>
    /// <para>If the device IRK is updated, the new IRK becomes the one to be distributed in all</para>
    /// <para>bonding procedures performed afterreturns.</para>
    /// <para>The IRK distributed during bonding procedure is the device IRK that is active whenis called.</para>
    /// </remarks>
    public unsafe partial class BleGapPrivacyParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal byte privacy_mode;
            internal byte private_addr_type;
            internal ushort private_addr_cycle_s;
            internal __IntPtr p_device_irk;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_privacy_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapPrivacyParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapPrivacyParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapPrivacyParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapPrivacyParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapPrivacyParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapPrivacyParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGapPrivacyParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapPrivacyParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapPrivacyParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapPrivacyParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapPrivacyParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapPrivacyParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapPrivacyParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapPrivacyParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapPrivacyParamsT(global::NrfBleDriver.BleGapPrivacyParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapPrivacyParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapPrivacyParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapPrivacyParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Privacy mode, seeDefault is</summary>
        public byte PrivacyMode
        {
            get
            {
                return ((__Internal*)__Instance)->privacy_mode;
            }

            set
            {
                ((__Internal*)__Instance)->privacy_mode = value;
            }
        }

        /// <summary>The private address type must be eitheror</summary>
        public byte PrivateAddrType
        {
            get
            {
                return ((__Internal*)__Instance)->private_addr_type;
            }

            set
            {
                ((__Internal*)__Instance)->private_addr_type = value;
            }
        }

        /// <summary>Private address cycle interval in seconds. Providing an address cycle value of 0 will use the default value defined by</summary>
        public ushort PrivateAddrCycleS
        {
            get
            {
                return ((__Internal*)__Instance)->private_addr_cycle_s;
            }

            set
            {
                ((__Internal*)__Instance)->private_addr_cycle_s = value;
            }
        }

        /// <summary>
        /// <para>When used as input, pointer to IRK structure that will be used as the default IRK. If NULL, the device default IRK will be used.</para>
        /// <para>When used as output, pointer to IRK structure where the current default IRK will be written to. If NULL, this argument is ignored.</para>
        /// <para>By default, the default IRK is used to generate random private resolvable addresses for the local device unless instructed otherwise.</para>
        /// </summary>
        public global::NrfBleDriver.BleGapIrkT PDeviceIrk
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGapIrkT.__GetOrCreateInstance(((__Internal*)__Instance)->p_device_irk, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->p_device_irk = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>PHY preferences for TX and RX</summary>
    /// <remarks>tx_phys and rx_phys are bit fields. Multiple bits can be set in them to indicate multiple preferred PHYs for each direction.</remarks>
    public unsafe partial class BleGapPhysT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal byte tx_phys;
            internal byte rx_phys;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_phys_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapPhysT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapPhysT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapPhysT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapPhysT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapPhysT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapPhysT(native.ToPointer(), skipVTables);
        }

        internal static BleGapPhysT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapPhysT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapPhysT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapPhysT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapPhysT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapPhysT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapPhysT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapPhysT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapPhysT(global::NrfBleDriver.BleGapPhysT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapPhysT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapPhysT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapPhysT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Preferred transmit PHYs, see</summary>
        public byte TxPhys
        {
            get
            {
                return ((__Internal*)__Instance)->tx_phys;
            }

            set
            {
                ((__Internal*)__Instance)->tx_phys = value;
            }
        }

        /// <summary>Preferred receive PHYs, see</summary>
        public byte RxPhys
        {
            get
            {
                return ((__Internal*)__Instance)->rx_phys;
            }

            set
            {
                ((__Internal*)__Instance)->rx_phys = value;
            }
        }
    }

    /// <summary>Keys that can be exchanged during a bonding procedure.</summary>
    public unsafe partial class BleGapSecKdistT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte enc;

            [FieldOffset(0)]
            internal byte id;

            [FieldOffset(0)]
            internal byte sign;

            [FieldOffset(0)]
            internal byte link;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_sec_kdist_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecKdistT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecKdistT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapSecKdistT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapSecKdistT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapSecKdistT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapSecKdistT(native.ToPointer(), skipVTables);
        }

        internal static BleGapSecKdistT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapSecKdistT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapSecKdistT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapSecKdistT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapSecKdistT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapSecKdistT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapSecKdistT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecKdistT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapSecKdistT(global::NrfBleDriver.BleGapSecKdistT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecKdistT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapSecKdistT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapSecKdistT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Long Term Key and Master Identification.</summary>
        public byte Enc
        {
            get
            {
                return ((__Internal*)__Instance)->enc;
            }

            set
            {
                ((__Internal*)__Instance)->enc = value;
            }
        }

        /// <summary>Identity Resolving Key and Identity Address Information.</summary>
        public byte Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        /// <summary>Connection Signature Resolving Key.</summary>
        public byte Sign
        {
            get
            {
                return ((__Internal*)__Instance)->sign;
            }

            set
            {
                ((__Internal*)__Instance)->sign = value;
            }
        }

        /// <summary>Derive the Link Key from the LTK.</summary>
        public byte Link
        {
            get
            {
                return ((__Internal*)__Instance)->link;
            }

            set
            {
                ((__Internal*)__Instance)->link = value;
            }
        }
    }

    /// <summary>GAP security parameters.</summary>
    public unsafe partial class BleGapSecParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 5)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte bond;

            [FieldOffset(0)]
            internal byte mitm;

            [FieldOffset(0)]
            internal byte lesc;

            [FieldOffset(0)]
            internal byte keypress;

            [FieldOffset(0)]
            internal byte io_caps;

            [FieldOffset(0)]
            internal byte oob;

            [FieldOffset(1)]
            internal byte min_key_size;

            [FieldOffset(2)]
            internal byte max_key_size;

            [FieldOffset(3)]
            internal global::NrfBleDriver.BleGapSecKdistT.__Internal kdist_own;

            [FieldOffset(4)]
            internal global::NrfBleDriver.BleGapSecKdistT.__Internal kdist_peer;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_sec_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapSecParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapSecParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapSecParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapSecParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGapSecParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapSecParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapSecParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapSecParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapSecParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapSecParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapSecParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapSecParamsT(global::NrfBleDriver.BleGapSecParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapSecParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapSecParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Perform bonding.</summary>
        public byte Bond
        {
            get
            {
                return ((__Internal*)__Instance)->bond;
            }

            set
            {
                ((__Internal*)__Instance)->bond = value;
            }
        }

        /// <summary>Enable Man In The Middle protection.</summary>
        public byte Mitm
        {
            get
            {
                return ((__Internal*)__Instance)->mitm;
            }

            set
            {
                ((__Internal*)__Instance)->mitm = value;
            }
        }

        /// <summary>Enable LE Secure Connection pairing.</summary>
        public byte Lesc
        {
            get
            {
                return ((__Internal*)__Instance)->lesc;
            }

            set
            {
                ((__Internal*)__Instance)->lesc = value;
            }
        }

        /// <summary>Enable generation of keypress notifications.</summary>
        public byte Keypress
        {
            get
            {
                return ((__Internal*)__Instance)->keypress;
            }

            set
            {
                ((__Internal*)__Instance)->keypress = value;
            }
        }

        /// <summary>IO capabilities, see</summary>
        public byte IoCaps
        {
            get
            {
                return ((__Internal*)__Instance)->io_caps;
            }

            set
            {
                ((__Internal*)__Instance)->io_caps = value;
            }
        }

        /// <summary>
        /// <para>The OOB data flag.</para>
        /// <para>- In LE legacy pairing, this flag is set if a device has out of band authentication data.</para>
        /// <para>The OOB method is used if both of the devices have out of band authentication data.</para>
        /// <para>- In LE Secure Connections pairing, this flag is set if a device has the peer device's out of band authentication data.</para>
        /// <para>The OOB method is used if at least one device has the peer device's OOB data available.</para>
        /// </summary>
        public byte Oob
        {
            get
            {
                return ((__Internal*)__Instance)->oob;
            }

            set
            {
                ((__Internal*)__Instance)->oob = value;
            }
        }

        /// <summary>Minimum encryption key size in octets between 7 and 16. If 0 then not applicable in this instance.</summary>
        public byte MinKeySize
        {
            get
            {
                return ((__Internal*)__Instance)->min_key_size;
            }

            set
            {
                ((__Internal*)__Instance)->min_key_size = value;
            }
        }

        /// <summary>Maximum encryption key size in octets between min_key_size and 16.</summary>
        public byte MaxKeySize
        {
            get
            {
                return ((__Internal*)__Instance)->max_key_size;
            }

            set
            {
                ((__Internal*)__Instance)->max_key_size = value;
            }
        }

        /// <summary>Key distribution bitmap: keys that the local device will distribute.</summary>
        public global::NrfBleDriver.BleGapSecKdistT KdistOwn
        {
            get
            {
                return global::NrfBleDriver.BleGapSecKdistT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->kdist_own));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->kdist_own = *(global::NrfBleDriver.BleGapSecKdistT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Key distribution bitmap: keys that the remote device will distribute.</summary>
        public global::NrfBleDriver.BleGapSecKdistT KdistPeer
        {
            get
            {
                return global::NrfBleDriver.BleGapSecKdistT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->kdist_peer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->kdist_peer = *(global::NrfBleDriver.BleGapSecKdistT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>GAP Encryption Information.</summary>
    public unsafe partial class BleGapEncInfoT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 17)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed byte ltk[16];

            [FieldOffset(16)]
            internal byte lesc;

            [FieldOffset(16)]
            internal byte auth;

            [FieldOffset(16)]
            internal byte ltk_len;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_enc_info_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEncInfoT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEncInfoT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEncInfoT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEncInfoT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEncInfoT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEncInfoT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEncInfoT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEncInfoT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEncInfoT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEncInfoT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEncInfoT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEncInfoT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEncInfoT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEncInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEncInfoT(global::NrfBleDriver.BleGapEncInfoT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEncInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEncInfoT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEncInfoT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Long Term Key.</summary>
        public byte[] Ltk
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->ltk, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->ltk[i] = value[i];
                }
            }
        }

        /// <summary>Key generated using LE Secure Connections.</summary>
        public byte Lesc
        {
            get
            {
                return ((__Internal*)__Instance)->lesc;
            }

            set
            {
                ((__Internal*)__Instance)->lesc = value;
            }
        }

        /// <summary>Authenticated Key.</summary>
        public byte Auth
        {
            get
            {
                return ((__Internal*)__Instance)->auth;
            }

            set
            {
                ((__Internal*)__Instance)->auth = value;
            }
        }

        /// <summary>LTK length in octets.</summary>
        public byte LtkLen
        {
            get
            {
                return ((__Internal*)__Instance)->ltk_len;
            }

            set
            {
                ((__Internal*)__Instance)->ltk_len = value;
            }
        }
    }

    /// <summary>GAP Master Identification.</summary>
    public unsafe partial class BleGapMasterIdT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 10)]
        public partial struct __Internal
        {
            internal ushort ediv;
            internal fixed byte rand[8];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_master_id_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapMasterIdT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapMasterIdT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapMasterIdT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapMasterIdT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapMasterIdT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapMasterIdT(native.ToPointer(), skipVTables);
        }

        internal static BleGapMasterIdT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapMasterIdT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapMasterIdT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapMasterIdT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapMasterIdT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapMasterIdT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapMasterIdT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapMasterIdT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapMasterIdT(global::NrfBleDriver.BleGapMasterIdT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapMasterIdT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapMasterIdT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapMasterIdT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Encrypted Diversifier.</summary>
        public ushort Ediv
        {
            get
            {
                return ((__Internal*)__Instance)->ediv;
            }

            set
            {
                ((__Internal*)__Instance)->ediv = value;
            }
        }

        /// <summary>Random Number.</summary>
        public byte[] Rand
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->rand, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->rand[i] = value[i];
                }
            }
        }
    }

    /// <summary>GAP Signing Information.</summary>
    public unsafe partial class BleGapSignInfoT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal fixed byte csrk[16];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_sign_info_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSignInfoT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSignInfoT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapSignInfoT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapSignInfoT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapSignInfoT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapSignInfoT(native.ToPointer(), skipVTables);
        }

        internal static BleGapSignInfoT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapSignInfoT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapSignInfoT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapSignInfoT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapSignInfoT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapSignInfoT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapSignInfoT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSignInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapSignInfoT(global::NrfBleDriver.BleGapSignInfoT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSignInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapSignInfoT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapSignInfoT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Signature Resolving Key.</summary>
        public byte[] Csrk
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->csrk, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->csrk[i] = value[i];
                }
            }
        }
    }

    /// <summary>GAP LE Secure Connections P-256 Public Key.</summary>
    public unsafe partial class BleGapLescP256PkT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal fixed byte pk[64];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_lesc_p256_pk_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapLescP256PkT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapLescP256PkT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapLescP256PkT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapLescP256PkT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapLescP256PkT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapLescP256PkT(native.ToPointer(), skipVTables);
        }

        internal static BleGapLescP256PkT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapLescP256PkT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapLescP256PkT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapLescP256PkT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapLescP256PkT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapLescP256PkT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapLescP256PkT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapLescP256PkT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapLescP256PkT(global::NrfBleDriver.BleGapLescP256PkT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapLescP256PkT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapLescP256PkT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapLescP256PkT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>LE Secure Connections Elliptic Curve Diffie-Hellman P-256 Public Key. Stored in the standard SMP protocol format: {X,Y} both in little-endian.</summary>
        public byte[] Pk
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->pk, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->pk[i] = value[i];
                }
            }
        }
    }

    /// <summary>GAP LE Secure Connections DHKey.</summary>
    public unsafe partial class BleGapLescDhkeyT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal fixed byte key[32];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_lesc_dhkey_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapLescDhkeyT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapLescDhkeyT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapLescDhkeyT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapLescDhkeyT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapLescDhkeyT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapLescDhkeyT(native.ToPointer(), skipVTables);
        }

        internal static BleGapLescDhkeyT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapLescDhkeyT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapLescDhkeyT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapLescDhkeyT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapLescDhkeyT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapLescDhkeyT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapLescDhkeyT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapLescDhkeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapLescDhkeyT(global::NrfBleDriver.BleGapLescDhkeyT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapLescDhkeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapLescDhkeyT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapLescDhkeyT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>LE Secure Connections Elliptic Curve Diffie-Hellman Key. Stored in little-endian.</summary>
        public byte[] Key
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->key, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->key[i] = value[i];
                }
            }
        }
    }

    /// <summary>GAP LE Secure Connections OOB data.</summary>
    public unsafe partial class BleGapLescOobDataT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 39)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapAddrT.__Internal addr;
            internal fixed byte r[16];
            internal fixed byte c[16];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_lesc_oob_data_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapLescOobDataT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapLescOobDataT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapLescOobDataT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapLescOobDataT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapLescOobDataT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapLescOobDataT(native.ToPointer(), skipVTables);
        }

        internal static BleGapLescOobDataT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapLescOobDataT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapLescOobDataT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapLescOobDataT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapLescOobDataT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapLescOobDataT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapLescOobDataT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapLescOobDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapLescOobDataT(global::NrfBleDriver.BleGapLescOobDataT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapLescOobDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapLescOobDataT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapLescOobDataT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Bluetooth address of the device.</summary>
        public global::NrfBleDriver.BleGapAddrT Addr
        {
            get
            {
                return global::NrfBleDriver.BleGapAddrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->addr));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->addr = *(global::NrfBleDriver.BleGapAddrT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Random Number.</summary>
        public byte[] R
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->r, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->r[i] = value[i];
                }
            }
        }

        /// <summary>Confirm Value.</summary>
        public byte[] C
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->c, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->c[i] = value[i];
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtConnectedT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapAddrT.__Internal peer_addr;
            internal byte role;
            internal global::NrfBleDriver.BleGapConnParamsT.__Internal conn_params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_connected_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnectedT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnectedT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtConnectedT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtConnectedT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtConnectedT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtConnectedT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtConnectedT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtConnectedT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtConnectedT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtConnectedT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtConnectedT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtConnectedT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtConnectedT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnectedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtConnectedT(global::NrfBleDriver.BleGapEvtConnectedT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnectedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtConnectedT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtConnectedT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Bluetooth address of the peer device. If the peer_addr resolved:is set to 1</para>
        /// <para>and the address is the device's identity address.</para>
        /// </summary>
        public global::NrfBleDriver.BleGapAddrT PeerAddr
        {
            get
            {
                return global::NrfBleDriver.BleGapAddrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->peer_addr));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->peer_addr = *(global::NrfBleDriver.BleGapAddrT.__Internal*) value.__Instance;
            }
        }

        /// <summary>BLE role for this connection, see</summary>
        public byte Role
        {
            get
            {
                return ((__Internal*)__Instance)->role;
            }

            set
            {
                ((__Internal*)__Instance)->role = value;
            }
        }

        /// <summary>GAP Connection Parameters.</summary>
        public global::NrfBleDriver.BleGapConnParamsT ConnParams
        {
            get
            {
                return global::NrfBleDriver.BleGapConnParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->conn_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->conn_params = *(global::NrfBleDriver.BleGapConnParamsT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtDisconnectedT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte reason;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_disconnected_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtDisconnectedT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtDisconnectedT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtDisconnectedT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtDisconnectedT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtDisconnectedT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtDisconnectedT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtDisconnectedT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtDisconnectedT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtDisconnectedT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtDisconnectedT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtDisconnectedT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtDisconnectedT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtDisconnectedT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtDisconnectedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtDisconnectedT(global::NrfBleDriver.BleGapEvtDisconnectedT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtDisconnectedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtDisconnectedT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtDisconnectedT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>HCI error code, see</summary>
        public byte Reason
        {
            get
            {
                return ((__Internal*)__Instance)->reason;
            }

            set
            {
                ((__Internal*)__Instance)->reason = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtConnParamUpdateT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapConnParamsT.__Internal conn_params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_conn_param_update_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnParamUpdateT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnParamUpdateT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtConnParamUpdateT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtConnParamUpdateT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtConnParamUpdateT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtConnParamUpdateT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtConnParamUpdateT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtConnParamUpdateT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtConnParamUpdateT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtConnParamUpdateT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtConnParamUpdateT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtConnParamUpdateT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtConnParamUpdateT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnParamUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtConnParamUpdateT(global::NrfBleDriver.BleGapEvtConnParamUpdateT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnParamUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtConnParamUpdateT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtConnParamUpdateT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>GAP Connection Parameters.</summary>
        public global::NrfBleDriver.BleGapConnParamsT ConnParams
        {
            get
            {
                return global::NrfBleDriver.BleGapConnParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->conn_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->conn_params = *(global::NrfBleDriver.BleGapConnParamsT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtPhyUpdateRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapPhysT.__Internal peer_preferred_phys;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_phy_update_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtPhyUpdateRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtPhyUpdateRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtPhyUpdateRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtPhyUpdateRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtPhyUpdateRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtPhyUpdateRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtPhyUpdateRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtPhyUpdateRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtPhyUpdateRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtPhyUpdateRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtPhyUpdateRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtPhyUpdateRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtPhyUpdateRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtPhyUpdateRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtPhyUpdateRequestT(global::NrfBleDriver.BleGapEvtPhyUpdateRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtPhyUpdateRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtPhyUpdateRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtPhyUpdateRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The PHYs the peer prefers to use.</summary>
        public global::NrfBleDriver.BleGapPhysT PeerPreferredPhys
        {
            get
            {
                return global::NrfBleDriver.BleGapPhysT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->peer_preferred_phys));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->peer_preferred_phys = *(global::NrfBleDriver.BleGapPhysT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event Structure for</summary>
    public unsafe partial class BleGapEvtPhyUpdateT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 3)]
        public partial struct __Internal
        {
            internal byte status;
            internal byte tx_phy;
            internal byte rx_phy;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_phy_update_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtPhyUpdateT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtPhyUpdateT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtPhyUpdateT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtPhyUpdateT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtPhyUpdateT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtPhyUpdateT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtPhyUpdateT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtPhyUpdateT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtPhyUpdateT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtPhyUpdateT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtPhyUpdateT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtPhyUpdateT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtPhyUpdateT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtPhyUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtPhyUpdateT(global::NrfBleDriver.BleGapEvtPhyUpdateT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtPhyUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtPhyUpdateT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtPhyUpdateT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Status of the procedure, see</summary>
        public byte Status
        {
            get
            {
                return ((__Internal*)__Instance)->status;
            }

            set
            {
                ((__Internal*)__Instance)->status = value;
            }
        }

        /// <summary>TX PHY for this connection, see</summary>
        public byte TxPhy
        {
            get
            {
                return ((__Internal*)__Instance)->tx_phy;
            }

            set
            {
                ((__Internal*)__Instance)->tx_phy = value;
            }
        }

        /// <summary>RX PHY for this connection, see</summary>
        public byte RxPhy
        {
            get
            {
                return ((__Internal*)__Instance)->rx_phy;
            }

            set
            {
                ((__Internal*)__Instance)->rx_phy = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtSecParamsRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 5)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapSecParamsT.__Internal peer_params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_sec_params_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtSecParamsRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtSecParamsRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtSecParamsRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtSecParamsRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtSecParamsRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtSecParamsRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtSecParamsRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtSecParamsRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtSecParamsRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtSecParamsRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtSecParamsRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtSecParamsRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtSecParamsRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtSecParamsRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtSecParamsRequestT(global::NrfBleDriver.BleGapEvtSecParamsRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtSecParamsRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtSecParamsRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtSecParamsRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Initiator Security Parameters.</summary>
        public global::NrfBleDriver.BleGapSecParamsT PeerParams
        {
            get
            {
                return global::NrfBleDriver.BleGapSecParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->peer_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->peer_params = *(global::NrfBleDriver.BleGapSecParamsT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtSecInfoRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapAddrT.__Internal peer_addr;

            [FieldOffset(8)]
            internal global::NrfBleDriver.BleGapMasterIdT.__Internal master_id;

            [FieldOffset(18)]
            internal byte enc_info;

            [FieldOffset(18)]
            internal byte id_info;

            [FieldOffset(18)]
            internal byte sign_info;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_sec_info_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtSecInfoRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtSecInfoRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtSecInfoRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtSecInfoRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtSecInfoRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtSecInfoRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtSecInfoRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtSecInfoRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtSecInfoRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtSecInfoRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtSecInfoRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtSecInfoRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtSecInfoRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtSecInfoRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtSecInfoRequestT(global::NrfBleDriver.BleGapEvtSecInfoRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtSecInfoRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtSecInfoRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtSecInfoRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Bluetooth address of the peer device.</summary>
        public global::NrfBleDriver.BleGapAddrT PeerAddr
        {
            get
            {
                return global::NrfBleDriver.BleGapAddrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->peer_addr));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->peer_addr = *(global::NrfBleDriver.BleGapAddrT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Master Identification for LTK lookup.</summary>
        public global::NrfBleDriver.BleGapMasterIdT MasterId
        {
            get
            {
                return global::NrfBleDriver.BleGapMasterIdT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->master_id));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->master_id = *(global::NrfBleDriver.BleGapMasterIdT.__Internal*) value.__Instance;
            }
        }

        /// <summary>If 1, Encryption Information required.</summary>
        public byte EncInfo
        {
            get
            {
                return ((__Internal*)__Instance)->enc_info;
            }

            set
            {
                ((__Internal*)__Instance)->enc_info = value;
            }
        }

        /// <summary>If 1, Identity Information required.</summary>
        public byte IdInfo
        {
            get
            {
                return ((__Internal*)__Instance)->id_info;
            }

            set
            {
                ((__Internal*)__Instance)->id_info = value;
            }
        }

        /// <summary>If 1, Signing Information required.</summary>
        public byte SignInfo
        {
            get
            {
                return ((__Internal*)__Instance)->sign_info;
            }

            set
            {
                ((__Internal*)__Instance)->sign_info = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtPasskeyDisplayT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 7)]
        public partial struct __Internal
        {
            internal fixed byte passkey[6];
            internal byte match_request;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_passkey_display_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtPasskeyDisplayT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtPasskeyDisplayT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtPasskeyDisplayT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtPasskeyDisplayT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtPasskeyDisplayT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtPasskeyDisplayT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtPasskeyDisplayT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtPasskeyDisplayT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtPasskeyDisplayT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtPasskeyDisplayT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtPasskeyDisplayT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtPasskeyDisplayT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtPasskeyDisplayT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtPasskeyDisplayT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtPasskeyDisplayT(global::NrfBleDriver.BleGapEvtPasskeyDisplayT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtPasskeyDisplayT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtPasskeyDisplayT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtPasskeyDisplayT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>6-digit passkey in ASCII ('0'-'9' digits only).</summary>
        public byte[] Passkey
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->passkey, 6);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 6; i++)
                        ((__Internal*)__Instance)->passkey[i] = value[i];
                }
            }
        }

        /// <summary>
        /// <para>If 1 requires the application to report the match usingwith eitherif there is no match or</para>
        /// <para>if there is a match.</para>
        /// </summary>
        public byte MatchRequest
        {
            get
            {
                return ((__Internal*)__Instance)->match_request;
            }

            set
            {
                ((__Internal*)__Instance)->match_request = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtKeyPressedT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte kp_not;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_key_pressed_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtKeyPressedT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtKeyPressedT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtKeyPressedT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtKeyPressedT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtKeyPressedT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtKeyPressedT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtKeyPressedT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtKeyPressedT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtKeyPressedT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtKeyPressedT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtKeyPressedT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtKeyPressedT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtKeyPressedT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtKeyPressedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtKeyPressedT(global::NrfBleDriver.BleGapEvtKeyPressedT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtKeyPressedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtKeyPressedT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtKeyPressedT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Keypress notification type, see</summary>
        public byte KpNot
        {
            get
            {
                return ((__Internal*)__Instance)->kp_not;
            }

            set
            {
                ((__Internal*)__Instance)->kp_not = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtAuthKeyRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte key_type;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_auth_key_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtAuthKeyRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtAuthKeyRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtAuthKeyRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtAuthKeyRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtAuthKeyRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtAuthKeyRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtAuthKeyRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtAuthKeyRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtAuthKeyRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtAuthKeyRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtAuthKeyRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtAuthKeyRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtAuthKeyRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtAuthKeyRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtAuthKeyRequestT(global::NrfBleDriver.BleGapEvtAuthKeyRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtAuthKeyRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtAuthKeyRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtAuthKeyRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>See</summary>
        public byte KeyType
        {
            get
            {
                return ((__Internal*)__Instance)->key_type;
            }

            set
            {
                ((__Internal*)__Instance)->key_type = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtLescDhkeyRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr p_pk_peer;
            internal byte oobd_req;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_lesc_dhkey_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtLescDhkeyRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtLescDhkeyRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtLescDhkeyRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtLescDhkeyRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtLescDhkeyRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtLescDhkeyRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtLescDhkeyRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtLescDhkeyRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtLescDhkeyRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtLescDhkeyRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtLescDhkeyRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtLescDhkeyRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtLescDhkeyRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtLescDhkeyRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtLescDhkeyRequestT(global::NrfBleDriver.BleGapEvtLescDhkeyRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtLescDhkeyRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtLescDhkeyRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtLescDhkeyRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>LE Secure Connections remote P-256 Public Key. This will point to the application-supplied memory</para>
        /// <para>inside the keyset during the call to</para>
        /// </summary>
        public global::NrfBleDriver.BleGapLescP256PkT PPkPeer
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGapLescP256PkT.__GetOrCreateInstance(((__Internal*)__Instance)->p_pk_peer, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->p_pk_peer = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>LESC OOB data required. A call tois required to complete the procedure.</summary>
        public byte OobdReq
        {
            get
            {
                return ((__Internal*)__Instance)->oobd_req;
            }

            set
            {
                ((__Internal*)__Instance)->oobd_req = value;
            }
        }
    }

    /// <summary>Security levels supported.</summary>
    /// <remarks>See Bluetooth Specification Version 4.2 Volume 3, Part C, Chapter 10, Section 10.2.1.</remarks>
    public unsafe partial class BleGapSecLevelsT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte lv1;

            [FieldOffset(0)]
            internal byte lv2;

            [FieldOffset(0)]
            internal byte lv3;

            [FieldOffset(0)]
            internal byte lv4;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_sec_levels_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecLevelsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecLevelsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapSecLevelsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapSecLevelsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapSecLevelsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapSecLevelsT(native.ToPointer(), skipVTables);
        }

        internal static BleGapSecLevelsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapSecLevelsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapSecLevelsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapSecLevelsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapSecLevelsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapSecLevelsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapSecLevelsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecLevelsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapSecLevelsT(global::NrfBleDriver.BleGapSecLevelsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecLevelsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapSecLevelsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapSecLevelsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>If 1: Level 1 is supported.</summary>
        public byte Lv1
        {
            get
            {
                return ((__Internal*)__Instance)->lv1;
            }

            set
            {
                ((__Internal*)__Instance)->lv1 = value;
            }
        }

        /// <summary>If 1: Level 2 is supported.</summary>
        public byte Lv2
        {
            get
            {
                return ((__Internal*)__Instance)->lv2;
            }

            set
            {
                ((__Internal*)__Instance)->lv2 = value;
            }
        }

        /// <summary>If 1: Level 3 is supported.</summary>
        public byte Lv3
        {
            get
            {
                return ((__Internal*)__Instance)->lv3;
            }

            set
            {
                ((__Internal*)__Instance)->lv3 = value;
            }
        }

        /// <summary>If 1: Level 4 is supported.</summary>
        public byte Lv4
        {
            get
            {
                return ((__Internal*)__Instance)->lv4;
            }

            set
            {
                ((__Internal*)__Instance)->lv4 = value;
            }
        }
    }

    /// <summary>Encryption Key.</summary>
    public unsafe partial class BleGapEncKeyT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapEncInfoT.__Internal enc_info;
            internal global::NrfBleDriver.BleGapMasterIdT.__Internal master_id;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_enc_key_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEncKeyT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEncKeyT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEncKeyT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEncKeyT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEncKeyT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEncKeyT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEncKeyT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEncKeyT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEncKeyT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEncKeyT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEncKeyT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEncKeyT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEncKeyT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEncKeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEncKeyT(global::NrfBleDriver.BleGapEncKeyT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEncKeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEncKeyT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEncKeyT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Encryption Information.</summary>
        public global::NrfBleDriver.BleGapEncInfoT EncInfo
        {
            get
            {
                return global::NrfBleDriver.BleGapEncInfoT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->enc_info));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->enc_info = *(global::NrfBleDriver.BleGapEncInfoT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Master Identification.</summary>
        public global::NrfBleDriver.BleGapMasterIdT MasterId
        {
            get
            {
                return global::NrfBleDriver.BleGapMasterIdT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->master_id));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->master_id = *(global::NrfBleDriver.BleGapMasterIdT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Identity Key.</summary>
    public unsafe partial class BleGapIdKeyT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 23)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapIrkT.__Internal id_info;
            internal global::NrfBleDriver.BleGapAddrT.__Internal id_addr_info;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_id_key_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapIdKeyT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapIdKeyT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapIdKeyT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapIdKeyT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapIdKeyT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapIdKeyT(native.ToPointer(), skipVTables);
        }

        internal static BleGapIdKeyT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapIdKeyT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapIdKeyT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapIdKeyT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapIdKeyT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapIdKeyT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapIdKeyT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapIdKeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapIdKeyT(global::NrfBleDriver.BleGapIdKeyT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapIdKeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapIdKeyT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapIdKeyT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Identity Resolving Key.</summary>
        public global::NrfBleDriver.BleGapIrkT IdInfo
        {
            get
            {
                return global::NrfBleDriver.BleGapIrkT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->id_info));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->id_info = *(global::NrfBleDriver.BleGapIrkT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Identity Address.</summary>
        public global::NrfBleDriver.BleGapAddrT IdAddrInfo
        {
            get
            {
                return global::NrfBleDriver.BleGapAddrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->id_addr_info));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->id_addr_info = *(global::NrfBleDriver.BleGapAddrT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Security Keys.</summary>
    public unsafe partial class BleGapSecKeysT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr p_enc_key;
            internal __IntPtr p_id_key;
            internal __IntPtr p_sign_key;
            internal __IntPtr p_pk;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_sec_keys_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecKeysT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecKeysT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapSecKeysT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapSecKeysT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapSecKeysT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapSecKeysT(native.ToPointer(), skipVTables);
        }

        internal static BleGapSecKeysT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapSecKeysT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapSecKeysT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapSecKeysT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapSecKeysT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapSecKeysT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapSecKeysT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecKeysT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapSecKeysT(global::NrfBleDriver.BleGapSecKeysT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecKeysT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapSecKeysT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapSecKeysT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Encryption Key, or NULL.</summary>
        public global::NrfBleDriver.BleGapEncKeyT PEncKey
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGapEncKeyT.__GetOrCreateInstance(((__Internal*)__Instance)->p_enc_key, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->p_enc_key = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Identity Key, or NULL.</summary>
        public global::NrfBleDriver.BleGapIdKeyT PIdKey
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGapIdKeyT.__GetOrCreateInstance(((__Internal*)__Instance)->p_id_key, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->p_id_key = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Signing Key, or NULL.</summary>
        public global::NrfBleDriver.BleGapSignInfoT PSignKey
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGapSignInfoT.__GetOrCreateInstance(((__Internal*)__Instance)->p_sign_key, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->p_sign_key = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>
        /// <para>LE Secure Connections P-256 Public Key. When in debug mode the application must use the value defined</para>
        /// <para>in the Core Bluetooth Specification v4.2 Vol.3, Part H, Section 2.3.5.6.1</para>
        /// </summary>
        public global::NrfBleDriver.BleGapLescP256PkT PPk
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGapLescP256PkT.__GetOrCreateInstance(((__Internal*)__Instance)->p_pk, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->p_pk = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Security key set for both local and peer keys.</summary>
    public unsafe partial class BleGapSecKeysetT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapSecKeysT.__Internal keys_own;
            internal global::NrfBleDriver.BleGapSecKeysT.__Internal keys_peer;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_sec_keyset_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecKeysetT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecKeysetT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapSecKeysetT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapSecKeysetT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapSecKeysetT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapSecKeysetT(native.ToPointer(), skipVTables);
        }

        internal static BleGapSecKeysetT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapSecKeysetT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapSecKeysetT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapSecKeysetT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapSecKeysetT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapSecKeysetT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapSecKeysetT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecKeysetT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapSecKeysetT(global::NrfBleDriver.BleGapSecKeysetT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecKeysetT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapSecKeysetT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapSecKeysetT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Keys distributed by the local device. For LE Secure Connections the encryption key will be generated locally and will always be stored if bonding.</summary>
        public global::NrfBleDriver.BleGapSecKeysT KeysOwn
        {
            get
            {
                return global::NrfBleDriver.BleGapSecKeysT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->keys_own));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->keys_own = *(global::NrfBleDriver.BleGapSecKeysT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Keys distributed by the remote device. For LE Secure Connections, p_enc_key must always be NULL.</summary>
        public global::NrfBleDriver.BleGapSecKeysT KeysPeer
        {
            get
            {
                return global::NrfBleDriver.BleGapSecKeysT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->keys_peer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->keys_peer = *(global::NrfBleDriver.BleGapSecKeysT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Data Length Update Procedure parameters.</summary>
    public unsafe partial class BleGapDataLengthParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort max_tx_octets;
            internal ushort max_rx_octets;
            internal ushort max_tx_time_us;
            internal ushort max_rx_time_us;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_data_length_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapDataLengthParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapDataLengthParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapDataLengthParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapDataLengthParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapDataLengthParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapDataLengthParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGapDataLengthParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapDataLengthParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapDataLengthParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapDataLengthParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapDataLengthParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapDataLengthParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapDataLengthParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapDataLengthParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapDataLengthParamsT(global::NrfBleDriver.BleGapDataLengthParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapDataLengthParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapDataLengthParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapDataLengthParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Maximum number of payload octets that a Controller supports for transmission of a single Link Layer Data Channel PDU.</summary>
        public ushort MaxTxOctets
        {
            get
            {
                return ((__Internal*)__Instance)->max_tx_octets;
            }

            set
            {
                ((__Internal*)__Instance)->max_tx_octets = value;
            }
        }

        /// <summary>Maximum number of payload octets that a Controller supports for reception of a single Link Layer Data Channel PDU.</summary>
        public ushort MaxRxOctets
        {
            get
            {
                return ((__Internal*)__Instance)->max_rx_octets;
            }

            set
            {
                ((__Internal*)__Instance)->max_rx_octets = value;
            }
        }

        /// <summary>Maximum time, in microseconds, that a Controller supports for transmission of a single Link Layer Data Channel PDU.</summary>
        public ushort MaxTxTimeUs
        {
            get
            {
                return ((__Internal*)__Instance)->max_tx_time_us;
            }

            set
            {
                ((__Internal*)__Instance)->max_tx_time_us = value;
            }
        }

        /// <summary>Maximum time, in microseconds, that a Controller supports for reception of a single Link Layer Data Channel PDU.</summary>
        public ushort MaxRxTimeUs
        {
            get
            {
                return ((__Internal*)__Instance)->max_rx_time_us;
            }

            set
            {
                ((__Internal*)__Instance)->max_rx_time_us = value;
            }
        }
    }

    /// <summary>Data Length Update Procedure local limitation.</summary>
    public unsafe partial class BleGapDataLengthLimitationT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 6)]
        public partial struct __Internal
        {
            internal ushort tx_payload_limited_octets;
            internal ushort rx_payload_limited_octets;
            internal ushort tx_rx_time_limited_us;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_data_length_limitation_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapDataLengthLimitationT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapDataLengthLimitationT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapDataLengthLimitationT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapDataLengthLimitationT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapDataLengthLimitationT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapDataLengthLimitationT(native.ToPointer(), skipVTables);
        }

        internal static BleGapDataLengthLimitationT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapDataLengthLimitationT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapDataLengthLimitationT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapDataLengthLimitationT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapDataLengthLimitationT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapDataLengthLimitationT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapDataLengthLimitationT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapDataLengthLimitationT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapDataLengthLimitationT(global::NrfBleDriver.BleGapDataLengthLimitationT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapDataLengthLimitationT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapDataLengthLimitationT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapDataLengthLimitationT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>If &gt; 0, the requested TX packet length is too long by this many octets.</summary>
        public ushort TxPayloadLimitedOctets
        {
            get
            {
                return ((__Internal*)__Instance)->tx_payload_limited_octets;
            }

            set
            {
                ((__Internal*)__Instance)->tx_payload_limited_octets = value;
            }
        }

        /// <summary>If &gt; 0, the requested RX packet length is too long by this many octets.</summary>
        public ushort RxPayloadLimitedOctets
        {
            get
            {
                return ((__Internal*)__Instance)->rx_payload_limited_octets;
            }

            set
            {
                ((__Internal*)__Instance)->rx_payload_limited_octets = value;
            }
        }

        /// <summary>If &gt; 0, the requested combination of TX and RX packet lengths is too long by this many microseconds.</summary>
        public ushort TxRxTimeLimitedUs
        {
            get
            {
                return ((__Internal*)__Instance)->tx_rx_time_limited_us;
            }

            set
            {
                ((__Internal*)__Instance)->tx_rx_time_limited_us = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtAuthStatusT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 6)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte auth_status;

            [FieldOffset(1)]
            internal byte error_src;

            [FieldOffset(1)]
            internal byte bonded;

            [FieldOffset(1)]
            internal byte lesc;

            [FieldOffset(2)]
            internal global::NrfBleDriver.BleGapSecLevelsT.__Internal sm1_levels;

            [FieldOffset(3)]
            internal global::NrfBleDriver.BleGapSecLevelsT.__Internal sm2_levels;

            [FieldOffset(4)]
            internal global::NrfBleDriver.BleGapSecKdistT.__Internal kdist_own;

            [FieldOffset(5)]
            internal global::NrfBleDriver.BleGapSecKdistT.__Internal kdist_peer;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_auth_status_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtAuthStatusT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtAuthStatusT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtAuthStatusT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtAuthStatusT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtAuthStatusT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtAuthStatusT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtAuthStatusT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtAuthStatusT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtAuthStatusT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtAuthStatusT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtAuthStatusT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtAuthStatusT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtAuthStatusT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtAuthStatusT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtAuthStatusT(global::NrfBleDriver.BleGapEvtAuthStatusT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtAuthStatusT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtAuthStatusT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtAuthStatusT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Authentication status, see</summary>
        public byte AuthStatus
        {
            get
            {
                return ((__Internal*)__Instance)->auth_status;
            }

            set
            {
                ((__Internal*)__Instance)->auth_status = value;
            }
        }

        /// <summary>On error, source that caused the failure, see</summary>
        public byte ErrorSrc
        {
            get
            {
                return ((__Internal*)__Instance)->error_src;
            }

            set
            {
                ((__Internal*)__Instance)->error_src = value;
            }
        }

        /// <summary>Procedure resulted in a bond.</summary>
        public byte Bonded
        {
            get
            {
                return ((__Internal*)__Instance)->bonded;
            }

            set
            {
                ((__Internal*)__Instance)->bonded = value;
            }
        }

        /// <summary>Procedure resulted in a LE Secure Connection.</summary>
        public byte Lesc
        {
            get
            {
                return ((__Internal*)__Instance)->lesc;
            }

            set
            {
                ((__Internal*)__Instance)->lesc = value;
            }
        }

        /// <summary>Levels supported in Security Mode 1.</summary>
        public global::NrfBleDriver.BleGapSecLevelsT Sm1Levels
        {
            get
            {
                return global::NrfBleDriver.BleGapSecLevelsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sm1_levels));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sm1_levels = *(global::NrfBleDriver.BleGapSecLevelsT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Levels supported in Security Mode 2.</summary>
        public global::NrfBleDriver.BleGapSecLevelsT Sm2Levels
        {
            get
            {
                return global::NrfBleDriver.BleGapSecLevelsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sm2_levels));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sm2_levels = *(global::NrfBleDriver.BleGapSecLevelsT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Bitmap stating which keys were exchanged (distributed) by the local device. If bonding with LE Secure Connections, the enc bit will be always set.</summary>
        public global::NrfBleDriver.BleGapSecKdistT KdistOwn
        {
            get
            {
                return global::NrfBleDriver.BleGapSecKdistT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->kdist_own));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->kdist_own = *(global::NrfBleDriver.BleGapSecKdistT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Bitmap stating which keys were exchanged (distributed) by the remote device. If bonding with LE Secure Connections, the enc bit will never be set.</summary>
        public global::NrfBleDriver.BleGapSecKdistT KdistPeer
        {
            get
            {
                return global::NrfBleDriver.BleGapSecKdistT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->kdist_peer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->kdist_peer = *(global::NrfBleDriver.BleGapSecKdistT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtConnSecUpdateT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapConnSecT.__Internal conn_sec;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_conn_sec_update_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnSecUpdateT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnSecUpdateT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtConnSecUpdateT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtConnSecUpdateT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtConnSecUpdateT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtConnSecUpdateT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtConnSecUpdateT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtConnSecUpdateT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtConnSecUpdateT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtConnSecUpdateT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtConnSecUpdateT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtConnSecUpdateT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtConnSecUpdateT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnSecUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtConnSecUpdateT(global::NrfBleDriver.BleGapEvtConnSecUpdateT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnSecUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtConnSecUpdateT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtConnSecUpdateT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection security level.</summary>
        public global::NrfBleDriver.BleGapConnSecT ConnSec
        {
            get
            {
                return global::NrfBleDriver.BleGapConnSecT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->conn_sec));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->conn_sec = *(global::NrfBleDriver.BleGapConnSecT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtTimeoutT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte src;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_timeout_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtTimeoutT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtTimeoutT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtTimeoutT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtTimeoutT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtTimeoutT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtTimeoutT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtTimeoutT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtTimeoutT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtTimeoutT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtTimeoutT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtTimeoutT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtTimeoutT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtTimeoutT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtTimeoutT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtTimeoutT(global::NrfBleDriver.BleGapEvtTimeoutT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtTimeoutT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtTimeoutT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtTimeoutT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Source of timeout event, see</summary>
        public byte Src
        {
            get
            {
                return ((__Internal*)__Instance)->src;
            }

            set
            {
                ((__Internal*)__Instance)->src = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtRssiChangedT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal sbyte rssi;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_rssi_changed_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtRssiChangedT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtRssiChangedT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtRssiChangedT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtRssiChangedT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtRssiChangedT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtRssiChangedT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtRssiChangedT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtRssiChangedT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtRssiChangedT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtRssiChangedT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtRssiChangedT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtRssiChangedT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtRssiChangedT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtRssiChangedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtRssiChangedT(global::NrfBleDriver.BleGapEvtRssiChangedT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtRssiChangedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtRssiChangedT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtRssiChangedT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Received Signal Strength Indication in dBm.</summary>
        public sbyte Rssi
        {
            get
            {
                return ((__Internal*)__Instance)->rssi;
            }

            set
            {
                ((__Internal*)__Instance)->rssi = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtAdvReportT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 47)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapAddrT.__Internal peer_addr;

            [FieldOffset(7)]
            internal global::NrfBleDriver.BleGapAddrT.__Internal direct_addr;

            [FieldOffset(14)]
            internal sbyte rssi;

            [FieldOffset(15)]
            internal byte scan_rsp;

            [FieldOffset(15)]
            internal byte type;

            [FieldOffset(15)]
            internal byte dlen;

            [FieldOffset(16)]
            internal fixed byte data[31];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_adv_report_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtAdvReportT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtAdvReportT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtAdvReportT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtAdvReportT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtAdvReportT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtAdvReportT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtAdvReportT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtAdvReportT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtAdvReportT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtAdvReportT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtAdvReportT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtAdvReportT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtAdvReportT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtAdvReportT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtAdvReportT(global::NrfBleDriver.BleGapEvtAdvReportT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtAdvReportT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtAdvReportT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtAdvReportT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Bluetooth address of the peer device. If the peer_addr resolved:is set to 1</para>
        /// <para>and the address is the device's identity address.</para>
        /// </summary>
        public global::NrfBleDriver.BleGapAddrT PeerAddr
        {
            get
            {
                return global::NrfBleDriver.BleGapAddrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->peer_addr));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->peer_addr = *(global::NrfBleDriver.BleGapAddrT.__Internal*) value.__Instance;
            }
        }

        /// <summary>
        /// <para>Set when the scanner is unable to resolve the private resolvable address of the initiator</para>
        /// <para>field of a directed advertisement packet and the scanner has been enabled to report this in</para>
        /// </summary>
        public global::NrfBleDriver.BleGapAddrT DirectAddr
        {
            get
            {
                return global::NrfBleDriver.BleGapAddrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->direct_addr));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->direct_addr = *(global::NrfBleDriver.BleGapAddrT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Received Signal Strength Indication in dBm.</summary>
        public sbyte Rssi
        {
            get
            {
                return ((__Internal*)__Instance)->rssi;
            }

            set
            {
                ((__Internal*)__Instance)->rssi = value;
            }
        }

        /// <summary>If 1, the report corresponds to a scan response and the type field may be ignored.</summary>
        public byte ScanRsp
        {
            get
            {
                return ((__Internal*)__Instance)->scan_rsp;
            }

            set
            {
                ((__Internal*)__Instance)->scan_rsp = value;
            }
        }

        /// <summary>SeeOnly valid if the scan_rsp field is 0.</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Advertising or scan response data length.</summary>
        public byte Dlen
        {
            get
            {
                return ((__Internal*)__Instance)->dlen;
            }

            set
            {
                ((__Internal*)__Instance)->dlen = value;
            }
        }

        /// <summary>Advertising or scan response data.</summary>
        public byte[] Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->data, 31);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 31; i++)
                        ((__Internal*)__Instance)->data[i] = value[i];
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtSecRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte bond;

            [FieldOffset(0)]
            internal byte mitm;

            [FieldOffset(0)]
            internal byte lesc;

            [FieldOffset(0)]
            internal byte keypress;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_sec_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtSecRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtSecRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtSecRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtSecRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtSecRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtSecRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtSecRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtSecRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtSecRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtSecRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtSecRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtSecRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtSecRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtSecRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtSecRequestT(global::NrfBleDriver.BleGapEvtSecRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtSecRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtSecRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtSecRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Perform bonding.</summary>
        public byte Bond
        {
            get
            {
                return ((__Internal*)__Instance)->bond;
            }

            set
            {
                ((__Internal*)__Instance)->bond = value;
            }
        }

        /// <summary>Man In The Middle protection requested.</summary>
        public byte Mitm
        {
            get
            {
                return ((__Internal*)__Instance)->mitm;
            }

            set
            {
                ((__Internal*)__Instance)->mitm = value;
            }
        }

        /// <summary>LE Secure Connections requested.</summary>
        public byte Lesc
        {
            get
            {
                return ((__Internal*)__Instance)->lesc;
            }

            set
            {
                ((__Internal*)__Instance)->lesc = value;
            }
        }

        /// <summary>Generation of keypress notifications requested.</summary>
        public byte Keypress
        {
            get
            {
                return ((__Internal*)__Instance)->keypress;
            }

            set
            {
                ((__Internal*)__Instance)->keypress = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtConnParamUpdateRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapConnParamsT.__Internal conn_params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_conn_param_update_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtConnParamUpdateRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtConnParamUpdateRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtConnParamUpdateRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtConnParamUpdateRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtConnParamUpdateRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtConnParamUpdateRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtConnParamUpdateRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtConnParamUpdateRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtConnParamUpdateRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtConnParamUpdateRequestT(global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>GAP Connection Parameters.</summary>
        public global::NrfBleDriver.BleGapConnParamsT ConnParams
        {
            get
            {
                return global::NrfBleDriver.BleGapConnParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->conn_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->conn_params = *(global::NrfBleDriver.BleGapConnParamsT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtScanReqReportT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal sbyte rssi;
            internal global::NrfBleDriver.BleGapAddrT.__Internal peer_addr;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_scan_req_report_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtScanReqReportT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtScanReqReportT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtScanReqReportT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtScanReqReportT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtScanReqReportT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtScanReqReportT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtScanReqReportT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtScanReqReportT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtScanReqReportT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtScanReqReportT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtScanReqReportT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtScanReqReportT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtScanReqReportT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtScanReqReportT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtScanReqReportT(global::NrfBleDriver.BleGapEvtScanReqReportT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtScanReqReportT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtScanReqReportT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtScanReqReportT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Received Signal Strength Indication in dBm.</summary>
        public sbyte Rssi
        {
            get
            {
                return ((__Internal*)__Instance)->rssi;
            }

            set
            {
                ((__Internal*)__Instance)->rssi = value;
            }
        }

        /// <summary>
        /// <para>Bluetooth address of the peer device. If the peer_addr resolved:is set to 1</para>
        /// <para>and the address is the device's identity address.</para>
        /// </summary>
        public global::NrfBleDriver.BleGapAddrT PeerAddr
        {
            get
            {
                return global::NrfBleDriver.BleGapAddrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->peer_addr));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->peer_addr = *(global::NrfBleDriver.BleGapAddrT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtDataLengthUpdateRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapDataLengthParamsT.__Internal peer_params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_data_length_update_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtDataLengthUpdateRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtDataLengthUpdateRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtDataLengthUpdateRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtDataLengthUpdateRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtDataLengthUpdateRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtDataLengthUpdateRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtDataLengthUpdateRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtDataLengthUpdateRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtDataLengthUpdateRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtDataLengthUpdateRequestT(global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Peer data length parameters.</summary>
        public global::NrfBleDriver.BleGapDataLengthParamsT PeerParams
        {
            get
            {
                return global::NrfBleDriver.BleGapDataLengthParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->peer_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->peer_params = *(global::NrfBleDriver.BleGapDataLengthParamsT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtDataLengthUpdateT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapDataLengthParamsT.__Internal effective_params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_data_length_update_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtDataLengthUpdateT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtDataLengthUpdateT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtDataLengthUpdateT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtDataLengthUpdateT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtDataLengthUpdateT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtDataLengthUpdateT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtDataLengthUpdateT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtDataLengthUpdateT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtDataLengthUpdateT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtDataLengthUpdateT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtDataLengthUpdateT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtDataLengthUpdateT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtDataLengthUpdateT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtDataLengthUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtDataLengthUpdateT(global::NrfBleDriver.BleGapEvtDataLengthUpdateT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtDataLengthUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtDataLengthUpdateT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtDataLengthUpdateT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The effective data length parameters.</summary>
        public global::NrfBleDriver.BleGapDataLengthParamsT EffectiveParams
        {
            get
            {
                return global::NrfBleDriver.BleGapDataLengthParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->effective_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->effective_params = *(global::NrfBleDriver.BleGapDataLengthParamsT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>GAP event structure.</summary>
    public unsafe partial class BleGapEvtT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal global::NrfBleDriver.BleGapEvtT.Params.__Internal @params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Params
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtConnectedT.__Internal connected;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtDisconnectedT.__Internal disconnected;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtConnParamUpdateT.__Internal conn_param_update;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtSecParamsRequestT.__Internal sec_params_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtSecInfoRequestT.__Internal sec_info_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtPasskeyDisplayT.__Internal passkey_display;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtKeyPressedT.__Internal key_pressed;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtAuthKeyRequestT.__Internal auth_key_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtLescDhkeyRequestT.__Internal lesc_dhkey_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtAuthStatusT.__Internal auth_status;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtConnSecUpdateT.__Internal conn_sec_update;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtTimeoutT.__Internal timeout;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtRssiChangedT.__Internal rssi_changed;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtAdvReportT.__Internal adv_report;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtSecRequestT.__Internal sec_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT.__Internal conn_param_update_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtScanReqReportT.__Internal scan_req_report;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtPhyUpdateRequestT.__Internal phy_update_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtPhyUpdateT.__Internal phy_update;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT.__Internal data_length_update_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtDataLengthUpdateT.__Internal data_length_update;

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-params>@ble_gap_evt_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Params.__Internal __instance;
            internal Params.__Internal __Instance => __instance;

            internal static Params __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Params(native.ToPointer(), skipVTables);
            }

            internal static Params __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Params(native, skipVTables);
            }

            private Params(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Params(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleGapEvtT.Params.__Internal*) native;
            }

            public Params(global::NrfBleDriver.BleGapEvtT.Params __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>Connected Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtConnectedT Connected
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtConnectedT.__CreateInstance(__instance.connected);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.connected = *(global::NrfBleDriver.BleGapEvtConnectedT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Disconnected Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtDisconnectedT Disconnected
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtDisconnectedT.__CreateInstance(__instance.disconnected);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.disconnected = *(global::NrfBleDriver.BleGapEvtDisconnectedT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Connection Parameter Update Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtConnParamUpdateT ConnParamUpdate
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtConnParamUpdateT.__CreateInstance(__instance.conn_param_update);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.conn_param_update = *(global::NrfBleDriver.BleGapEvtConnParamUpdateT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Security Parameters Request Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtSecParamsRequestT SecParamsRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtSecParamsRequestT.__CreateInstance(__instance.sec_params_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.sec_params_request = *(global::NrfBleDriver.BleGapEvtSecParamsRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Security Information Request Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtSecInfoRequestT SecInfoRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtSecInfoRequestT.__CreateInstance(__instance.sec_info_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.sec_info_request = *(global::NrfBleDriver.BleGapEvtSecInfoRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Passkey Display Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtPasskeyDisplayT PasskeyDisplay
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtPasskeyDisplayT.__CreateInstance(__instance.passkey_display);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.passkey_display = *(global::NrfBleDriver.BleGapEvtPasskeyDisplayT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Key Pressed Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtKeyPressedT KeyPressed
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtKeyPressedT.__CreateInstance(__instance.key_pressed);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.key_pressed = *(global::NrfBleDriver.BleGapEvtKeyPressedT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Authentication Key Request Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtAuthKeyRequestT AuthKeyRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtAuthKeyRequestT.__CreateInstance(__instance.auth_key_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.auth_key_request = *(global::NrfBleDriver.BleGapEvtAuthKeyRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>LE Secure Connections DHKey calculation request.</summary>
            public global::NrfBleDriver.BleGapEvtLescDhkeyRequestT LescDhkeyRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtLescDhkeyRequestT.__CreateInstance(__instance.lesc_dhkey_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.lesc_dhkey_request = *(global::NrfBleDriver.BleGapEvtLescDhkeyRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Authentication Status Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtAuthStatusT AuthStatus
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtAuthStatusT.__CreateInstance(__instance.auth_status);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.auth_status = *(global::NrfBleDriver.BleGapEvtAuthStatusT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Connection Security Update Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtConnSecUpdateT ConnSecUpdate
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtConnSecUpdateT.__CreateInstance(__instance.conn_sec_update);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.conn_sec_update = *(global::NrfBleDriver.BleGapEvtConnSecUpdateT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Timeout Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtTimeoutT Timeout
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtTimeoutT.__CreateInstance(__instance.timeout);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.timeout = *(global::NrfBleDriver.BleGapEvtTimeoutT.__Internal*) value.__Instance;
                }
            }

            /// <summary>RSSI Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtRssiChangedT RssiChanged
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtRssiChangedT.__CreateInstance(__instance.rssi_changed);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.rssi_changed = *(global::NrfBleDriver.BleGapEvtRssiChangedT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Advertising Report Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtAdvReportT AdvReport
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtAdvReportT.__CreateInstance(__instance.adv_report);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.adv_report = *(global::NrfBleDriver.BleGapEvtAdvReportT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Security Request Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtSecRequestT SecRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtSecRequestT.__CreateInstance(__instance.sec_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.sec_request = *(global::NrfBleDriver.BleGapEvtSecRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Connection Parameter Update Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT ConnParamUpdateRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT.__CreateInstance(__instance.conn_param_update_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.conn_param_update_request = *(global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Scan Request Report Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtScanReqReportT ScanReqReport
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtScanReqReportT.__CreateInstance(__instance.scan_req_report);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.scan_req_report = *(global::NrfBleDriver.BleGapEvtScanReqReportT.__Internal*) value.__Instance;
                }
            }

            /// <summary>PHY Update Request Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtPhyUpdateRequestT PhyUpdateRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtPhyUpdateRequestT.__CreateInstance(__instance.phy_update_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.phy_update_request = *(global::NrfBleDriver.BleGapEvtPhyUpdateRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>PHY Update Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtPhyUpdateT PhyUpdate
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtPhyUpdateT.__CreateInstance(__instance.phy_update);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.phy_update = *(global::NrfBleDriver.BleGapEvtPhyUpdateT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Data Length Update Request Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT DataLengthUpdateRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT.__CreateInstance(__instance.data_length_update_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.data_length_update_request = *(global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Data Length Update Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtDataLengthUpdateT DataLengthUpdate
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtDataLengthUpdateT.__CreateInstance(__instance.data_length_update);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.data_length_update = *(global::NrfBleDriver.BleGapEvtDataLengthUpdateT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtT(global::NrfBleDriver.BleGapEvtT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle on which event occurred.</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>Event Parameters.</summary>
        public global::NrfBleDriver.BleGapEvtT.Params @params
        {
            get
            {
                return global::NrfBleDriver.BleGapEvtT.Params.__CreateInstance(((__Internal*)__Instance)->@params);
            }

            set
            {
                ((__Internal*)__Instance)->@params = value.__Instance;
            }
        }
    }

    /// <summary>BLE GAP connection configuration parameters, set with</summary>
    /// <remarks>
    /// <para>::NRF_ERROR_CONN_COUNT     The connection count for the connection configurations is zero.</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  One or more of the following is true:</para>
    /// <para>- The sum of conn_count for all connection configurations combined exceeds UINT8_MAX.</para>
    /// <para>- The event length is smaller than</para>
    /// </remarks>
    public unsafe partial class BleGapConnCfgT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal byte conn_count;
            internal ushort event_length;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_conn_cfg_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnCfgT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnCfgT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapConnCfgT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapConnCfgT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapConnCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapConnCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleGapConnCfgT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapConnCfgT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapConnCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapConnCfgT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapConnCfgT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapConnCfgT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapConnCfgT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapConnCfgT(global::NrfBleDriver.BleGapConnCfgT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapConnCfgT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapConnCfgT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The number of concurrent connections the application can create with this configuration.</para>
        /// <para>The default and minimum value is</para>
        /// </summary>
        public byte ConnCount
        {
            get
            {
                return ((__Internal*)__Instance)->conn_count;
            }

            set
            {
                ((__Internal*)__Instance)->conn_count = value;
            }
        }

        /// <summary>
        /// <para>The time set aside for this connection on every connection interval in 1.25 ms units.</para>
        /// <para>The default value isthe minimum value isThe event length and the connection interval are the primary parameters</para>
        /// <para>for setting the throughput of a connection.</para>
        /// <para>See the SoftDevice Specification for details on throughput.</para>
        /// </summary>
        public ushort EventLength
        {
            get
            {
                return ((__Internal*)__Instance)->event_length;
            }

            set
            {
                ((__Internal*)__Instance)->event_length = value;
            }
        }
    }

    /// <summary>Configuration of maximum concurrent connections in the different connected roles, set with</summary>
    /// <remarks>
    /// <para>::NRF_ERROR_CONN_COUNT     The sum of periph_role_count and central_role_count is too</para>
    /// <para>large. The maximum supported sum of concurrent connections is</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  central_sec_count is larger than central_role_count.</para>
    /// </remarks>
    public unsafe partial class BleGapCfgRoleCountT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 3)]
        public partial struct __Internal
        {
            internal byte periph_role_count;
            internal byte central_role_count;
            internal byte central_sec_count;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_cfg_role_count_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapCfgRoleCountT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapCfgRoleCountT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapCfgRoleCountT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapCfgRoleCountT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapCfgRoleCountT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapCfgRoleCountT(native.ToPointer(), skipVTables);
        }

        internal static BleGapCfgRoleCountT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapCfgRoleCountT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapCfgRoleCountT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapCfgRoleCountT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapCfgRoleCountT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapCfgRoleCountT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapCfgRoleCountT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapCfgRoleCountT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapCfgRoleCountT(global::NrfBleDriver.BleGapCfgRoleCountT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapCfgRoleCountT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapCfgRoleCountT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapCfgRoleCountT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Maximum number of connections concurrently acting as a peripheral. Default value is</summary>
        public byte PeriphRoleCount
        {
            get
            {
                return ((__Internal*)__Instance)->periph_role_count;
            }

            set
            {
                ((__Internal*)__Instance)->periph_role_count = value;
            }
        }

        /// <summary>Maximum number of connections concurrently acting as a central. Default value is</summary>
        public byte CentralRoleCount
        {
            get
            {
                return ((__Internal*)__Instance)->central_role_count;
            }

            set
            {
                ((__Internal*)__Instance)->central_role_count = value;
            }
        }

        /// <summary>Number of SMP instances shared between all connections acting as a central. Default value is</summary>
        public byte CentralSecCount
        {
            get
            {
                return ((__Internal*)__Instance)->central_sec_count;
            }

            set
            {
                ((__Internal*)__Instance)->central_sec_count = value;
            }
        }
    }

    /// <summary>Device name and its properties, set with</summary>
    /// <remarks>
    /// <para>If the device name is not configured, the default device name will bethe maximum device name length will bevloc will be set toand the device name</para>
    /// <para>will have no write access.</para>
    /// <para>Ifis more thanand vloc is set tothe attribute table size must be increased to have room for the longer device name (see</para>
    /// <para>and</para>
    /// <para>If vloc is:</para>
    /// <para>- p_value must point to non-volatile memory (flash) or be NULL.</para>
    /// <para>- If p_value is NULL, the device name will initially be empty.</para>
    /// <para>If vloc is:</para>
    /// <para>- p_value cannot be NULL.</para>
    /// <para>- If the device name is writable, p_value must point to volatile memory (RAM).</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  One or more of the following is true:</para>
    /// <para>- Invalid device name location (vloc).</para>
    /// <para>- Invalid device name security mode.</para>
    /// <para>::NRF_ERROR_INVALID_LENGTH One or more of the following is true:</para>
    /// <para>- The device name length is invalid (must be between 0 and- The device name length is too long for the given Attribute Table.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED  Device name security mode is not supported.</para>
    /// </remarks>
    public unsafe partial class BleGapCfgDeviceNameT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapConnSecModeT.__Internal write_perm;
            internal byte vloc;
            internal __IntPtr p_value;
            internal ushort current_len;
            internal ushort max_len;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_cfg_device_name_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapCfgDeviceNameT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapCfgDeviceNameT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapCfgDeviceNameT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapCfgDeviceNameT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapCfgDeviceNameT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapCfgDeviceNameT(native.ToPointer(), skipVTables);
        }

        internal static BleGapCfgDeviceNameT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapCfgDeviceNameT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapCfgDeviceNameT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapCfgDeviceNameT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapCfgDeviceNameT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapCfgDeviceNameT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapCfgDeviceNameT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapCfgDeviceNameT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapCfgDeviceNameT(global::NrfBleDriver.BleGapCfgDeviceNameT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapCfgDeviceNameT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapCfgDeviceNameT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapCfgDeviceNameT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Write permissions.</summary>
        public global::NrfBleDriver.BleGapConnSecModeT WritePerm
        {
            get
            {
                return global::NrfBleDriver.BleGapConnSecModeT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->write_perm));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->write_perm = *(global::NrfBleDriver.BleGapConnSecModeT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Value location, see</summary>
        public byte Vloc
        {
            get
            {
                return ((__Internal*)__Instance)->vloc;
            }

            set
            {
                ((__Internal*)__Instance)->vloc = value;
            }
        }

        /// <summary>Pointer to where the value (device name) is stored or will be stored.</summary>
        public byte* PValue
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_value;
            }

            set
            {
                ((__Internal*)__Instance)->p_value = (__IntPtr) value;
            }
        }

        /// <summary>Current length in bytes of the memory pointed to by p_value.</summary>
        public ushort CurrentLen
        {
            get
            {
                return ((__Internal*)__Instance)->current_len;
            }

            set
            {
                ((__Internal*)__Instance)->current_len = value;
            }
        }

        /// <summary>Maximum length in bytes of the memory pointed to by p_value.</summary>
        public ushort MaxLen
        {
            get
            {
                return ((__Internal*)__Instance)->max_len;
            }

            set
            {
                ((__Internal*)__Instance)->max_len = value;
            }
        }
    }

    /// <summary>Configuration structure for GAP configurations.</summary>
    public unsafe partial struct BleGapCfgT
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapCfgRoleCountT.__Internal role_count_cfg;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapCfgDeviceNameT.__Internal device_name_cfg;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_cfg_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        private BleGapCfgT.__Internal __instance;
        internal BleGapCfgT.__Internal __Instance => __instance;

        internal static BleGapCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleGapCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapCfgT(native, skipVTables);
        }

        private BleGapCfgT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private BleGapCfgT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NrfBleDriver.BleGapCfgT.__Internal*) native;
        }

        public BleGapCfgT(global::NrfBleDriver.BleGapCfgT __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>Role count configuration, cfg_id is</summary>
        public global::NrfBleDriver.BleGapCfgRoleCountT RoleCountCfg
        {
            get
            {
                return global::NrfBleDriver.BleGapCfgRoleCountT.__CreateInstance(__instance.role_count_cfg);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.role_count_cfg = *(global::NrfBleDriver.BleGapCfgRoleCountT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Device name configuration, cfg_id is</summary>
        public global::NrfBleDriver.BleGapCfgDeviceNameT DeviceNameCfg
        {
            get
            {
                return global::NrfBleDriver.BleGapCfgDeviceNameT.__CreateInstance(__instance.device_name_cfg);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.device_name_cfg = *(global::NrfBleDriver.BleGapCfgDeviceNameT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>
    /// <para>Channel Map option.</para>
    /// <para>Used withto get the current channel map</para>
    /// <para>orto set a new channel map. When setting the</para>
    /// <para>channel map, it applies to all current and future connections. When getting the</para>
    /// <para>current channel map, it applies to a single connection and the connection handle</para>
    /// <para>must be supplied.</para>
    /// </summary>
    /// <remarks>
    /// <para>Setting the channel map may take some time, depending on connection parameters.</para>
    /// <para>The time taken may be different for each connection and the get operation will</para>
    /// <para>return the previous channel map until the new one has taken effect.</para>
    /// <para>After setting the channel map, by spec it can not be set again until at least 1 s has passed.</para>
    /// <para>See Bluetooth Specification Version 4.1 Volume 2, Part E, Section 7.3.46.</para>
    /// <para>::NRF_SUCCESS Get or set successful.</para>
    /// <para>::NRF_ERROR_BUSY Channel map was set again before enough time had passed.</para>
    /// <para>::NRF_ERROR_INVALID_STATE Invalid state to perform operation.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied for get.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED Returned by sd_ble_opt_set in peripheral-only SoftDevices.</para>
    /// </remarks>
    public unsafe partial class BleGapOptChMapT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal fixed byte ch_map[5];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_ch_map_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptChMapT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptChMapT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapOptChMapT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapOptChMapT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapOptChMapT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptChMapT(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptChMapT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapOptChMapT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapOptChMapT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptChMapT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapOptChMapT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapOptChMapT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapOptChMapT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptChMapT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapOptChMapT(global::NrfBleDriver.BleGapOptChMapT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptChMapT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapOptChMapT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapOptChMapT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle (only applicable for get)</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>Channel Map (37-bit).</summary>
        public byte[] ChMap
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->ch_map, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->ch_map[i] = value[i];
                }
            }
        }
    }

    /// <summary>Local connection latency option.</summary>
    /// <remarks>
    /// <para>Local connection latency is a feature which enables the slave to improve</para>
    /// <para>current consumption by ignoring the slave latency set by the peer. The</para>
    /// <para>local connection latency can only be set to a multiple of the slave latency,</para>
    /// <para>and cannot be longer than half of the supervision timeout.</para>
    /// <para>Used withto set the local connection latency. The</para>
    /// <para>is not supported for this option, but the actual</para>
    /// <para>local connection latency (unless set to NULL) is set as a return parameter</para>
    /// <para>when setting the option.</para>
    /// <para>The latency set will be truncated down to the closest slave latency event</para>
    /// <para>multiple, or the nearest multiple before half of the supervision timeout.</para>
    /// <para>The local connection latency is disabled by default, and needs to be enabled for new</para>
    /// <para>connections and whenever the connection is updated.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED Get is not supported.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.</para>
    /// </remarks>
    public unsafe partial class BleGapOptLocalConnLatencyT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal ushort requested_latency;
            internal __IntPtr p_actual_latency;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_local_conn_latency_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptLocalConnLatencyT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptLocalConnLatencyT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapOptLocalConnLatencyT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapOptLocalConnLatencyT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapOptLocalConnLatencyT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptLocalConnLatencyT(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptLocalConnLatencyT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapOptLocalConnLatencyT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapOptLocalConnLatencyT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptLocalConnLatencyT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapOptLocalConnLatencyT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapOptLocalConnLatencyT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapOptLocalConnLatencyT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptLocalConnLatencyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapOptLocalConnLatencyT(global::NrfBleDriver.BleGapOptLocalConnLatencyT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptLocalConnLatencyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapOptLocalConnLatencyT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapOptLocalConnLatencyT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>Requested local connection latency.</summary>
        public ushort RequestedLatency
        {
            get
            {
                return ((__Internal*)__Instance)->requested_latency;
            }

            set
            {
                ((__Internal*)__Instance)->requested_latency = value;
            }
        }

        /// <summary>Pointer to storage for the actual local connection latency (can be set to NULL to skip return value).</summary>
        public ushort* PActualLatency
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->p_actual_latency;
            }

            set
            {
                ((__Internal*)__Instance)->p_actual_latency = (__IntPtr) value;
            }
        }
    }

    /// <summary>Disable slave latency</summary>
    /// <remarks>
    /// <para>Used withto temporarily disable slave latency of a peripheral connection (seeAnd to re-enable it again.</para>
    /// <para>When disabled, the peripheral will ignore the slave_latency set by the central.</para>
    /// <para>Shall only be called on peripheral links.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED Get is not supported.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.</para>
    /// </remarks>
    public unsafe partial class BleGapOptSlaveLatencyDisableT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal byte disable;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_slave_latency_disable_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptSlaveLatencyDisableT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptSlaveLatencyDisableT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapOptSlaveLatencyDisableT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapOptSlaveLatencyDisableT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapOptSlaveLatencyDisableT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptSlaveLatencyDisableT(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptSlaveLatencyDisableT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapOptSlaveLatencyDisableT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapOptSlaveLatencyDisableT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptSlaveLatencyDisableT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapOptSlaveLatencyDisableT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapOptSlaveLatencyDisableT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapOptSlaveLatencyDisableT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptSlaveLatencyDisableT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapOptSlaveLatencyDisableT(global::NrfBleDriver.BleGapOptSlaveLatencyDisableT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptSlaveLatencyDisableT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapOptSlaveLatencyDisableT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapOptSlaveLatencyDisableT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>Set to 1 to disable slave latency. Set to 0 enable it again.</summary>
        public byte Disable
        {
            get
            {
                return ((__Internal*)__Instance)->disable;
            }

            set
            {
                ((__Internal*)__Instance)->disable = value;
            }
        }
    }

    /// <summary>Passkey Option.</summary>
    /// <remarks>
    /// <para>Structure containing the passkey to be used during pairing. This can be used withto make the SoftDevice use a preprogrammed passkey for authentication</para>
    /// <para>instead of generating a random one.</para>
    /// <para>Repeated pairing attempts using the same preprogrammed passkey makes pairing vulnerable to MITM attacks.</para>
    /// <para>is not supported for this option.</para>
    /// </remarks>
    public unsafe partial class BleGapOptPasskeyT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr p_passkey;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_passkey_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptPasskeyT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptPasskeyT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapOptPasskeyT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapOptPasskeyT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapOptPasskeyT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptPasskeyT(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptPasskeyT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapOptPasskeyT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapOptPasskeyT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptPasskeyT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapOptPasskeyT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapOptPasskeyT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapOptPasskeyT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptPasskeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapOptPasskeyT(global::NrfBleDriver.BleGapOptPasskeyT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptPasskeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapOptPasskeyT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapOptPasskeyT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Pointer to 6-digit ASCII string (digit 0..9 only, no NULL termination) passkey to be used during pairing. If this is NULL, the SoftDevice will generate a random passkey if required.</summary>
        public byte* PPasskey
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_passkey;
            }
        }
    }

    /// <summary>Scan request report option.</summary>
    /// <remarks>
    /// <para>This can be used withto make the SoftDevice send</para>
    /// <para>events.</para>
    /// <para>Due to the limited space reserved for scan request report events,</para>
    /// <para>not all received scan requests will be reported.</para>
    /// <para>If whitelisting is used, only whitelisted requests are reported.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_INVALID_STATE When advertising is ongoing while the option is set.</para>
    /// </remarks>
    public unsafe partial class BleGapOptScanReqReportT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte enable;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_scan_req_report_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptScanReqReportT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptScanReqReportT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapOptScanReqReportT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapOptScanReqReportT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapOptScanReqReportT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptScanReqReportT(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptScanReqReportT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapOptScanReqReportT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapOptScanReqReportT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptScanReqReportT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapOptScanReqReportT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapOptScanReqReportT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapOptScanReqReportT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptScanReqReportT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapOptScanReqReportT(global::NrfBleDriver.BleGapOptScanReqReportT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptScanReqReportT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapOptScanReqReportT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapOptScanReqReportT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Enable scan request reports.</summary>
        public byte Enable
        {
            get
            {
                return ((__Internal*)__Instance)->enable;
            }

            set
            {
                ((__Internal*)__Instance)->enable = value;
            }
        }
    }

    /// <summary>Compatibility mode 1 option.</summary>
    /// <remarks>
    /// <para>This can be used withto enable and disable</para>
    /// <para>compatibility mode 1. Compatibility mode 1 is disabled by default.</para>
    /// <para>Compatibility mode 1 enables interoperability with devices that do not support a value of</para>
    /// <para>0 for the WinOffset parameter in the Link Layer CONNECT_IND packet. This applies to a</para>
    /// <para>limited set of legacy peripheral devices from another vendor. Enabling this compatibility</para>
    /// <para>mode will only have an effect if the local device will act as a central device and</para>
    /// <para>initiate a connection to a peripheral device. In that case it may lead to the connection</para>
    /// <para>creation taking up to one connection interval longer to complete for all connections.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_INVALID_STATE When connection creation is ongoing while mode 1 is set.</para>
    /// </remarks>
    public unsafe partial class BleGapOptCompatMode1T : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte enable;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_compat_mode_1_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptCompatMode1T> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptCompatMode1T>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapOptCompatMode1T managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapOptCompatMode1T managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapOptCompatMode1T __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptCompatMode1T(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptCompatMode1T __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapOptCompatMode1T)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapOptCompatMode1T __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptCompatMode1T(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapOptCompatMode1T(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapOptCompatMode1T(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapOptCompatMode1T()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptCompatMode1T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapOptCompatMode1T(global::NrfBleDriver.BleGapOptCompatMode1T __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptCompatMode1T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapOptCompatMode1T.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapOptCompatMode1T.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Enable compatibility mode 1.</summary>
        public byte Enable
        {
            get
            {
                return ((__Internal*)__Instance)->enable;
            }

            set
            {
                ((__Internal*)__Instance)->enable = value;
            }
        }
    }

    /// <summary>Authenticated payload timeout option.</summary>
    /// <remarks>
    /// <para>This can be used withto change the Authenticated payload timeout to a value other</para>
    /// <para>than the default of</para>
    /// <para>The authenticated payload timeout event ::BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD will be generated</para>
    /// <para>if auth_payload_timeout time has elapsed without receiving a packet with a valid MIC on an encrypted</para>
    /// <para>link.</para>
    /// <para>The LE ping procedure will be initiated before the timer expires to give the peer a chance</para>
    /// <para>to reset the timer. In addition the stack will try to prioritize running of LE ping over other</para>
    /// <para>activities to increase chances of finishing LE ping before timer expires. To avoid side-effects</para>
    /// <para>on other activities, it is recommended to use high timeout values.</para>
    /// <para>Recommended timeout &gt; 2*(connInterval * (6 + connSlaveLatency)).</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied. auth_payload_timeout was outside of allowed range.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.</para>
    /// </remarks>
    public unsafe partial class BleGapOptAuthPayloadTimeoutT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal ushort auth_payload_timeout;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_auth_payload_timeout_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapOptAuthPayloadTimeoutT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptAuthPayloadTimeoutT(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptAuthPayloadTimeoutT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapOptAuthPayloadTimeoutT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapOptAuthPayloadTimeoutT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptAuthPayloadTimeoutT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapOptAuthPayloadTimeoutT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapOptAuthPayloadTimeoutT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapOptAuthPayloadTimeoutT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapOptAuthPayloadTimeoutT(global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>Requested timeout in 10 ms unit, see</summary>
        public ushort AuthPayloadTimeout
        {
            get
            {
                return ((__Internal*)__Instance)->auth_payload_timeout;
            }

            set
            {
                ((__Internal*)__Instance)->auth_payload_timeout = value;
            }
        }
    }

    /// <summary>Option structure for GAP options.</summary>
    public unsafe partial struct BleGapOptT
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptChMapT.__Internal ch_map;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptLocalConnLatencyT.__Internal local_conn_latency;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptPasskeyT.__Internal passkey;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptScanReqReportT.__Internal scan_req_report;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptCompatMode1T.__Internal compat_mode_1;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT.__Internal auth_payload_timeout;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptSlaveLatencyDisableT.__Internal slave_latency_disable;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        private BleGapOptT.__Internal __instance;
        internal BleGapOptT.__Internal __Instance => __instance;

        internal static BleGapOptT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptT(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptT(native, skipVTables);
        }

        private BleGapOptT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private BleGapOptT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NrfBleDriver.BleGapOptT.__Internal*) native;
        }

        public BleGapOptT(global::NrfBleDriver.BleGapOptT __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>Parameters for the Channel Map option.</summary>
        public global::NrfBleDriver.BleGapOptChMapT ChMap
        {
            get
            {
                return global::NrfBleDriver.BleGapOptChMapT.__CreateInstance(__instance.ch_map);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.ch_map = *(global::NrfBleDriver.BleGapOptChMapT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Parameters for the Local connection latency option</summary>
        public global::NrfBleDriver.BleGapOptLocalConnLatencyT LocalConnLatency
        {
            get
            {
                return global::NrfBleDriver.BleGapOptLocalConnLatencyT.__CreateInstance(__instance.local_conn_latency);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.local_conn_latency = *(global::NrfBleDriver.BleGapOptLocalConnLatencyT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Parameters for the Passkey option.</summary>
        public global::NrfBleDriver.BleGapOptPasskeyT Passkey
        {
            get
            {
                return global::NrfBleDriver.BleGapOptPasskeyT.__CreateInstance(__instance.passkey);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.passkey = *(global::NrfBleDriver.BleGapOptPasskeyT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Parameters for the scan request report option.</summary>
        public global::NrfBleDriver.BleGapOptScanReqReportT ScanReqReport
        {
            get
            {
                return global::NrfBleDriver.BleGapOptScanReqReportT.__CreateInstance(__instance.scan_req_report);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.scan_req_report = *(global::NrfBleDriver.BleGapOptScanReqReportT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Parameters for the compatibility mode 1 option.</summary>
        public global::NrfBleDriver.BleGapOptCompatMode1T CompatMode1
        {
            get
            {
                return global::NrfBleDriver.BleGapOptCompatMode1T.__CreateInstance(__instance.compat_mode_1);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.compat_mode_1 = *(global::NrfBleDriver.BleGapOptCompatMode1T.__Internal*) value.__Instance;
            }
        }

        /// <summary>Parameters for the authenticated payload timeout option.</summary>
        public global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT AuthPayloadTimeout
        {
            get
            {
                return global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT.__CreateInstance(__instance.auth_payload_timeout);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.auth_payload_timeout = *(global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Parameters for the Disable slave latency option</summary>
        public global::NrfBleDriver.BleGapOptSlaveLatencyDisableT SlaveLatencyDisable
        {
            get
            {
                return global::NrfBleDriver.BleGapOptSlaveLatencyDisableT.__CreateInstance(__instance.slave_latency_disable);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.slave_latency_disable = *(global::NrfBleDriver.BleGapOptSlaveLatencyDisableT.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ble_gap
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_addr_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAddrSet(__IntPtr adapter, __IntPtr p_addr);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_addr_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAddrGet(__IntPtr adapter, __IntPtr p_addr);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_whitelist_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapWhitelistSet(__IntPtr adapter, __IntPtr pp_wl_addrs, byte len);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_device_identities_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapDeviceIdentitiesSet(__IntPtr adapter, __IntPtr pp_id_keys, __IntPtr pp_local_irks, byte len);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_privacy_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapPrivacySet(__IntPtr adapter, __IntPtr p_privacy_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_privacy_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapPrivacyGet(__IntPtr adapter, __IntPtr p_privacy_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_adv_data_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAdvDataSet(__IntPtr adapter, byte* p_adv_data, byte dlen, byte* p_sr_data, byte srdlen);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_adv_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAdvStart(__IntPtr adapter, __IntPtr p_adv_params, byte conn_cfg_tag);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_adv_stop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAdvStop(__IntPtr adapter);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_conn_param_update", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapConnParamUpdate(__IntPtr adapter, ushort conn_handle, __IntPtr p_conn_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_disconnect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapDisconnect(__IntPtr adapter, ushort conn_handle, byte hci_status_code);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_tx_power_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapTxPowerSet(__IntPtr adapter, sbyte tx_power);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_appearance_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAppearanceSet(__IntPtr adapter, ushort appearance);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_appearance_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAppearanceGet(__IntPtr adapter, ushort* p_appearance);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_ppcp_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapPpcpSet(__IntPtr adapter, __IntPtr p_conn_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_ppcp_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapPpcpGet(__IntPtr adapter, __IntPtr p_conn_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_device_name_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapDeviceNameSet(__IntPtr adapter, __IntPtr p_write_perm, byte* p_dev_name, ushort len);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_device_name_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapDeviceNameGet(__IntPtr adapter, byte* p_dev_name, ushort* p_dev_name_len);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_authenticate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAuthenticate(__IntPtr adapter, ushort conn_handle, __IntPtr p_sec_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_sec_params_reply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapSecParamsReply(__IntPtr adapter, ushort conn_handle, byte sec_status, __IntPtr p_sec_params, __IntPtr p_sec_keyset);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_auth_key_reply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAuthKeyReply(__IntPtr adapter, ushort conn_handle, byte key_type, byte* p_key);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_lesc_dhkey_reply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapLescDhkeyReply(__IntPtr adapter, ushort conn_handle, __IntPtr p_dhkey);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_keypress_notify", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapKeypressNotify(__IntPtr adapter, ushort conn_handle, byte kp_not);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_lesc_oob_data_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapLescOobDataGet(__IntPtr adapter, ushort conn_handle, __IntPtr p_pk_own, __IntPtr p_oobd_own);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_lesc_oob_data_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapLescOobDataSet(__IntPtr adapter, ushort conn_handle, __IntPtr p_oobd_own, __IntPtr p_oobd_peer);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_encrypt", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapEncrypt(__IntPtr adapter, ushort conn_handle, __IntPtr p_master_id, __IntPtr p_enc_info);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_sec_info_reply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapSecInfoReply(__IntPtr adapter, ushort conn_handle, __IntPtr p_enc_info, __IntPtr p_id_info, __IntPtr p_sign_info);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_conn_sec_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapConnSecGet(__IntPtr adapter, ushort conn_handle, __IntPtr p_conn_sec);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_rssi_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapRssiStart(__IntPtr adapter, ushort conn_handle, byte threshold_dbm, byte skip_count);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_rssi_stop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapRssiStop(__IntPtr adapter, ushort conn_handle);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_rssi_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapRssiGet(__IntPtr adapter, ushort conn_handle, sbyte* p_rssi);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_scan_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapScanStart(__IntPtr adapter, __IntPtr p_scan_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_scan_stop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapScanStop(__IntPtr adapter);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_connect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapConnect(__IntPtr adapter, __IntPtr p_peer_addr, __IntPtr p_scan_params, __IntPtr p_conn_params, byte conn_cfg_tag);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_connect_cancel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapConnectCancel(__IntPtr adapter);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_phy_update", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapPhyUpdate(__IntPtr adapter, ushort conn_handle, __IntPtr p_gap_phys);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_data_length_update", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapDataLengthUpdate(__IntPtr adapter, ushort conn_handle, __IntPtr p_dl_params, __IntPtr p_dl_limitation);
        }

        public static uint SdBleGapAddrSet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapAddrT p_addr)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_addr is null ? __IntPtr.Zero : p_addr.__Instance;
            var __ret = __Internal.SdBleGapAddrSet(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleGapAddrGet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapAddrT p_addr)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_addr is null ? __IntPtr.Zero : p_addr.__Instance;
            var __ret = __Internal.SdBleGapAddrGet(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleGapWhitelistSet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapAddrT pp_wl_addrs, byte len)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var ____arg1 = pp_wl_addrs is null ? __IntPtr.Zero : pp_wl_addrs.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var __ret = __Internal.SdBleGapWhitelistSet(__arg0, __arg1, len);
            return __ret;
        }

        public static uint SdBleGapDeviceIdentitiesSet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapIdKeyT pp_id_keys, global::NrfBleDriver.BleGapIrkT pp_local_irks, byte len)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var ____arg1 = pp_id_keys is null ? __IntPtr.Zero : pp_id_keys.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ____arg2 = pp_local_irks is null ? __IntPtr.Zero : pp_local_irks.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var __ret = __Internal.SdBleGapDeviceIdentitiesSet(__arg0, __arg1, __arg2, len);
            return __ret;
        }

        public static uint SdBleGapPrivacySet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapPrivacyParamsT p_privacy_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_privacy_params is null ? __IntPtr.Zero : p_privacy_params.__Instance;
            var __ret = __Internal.SdBleGapPrivacySet(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleGapPrivacyGet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapPrivacyParamsT p_privacy_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_privacy_params is null ? __IntPtr.Zero : p_privacy_params.__Instance;
            var __ret = __Internal.SdBleGapPrivacyGet(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleGapAdvDataSet(global::NrfBleDriver.AdapterT adapter, byte* p_adv_data, byte dlen, byte* p_sr_data, byte srdlen)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapAdvDataSet(__arg0, p_adv_data, dlen, p_sr_data, srdlen);
            return __ret;
        }

        public static uint SdBleGapAdvStart(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapAdvParamsT p_adv_params, byte conn_cfg_tag)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_adv_params is null ? __IntPtr.Zero : p_adv_params.__Instance;
            var __ret = __Internal.SdBleGapAdvStart(__arg0, __arg1, conn_cfg_tag);
            return __ret;
        }

        public static uint SdBleGapAdvStop(global::NrfBleDriver.AdapterT adapter)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapAdvStop(__arg0);
            return __ret;
        }

        public static uint SdBleGapConnParamUpdate(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapConnParamsT p_conn_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_conn_params is null ? __IntPtr.Zero : p_conn_params.__Instance;
            var __ret = __Internal.SdBleGapConnParamUpdate(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGapDisconnect(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, byte hci_status_code)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapDisconnect(__arg0, conn_handle, hci_status_code);
            return __ret;
        }

        public static uint SdBleGapTxPowerSet(global::NrfBleDriver.AdapterT adapter, sbyte tx_power)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapTxPowerSet(__arg0, tx_power);
            return __ret;
        }

        public static uint SdBleGapAppearanceSet(global::NrfBleDriver.AdapterT adapter, ushort appearance)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapAppearanceSet(__arg0, appearance);
            return __ret;
        }

        public static uint SdBleGapAppearanceGet(global::NrfBleDriver.AdapterT adapter, ref ushort p_appearance)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (ushort* __p_appearance1 = &p_appearance)
            {
                var __arg1 = __p_appearance1;
                var __ret = __Internal.SdBleGapAppearanceGet(__arg0, __arg1);
                return __ret;
            }
        }

        public static uint SdBleGapPpcpSet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapConnParamsT p_conn_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_conn_params is null ? __IntPtr.Zero : p_conn_params.__Instance;
            var __ret = __Internal.SdBleGapPpcpSet(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleGapPpcpGet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapConnParamsT p_conn_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_conn_params is null ? __IntPtr.Zero : p_conn_params.__Instance;
            var __ret = __Internal.SdBleGapPpcpGet(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleGapDeviceNameSet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapConnSecModeT p_write_perm, byte* p_dev_name, ushort len)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_write_perm is null ? __IntPtr.Zero : p_write_perm.__Instance;
            var __ret = __Internal.SdBleGapDeviceNameSet(__arg0, __arg1, p_dev_name, len);
            return __ret;
        }

        public static uint SdBleGapDeviceNameGet(global::NrfBleDriver.AdapterT adapter, byte* p_dev_name, ref ushort p_dev_name_len)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (ushort* __p_dev_name_len2 = &p_dev_name_len)
            {
                var __arg2 = __p_dev_name_len2;
                var __ret = __Internal.SdBleGapDeviceNameGet(__arg0, p_dev_name, __arg2);
                return __ret;
            }
        }

        public static uint SdBleGapAuthenticate(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapSecParamsT p_sec_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_sec_params is null ? __IntPtr.Zero : p_sec_params.__Instance;
            var __ret = __Internal.SdBleGapAuthenticate(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGapSecParamsReply(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, byte sec_status, global::NrfBleDriver.BleGapSecParamsT p_sec_params, global::NrfBleDriver.BleGapSecKeysetT p_sec_keyset)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg3 = p_sec_params is null ? __IntPtr.Zero : p_sec_params.__Instance;
            var __arg4 = p_sec_keyset is null ? __IntPtr.Zero : p_sec_keyset.__Instance;
            var __ret = __Internal.SdBleGapSecParamsReply(__arg0, conn_handle, sec_status, __arg3, __arg4);
            return __ret;
        }

        public static uint SdBleGapAuthKeyReply(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, byte key_type, byte* p_key)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapAuthKeyReply(__arg0, conn_handle, key_type, p_key);
            return __ret;
        }

        public static uint SdBleGapLescDhkeyReply(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapLescDhkeyT p_dhkey)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_dhkey is null ? __IntPtr.Zero : p_dhkey.__Instance;
            var __ret = __Internal.SdBleGapLescDhkeyReply(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGapKeypressNotify(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, byte kp_not)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapKeypressNotify(__arg0, conn_handle, kp_not);
            return __ret;
        }

        public static uint SdBleGapLescOobDataGet(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapLescP256PkT p_pk_own, global::NrfBleDriver.BleGapLescOobDataT p_oobd_own)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_pk_own is null ? __IntPtr.Zero : p_pk_own.__Instance;
            var __arg3 = p_oobd_own is null ? __IntPtr.Zero : p_oobd_own.__Instance;
            var __ret = __Internal.SdBleGapLescOobDataGet(__arg0, conn_handle, __arg2, __arg3);
            return __ret;
        }

        public static uint SdBleGapLescOobDataSet(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapLescOobDataT p_oobd_own, global::NrfBleDriver.BleGapLescOobDataT p_oobd_peer)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_oobd_own is null ? __IntPtr.Zero : p_oobd_own.__Instance;
            var __arg3 = p_oobd_peer is null ? __IntPtr.Zero : p_oobd_peer.__Instance;
            var __ret = __Internal.SdBleGapLescOobDataSet(__arg0, conn_handle, __arg2, __arg3);
            return __ret;
        }

        public static uint SdBleGapEncrypt(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapMasterIdT p_master_id, global::NrfBleDriver.BleGapEncInfoT p_enc_info)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_master_id is null ? __IntPtr.Zero : p_master_id.__Instance;
            var __arg3 = p_enc_info is null ? __IntPtr.Zero : p_enc_info.__Instance;
            var __ret = __Internal.SdBleGapEncrypt(__arg0, conn_handle, __arg2, __arg3);
            return __ret;
        }

        public static uint SdBleGapSecInfoReply(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapEncInfoT p_enc_info, global::NrfBleDriver.BleGapIrkT p_id_info, global::NrfBleDriver.BleGapSignInfoT p_sign_info)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_enc_info is null ? __IntPtr.Zero : p_enc_info.__Instance;
            var __arg3 = p_id_info is null ? __IntPtr.Zero : p_id_info.__Instance;
            var __arg4 = p_sign_info is null ? __IntPtr.Zero : p_sign_info.__Instance;
            var __ret = __Internal.SdBleGapSecInfoReply(__arg0, conn_handle, __arg2, __arg3, __arg4);
            return __ret;
        }

        public static uint SdBleGapConnSecGet(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapConnSecT p_conn_sec)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_conn_sec is null ? __IntPtr.Zero : p_conn_sec.__Instance;
            var __ret = __Internal.SdBleGapConnSecGet(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGapRssiStart(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, byte threshold_dbm, byte skip_count)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapRssiStart(__arg0, conn_handle, threshold_dbm, skip_count);
            return __ret;
        }

        public static uint SdBleGapRssiStop(global::NrfBleDriver.AdapterT adapter, ushort conn_handle)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapRssiStop(__arg0, conn_handle);
            return __ret;
        }

        public static uint SdBleGapRssiGet(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, sbyte* p_rssi)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapRssiGet(__arg0, conn_handle, p_rssi);
            return __ret;
        }

        public static uint SdBleGapScanStart(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapScanParamsT p_scan_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_scan_params is null ? __IntPtr.Zero : p_scan_params.__Instance;
            var __ret = __Internal.SdBleGapScanStart(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleGapScanStop(global::NrfBleDriver.AdapterT adapter)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapScanStop(__arg0);
            return __ret;
        }

        public static uint SdBleGapConnect(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapAddrT p_peer_addr, global::NrfBleDriver.BleGapScanParamsT p_scan_params, global::NrfBleDriver.BleGapConnParamsT p_conn_params, byte conn_cfg_tag)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_peer_addr is null ? __IntPtr.Zero : p_peer_addr.__Instance;
            var __arg2 = p_scan_params is null ? __IntPtr.Zero : p_scan_params.__Instance;
            var __arg3 = p_conn_params is null ? __IntPtr.Zero : p_conn_params.__Instance;
            var __ret = __Internal.SdBleGapConnect(__arg0, __arg1, __arg2, __arg3, conn_cfg_tag);
            return __ret;
        }

        public static uint SdBleGapConnectCancel(global::NrfBleDriver.AdapterT adapter)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapConnectCancel(__arg0);
            return __ret;
        }

        public static uint SdBleGapPhyUpdate(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapPhysT p_gap_phys)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_gap_phys is null ? __IntPtr.Zero : p_gap_phys.__Instance;
            var __ret = __Internal.SdBleGapPhyUpdate(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGapDataLengthUpdate(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapDataLengthParamsT p_dl_params, global::NrfBleDriver.BleGapDataLengthLimitationT p_dl_limitation)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_dl_params is null ? __IntPtr.Zero : p_dl_params.__Instance;
            var __arg3 = p_dl_limitation is null ? __IntPtr.Zero : p_dl_limitation.__Instance;
            var __ret = __Internal.SdBleGapDataLengthUpdate(__arg0, conn_handle, __arg2, __arg3);
            return __ret;
        }
    }

    /// <summary>L2CAP API SVC numbers.</summary>
    public enum BLE_L2CAP_SVCS
    {
        /// <summary>Set up an L2CAP channel.</summary>
        SD_BLE_L2CAP_CH_SETUP = 176,
        /// <summary>Release an L2CAP channel.</summary>
        SD_BLE_L2CAP_CH_RELEASE = 177,
        /// <summary>Receive an SDU on an L2CAP channel.</summary>
        SD_BLE_L2CAP_CH_RX = 178,
        /// <summary>Transmit an SDU on an L2CAP channel.</summary>
        SD_BLE_L2CAP_CH_TX = 179,
        /// <summary>Advanced SDU reception flow control.</summary>
        SD_BLE_L2CAP_CH_FLOW_CONTROL = 180
    }

    /// <summary>L2CAP Event IDs.</summary>
    public enum BLE_L2CAP_EVTS
    {
        /// <summary>
        /// <para>L2CAP Channel Setup Request event.</para>
        /// <para>See</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_SETUP_REQUEST = 112,
        /// <summary>
        /// <para>L2CAP Channel Setup Refused event.</para>
        /// <para>See</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_SETUP_REFUSED = 113,
        /// <summary>
        /// <para>L2CAP Channel Setup Completed event.</para>
        /// <para>See</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_SETUP = 114,
        /// <summary>
        /// <para>L2CAP Channel Released event.</para>
        /// <para>No additional event structure applies.</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_RELEASED = 115,
        /// <summary>
        /// <para>L2CAP Channel SDU data buffer released event.</para>
        /// <para>See</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED = 116,
        /// <summary>
        /// <para>L2CAP Channel Credit received.</para>
        /// <para>See</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_CREDIT = 117,
        /// <summary>
        /// <para>L2CAP Channel SDU received.</para>
        /// <para>See</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_RX = 118,
        /// <summary>
        /// <para>L2CAP Channel SDU transmitted.</para>
        /// <para>See</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_TX = 119
    }

    /// <summary>BLE L2CAP connection configuration parameters, set with</summary>
    /// <remarks>
    /// <para>These parameters are set per connection, so all L2CAP channels created on this connection</para>
    /// <para>will have the same parameters.</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  One or more of the following is true:</para>
    /// <para>- rx_mps is smaller than- tx_mps is smaller than- ch_count is greater than</para>
    /// <para>::NRF_ERROR_NO_MEM         rx_mps or tx_mps is set too high.</para>
    /// </remarks>
    /// <summary>L2CAP channel RX parameters.</summary>
    /// <summary>L2CAP channel setup parameters.</summary>
    /// <summary>L2CAP channel TX parameters.</summary>
    /// <summary>L2CAP Channel Setup Request event.</summary>
    /// <summary>L2CAP Channel Setup Refused event.</summary>
    /// <summary>L2CAP Channel Setup Completed event.</summary>
    /// <summary>L2CAP Channel SDU Data Duffer Released event.</summary>
    /// <summary>L2CAP Channel Credit received event.</summary>
    /// <summary>L2CAP Channel received SDU event.</summary>
    /// <summary>L2CAP Channel transmitted SDU event.</summary>
    /// <summary>L2CAP event structure.</summary>
    /// <summary>BLE L2CAP connection configuration parameters, set with</summary>
    /// <remarks>
    /// <para>These parameters are set per connection, so all L2CAP channels created on this connection</para>
    /// <para>will have the same parameters.</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  One or more of the following is true:</para>
    /// <para>- rx_mps is smaller than- tx_mps is smaller than- ch_count is greater than</para>
    /// <para>::NRF_ERROR_NO_MEM         rx_mps or tx_mps is set too high.</para>
    /// </remarks>
    public unsafe partial class BleL2capConnCfgT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort rx_mps;
            internal ushort tx_mps;
            internal byte rx_queue_size;
            internal byte tx_queue_size;
            internal byte ch_count;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_conn_cfg_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capConnCfgT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capConnCfgT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capConnCfgT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capConnCfgT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capConnCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capConnCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capConnCfgT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capConnCfgT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capConnCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capConnCfgT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capConnCfgT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capConnCfgT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capConnCfgT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capConnCfgT(global::NrfBleDriver.BleL2capConnCfgT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capConnCfgT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capConnCfgT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The maximum L2CAP PDU payload size, in bytes, that L2CAP shall</para>
        /// <para>be able to receive on L2CAP channels on connections with this</para>
        /// <para>configuration. The minimum value is</para>
        /// </summary>
        public ushort RxMps
        {
            get
            {
                return ((__Internal*)__Instance)->rx_mps;
            }

            set
            {
                ((__Internal*)__Instance)->rx_mps = value;
            }
        }

        /// <summary>
        /// <para>The maximum L2CAP PDU payload size, in bytes, that L2CAP shall</para>
        /// <para>be able to transmit on L2CAP channels on connections with this</para>
        /// <para>configuration. The minimum value is</para>
        /// </summary>
        public ushort TxMps
        {
            get
            {
                return ((__Internal*)__Instance)->tx_mps;
            }

            set
            {
                ((__Internal*)__Instance)->tx_mps = value;
            }
        }

        /// <summary>
        /// <para>Number of SDU data buffers that can be queued for reception per</para>
        /// <para>L2CAP channel. The minimum value is one.</para>
        /// </summary>
        public byte RxQueueSize
        {
            get
            {
                return ((__Internal*)__Instance)->rx_queue_size;
            }

            set
            {
                ((__Internal*)__Instance)->rx_queue_size = value;
            }
        }

        /// <summary>
        /// <para>Number of SDU data buffers that can be queued for transmission</para>
        /// <para>per L2CAP channel. The minimum value is one.</para>
        /// </summary>
        public byte TxQueueSize
        {
            get
            {
                return ((__Internal*)__Instance)->tx_queue_size;
            }

            set
            {
                ((__Internal*)__Instance)->tx_queue_size = value;
            }
        }

        /// <summary>
        /// <para>Number of L2CAP channels the application can create per connection</para>
        /// <para>with this configuration. The default value is zero, the maximum</para>
        /// <para>value is</para>
        /// </summary>
        /// <remarks>
        /// <para>if this parameter is set to zero, all other parameters in</para>
        /// <para>are ignored.</para>
        /// </remarks>
        public byte ChCount
        {
            get
            {
                return ((__Internal*)__Instance)->ch_count;
            }

            set
            {
                ((__Internal*)__Instance)->ch_count = value;
            }
        }
    }

    /// <summary>L2CAP channel RX parameters.</summary>
    public unsafe partial class BleL2capChRxParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal ushort rx_mtu;
            internal ushort rx_mps;
            internal global::NrfBleDriver.BleDataT.__Internal sdu_buf;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_ch_rx_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capChRxParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capChRxParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capChRxParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capChRxParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capChRxParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capChRxParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capChRxParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capChRxParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capChRxParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capChRxParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capChRxParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capChRxParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capChRxParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capChRxParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capChRxParamsT(global::NrfBleDriver.BleL2capChRxParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capChRxParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capChRxParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capChRxParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The maximum L2CAP SDU size, in bytes, that L2CAP shall be able to</para>
        /// <para>receive on this L2CAP channel.</para>
        /// <para>- Must be equal to or greater than</para>
        /// </summary>
        public ushort RxMtu
        {
            get
            {
                return ((__Internal*)__Instance)->rx_mtu;
            }

            set
            {
                ((__Internal*)__Instance)->rx_mtu = value;
            }
        }

        /// <summary>
        /// <para>The maximum L2CAP PDU payload size, in bytes, that L2CAP shall be</para>
        /// <para>able to receive on this L2CAP channel.</para>
        /// <para>- Must be equal to or greater than- Must be equal to or less than</para>
        /// </summary>
        public ushort RxMps
        {
            get
            {
                return ((__Internal*)__Instance)->rx_mps;
            }

            set
            {
                ((__Internal*)__Instance)->rx_mps = value;
            }
        }

        /// <summary>
        /// <para>SDU data buffer for reception.</para>
        /// <para>- Ifis non-NULL, initial credits are</para>
        /// <para>issued to the peer.</para>
        /// <para>- Ifis NULL, no initial credits are</para>
        /// <para>issued to the peer.</para>
        /// </summary>
        public global::NrfBleDriver.BleDataT SduBuf
        {
            get
            {
                return global::NrfBleDriver.BleDataT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sdu_buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sdu_buf = *(global::NrfBleDriver.BleDataT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>L2CAP channel setup parameters.</summary>
    public unsafe partial class BleL2capChSetupParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleL2capChRxParamsT.__Internal rx_params;
            internal ushort le_psm;
            internal ushort status;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_ch_setup_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capChSetupParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capChSetupParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capChSetupParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capChSetupParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capChSetupParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capChSetupParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capChSetupParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capChSetupParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capChSetupParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capChSetupParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capChSetupParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capChSetupParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capChSetupParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capChSetupParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capChSetupParamsT(global::NrfBleDriver.BleL2capChSetupParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capChSetupParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capChSetupParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capChSetupParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>L2CAP channel RX parameters.</summary>
        public global::NrfBleDriver.BleL2capChRxParamsT RxParams
        {
            get
            {
                return global::NrfBleDriver.BleL2capChRxParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->rx_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->rx_params = *(global::NrfBleDriver.BleL2capChRxParamsT.__Internal*) value.__Instance;
            }
        }

        /// <summary>
        /// <para>LE Protocol/Service Multiplexer. Used when requesting</para>
        /// <para>setup of an L2CAP channel, ignored otherwise.</para>
        /// </summary>
        public ushort LePsm
        {
            get
            {
                return ((__Internal*)__Instance)->le_psm;
            }

            set
            {
                ((__Internal*)__Instance)->le_psm = value;
            }
        }

        /// <summary>
        /// <para>Status code, seeUsed when replying to a setup request of an L2CAP</para>
        /// <para>channel, ignored otherwise.</para>
        /// </summary>
        public ushort Status
        {
            get
            {
                return ((__Internal*)__Instance)->status;
            }

            set
            {
                ((__Internal*)__Instance)->status = value;
            }
        }
    }

    /// <summary>L2CAP channel TX parameters.</summary>
    public unsafe partial class BleL2capChTxParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort tx_mtu;
            internal ushort peer_mps;
            internal ushort tx_mps;
            internal ushort credits;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_ch_tx_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capChTxParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capChTxParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capChTxParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capChTxParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capChTxParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capChTxParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capChTxParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capChTxParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capChTxParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capChTxParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capChTxParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capChTxParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capChTxParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capChTxParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capChTxParamsT(global::NrfBleDriver.BleL2capChTxParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capChTxParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capChTxParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capChTxParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The maximum L2CAP SDU size, in bytes, that L2CAP is able to</para>
        /// <para>transmit on this L2CAP channel.</para>
        /// </summary>
        public ushort TxMtu
        {
            get
            {
                return ((__Internal*)__Instance)->tx_mtu;
            }

            set
            {
                ((__Internal*)__Instance)->tx_mtu = value;
            }
        }

        /// <summary>
        /// <para>The maximum L2CAP PDU payload size, in bytes, that the peer is</para>
        /// <para>able to receive on this L2CAP channel.</para>
        /// </summary>
        public ushort PeerMps
        {
            get
            {
                return ((__Internal*)__Instance)->peer_mps;
            }

            set
            {
                ((__Internal*)__Instance)->peer_mps = value;
            }
        }

        /// <summary>
        /// <para>The maximum L2CAP PDU payload size, in bytes, that L2CAP is able</para>
        /// <para>to transmit on this L2CAP channel. This is effective tx_mps,</para>
        /// <para>selected by the SoftDevice as</para>
        /// <para>MIN()</para>
        /// </summary>
        public ushort TxMps
        {
            get
            {
                return ((__Internal*)__Instance)->tx_mps;
            }

            set
            {
                ((__Internal*)__Instance)->tx_mps = value;
            }
        }

        /// <summary>Initial credits given by the peer.</summary>
        public ushort Credits
        {
            get
            {
                return ((__Internal*)__Instance)->credits;
            }

            set
            {
                ((__Internal*)__Instance)->credits = value;
            }
        }
    }

    /// <summary>L2CAP Channel Setup Request event.</summary>
    public unsafe partial class BleL2capEvtChSetupRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 10)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleL2capChTxParamsT.__Internal tx_params;
            internal ushort le_psm;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_ch_setup_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSetupRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSetupRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtChSetupRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtChSetupRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtChSetupRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtChSetupRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtChSetupRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtChSetupRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtChSetupRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtChSetupRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtChSetupRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtChSetupRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtChSetupRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSetupRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtChSetupRequestT(global::NrfBleDriver.BleL2capEvtChSetupRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSetupRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtChSetupRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtChSetupRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>L2CAP channel TX parameters.</summary>
        public global::NrfBleDriver.BleL2capChTxParamsT TxParams
        {
            get
            {
                return global::NrfBleDriver.BleL2capChTxParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->tx_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->tx_params = *(global::NrfBleDriver.BleL2capChTxParamsT.__Internal*) value.__Instance;
            }
        }

        /// <summary>LE Protocol/Service Multiplexer.</summary>
        public ushort LePsm
        {
            get
            {
                return ((__Internal*)__Instance)->le_psm;
            }

            set
            {
                ((__Internal*)__Instance)->le_psm = value;
            }
        }
    }

    /// <summary>L2CAP Channel Setup Refused event.</summary>
    public unsafe partial class BleL2capEvtChSetupRefusedT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal byte source;
            internal ushort status;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_ch_setup_refused_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSetupRefusedT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSetupRefusedT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtChSetupRefusedT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtChSetupRefusedT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtChSetupRefusedT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtChSetupRefusedT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtChSetupRefusedT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtChSetupRefusedT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtChSetupRefusedT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtChSetupRefusedT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtChSetupRefusedT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtChSetupRefusedT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtChSetupRefusedT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSetupRefusedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtChSetupRefusedT(global::NrfBleDriver.BleL2capEvtChSetupRefusedT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSetupRefusedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtChSetupRefusedT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtChSetupRefusedT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Source, see</summary>
        public byte Source
        {
            get
            {
                return ((__Internal*)__Instance)->source;
            }

            set
            {
                ((__Internal*)__Instance)->source = value;
            }
        }

        /// <summary>Status code, see</summary>
        public ushort Status
        {
            get
            {
                return ((__Internal*)__Instance)->status;
            }

            set
            {
                ((__Internal*)__Instance)->status = value;
            }
        }
    }

    /// <summary>L2CAP Channel Setup Completed event.</summary>
    public unsafe partial class BleL2capEvtChSetupT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleL2capChTxParamsT.__Internal tx_params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_ch_setup_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSetupT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSetupT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtChSetupT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtChSetupT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtChSetupT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtChSetupT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtChSetupT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtChSetupT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtChSetupT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtChSetupT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtChSetupT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtChSetupT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtChSetupT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSetupT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtChSetupT(global::NrfBleDriver.BleL2capEvtChSetupT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSetupT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtChSetupT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtChSetupT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>L2CAP channel TX parameters.</summary>
        public global::NrfBleDriver.BleL2capChTxParamsT TxParams
        {
            get
            {
                return global::NrfBleDriver.BleL2capChTxParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->tx_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->tx_params = *(global::NrfBleDriver.BleL2capChTxParamsT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>L2CAP Channel SDU Data Duffer Released event.</summary>
    public unsafe partial class BleL2capEvtChSduBufReleasedT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleDataT.__Internal sdu_buf;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_ch_sdu_buf_released_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSduBufReleasedT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSduBufReleasedT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtChSduBufReleasedT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtChSduBufReleasedT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtChSduBufReleasedT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtChSduBufReleasedT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtChSduBufReleasedT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtChSduBufReleasedT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtChSduBufReleasedT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtChSduBufReleasedT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtChSduBufReleasedT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtChSduBufReleasedT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtChSduBufReleasedT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSduBufReleasedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtChSduBufReleasedT(global::NrfBleDriver.BleL2capEvtChSduBufReleasedT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSduBufReleasedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtChSduBufReleasedT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtChSduBufReleasedT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Returned reception or transmission SDU data buffer. The SoftDevice</para>
        /// <para>returns SDU data buffers supplied by the application, which have</para>
        /// <para>not yet been returned previously via aor</para>
        /// <para>event.</para>
        /// </summary>
        public global::NrfBleDriver.BleDataT SduBuf
        {
            get
            {
                return global::NrfBleDriver.BleDataT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sdu_buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sdu_buf = *(global::NrfBleDriver.BleDataT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>L2CAP Channel Credit received event.</summary>
    public unsafe partial class BleL2capEvtChCreditT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal ushort credits;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_ch_credit_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChCreditT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChCreditT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtChCreditT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtChCreditT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtChCreditT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtChCreditT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtChCreditT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtChCreditT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtChCreditT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtChCreditT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtChCreditT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtChCreditT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtChCreditT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChCreditT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtChCreditT(global::NrfBleDriver.BleL2capEvtChCreditT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChCreditT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtChCreditT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtChCreditT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Additional credits given by the peer.</summary>
        public ushort Credits
        {
            get
            {
                return ((__Internal*)__Instance)->credits;
            }

            set
            {
                ((__Internal*)__Instance)->credits = value;
            }
        }
    }

    /// <summary>L2CAP Channel received SDU event.</summary>
    public unsafe partial class BleL2capEvtChRxT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal ushort sdu_len;
            internal global::NrfBleDriver.BleDataT.__Internal sdu_buf;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_ch_rx_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChRxT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChRxT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtChRxT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtChRxT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtChRxT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtChRxT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtChRxT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtChRxT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtChRxT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtChRxT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtChRxT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtChRxT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtChRxT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChRxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtChRxT(global::NrfBleDriver.BleL2capEvtChRxT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChRxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtChRxT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtChRxT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Total SDU length, in bytes.</summary>
        public ushort SduLen
        {
            get
            {
                return ((__Internal*)__Instance)->sdu_len;
            }

            set
            {
                ((__Internal*)__Instance)->sdu_len = value;
            }
        }

        /// <summary>SDU data buffer.</summary>
        /// <remarks>
        /// <para>If there is not enough space in the buffer</para>
        /// <para>(sdu_buf.len&lt;sdu_len) then the rest of the SDU will be</para>
        /// <para>silently discarded by the SoftDevice.</para>
        /// </remarks>
        public global::NrfBleDriver.BleDataT SduBuf
        {
            get
            {
                return global::NrfBleDriver.BleDataT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sdu_buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sdu_buf = *(global::NrfBleDriver.BleDataT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>L2CAP Channel transmitted SDU event.</summary>
    public unsafe partial class BleL2capEvtChTxT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleDataT.__Internal sdu_buf;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_ch_tx_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChTxT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChTxT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtChTxT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtChTxT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtChTxT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtChTxT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtChTxT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtChTxT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtChTxT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtChTxT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtChTxT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtChTxT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtChTxT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChTxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtChTxT(global::NrfBleDriver.BleL2capEvtChTxT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChTxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtChTxT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtChTxT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>SDU data buffer.</summary>
        public global::NrfBleDriver.BleDataT SduBuf
        {
            get
            {
                return global::NrfBleDriver.BleDataT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sdu_buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sdu_buf = *(global::NrfBleDriver.BleDataT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>L2CAP event structure.</summary>
    public unsafe partial class BleL2capEvtT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal ushort local_cid;
            internal global::NrfBleDriver.BleL2capEvtT.Params.__Internal @params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Params
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtChSetupRequestT.__Internal ch_setup_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtChSetupRefusedT.__Internal ch_setup_refused;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtChSetupT.__Internal ch_setup;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtChSduBufReleasedT.__Internal ch_sdu_buf_released;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtChCreditT.__Internal credit;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtChRxT.__Internal rx;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtChTxT.__Internal tx;

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-params>@ble_l2cap_evt_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Params.__Internal __instance;
            internal Params.__Internal __Instance => __instance;

            internal static Params __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Params(native.ToPointer(), skipVTables);
            }

            internal static Params __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Params(native, skipVTables);
            }

            private Params(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Params(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleL2capEvtT.Params.__Internal*) native;
            }

            public Params(global::NrfBleDriver.BleL2capEvtT.Params __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>L2CAP Channel Setup Request Event Parameters.</summary>
            public global::NrfBleDriver.BleL2capEvtChSetupRequestT ChSetupRequest
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtChSetupRequestT.__CreateInstance(__instance.ch_setup_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.ch_setup_request = *(global::NrfBleDriver.BleL2capEvtChSetupRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP Channel Setup Refused Event Parameters.</summary>
            public global::NrfBleDriver.BleL2capEvtChSetupRefusedT ChSetupRefused
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtChSetupRefusedT.__CreateInstance(__instance.ch_setup_refused);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.ch_setup_refused = *(global::NrfBleDriver.BleL2capEvtChSetupRefusedT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP Channel Setup Completed Event Parameters.</summary>
            public global::NrfBleDriver.BleL2capEvtChSetupT ChSetup
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtChSetupT.__CreateInstance(__instance.ch_setup);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.ch_setup = *(global::NrfBleDriver.BleL2capEvtChSetupT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP Channel SDU Data Buffer Released Event Parameters.</summary>
            public global::NrfBleDriver.BleL2capEvtChSduBufReleasedT ChSduBufReleased
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtChSduBufReleasedT.__CreateInstance(__instance.ch_sdu_buf_released);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.ch_sdu_buf_released = *(global::NrfBleDriver.BleL2capEvtChSduBufReleasedT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP Channel Credit Received Event Parameters.</summary>
            public global::NrfBleDriver.BleL2capEvtChCreditT Credit
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtChCreditT.__CreateInstance(__instance.credit);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.credit = *(global::NrfBleDriver.BleL2capEvtChCreditT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP Channel SDU Received Event Parameters.</summary>
            public global::NrfBleDriver.BleL2capEvtChRxT Rx
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtChRxT.__CreateInstance(__instance.rx);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.rx = *(global::NrfBleDriver.BleL2capEvtChRxT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP Channel SDU Transmitted Event Parameters.</summary>
            public global::NrfBleDriver.BleL2capEvtChTxT Tx
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtChTxT.__CreateInstance(__instance.tx);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.tx = *(global::NrfBleDriver.BleL2capEvtChTxT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtT(global::NrfBleDriver.BleL2capEvtT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle on which the event occured.</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>
        /// <para>Local Channel ID of the L2CAP channel, or</para>
        /// <para>if not present.</para>
        /// </summary>
        public ushort LocalCid
        {
            get
            {
                return ((__Internal*)__Instance)->local_cid;
            }

            set
            {
                ((__Internal*)__Instance)->local_cid = value;
            }
        }

        /// <summary>Event Parameters.</summary>
        public global::NrfBleDriver.BleL2capEvtT.Params @params
        {
            get
            {
                return global::NrfBleDriver.BleL2capEvtT.Params.__CreateInstance(((__Internal*)__Instance)->@params);
            }

            set
            {
                ((__Internal*)__Instance)->@params = value.__Instance;
            }
        }
    }

    public unsafe partial class ble_l2cap
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_l2cap_ch_setup", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleL2capChSetup(__IntPtr adapter, ushort conn_handle, ushort* p_local_cid, __IntPtr p_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_l2cap_ch_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleL2capChRelease(__IntPtr adapter, ushort conn_handle, ushort local_cid);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_l2cap_ch_rx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleL2capChRx(__IntPtr adapter, ushort conn_handle, ushort local_cid, __IntPtr p_sdu_buf);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_l2cap_ch_tx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleL2capChTx(__IntPtr adapter, ushort conn_handle, ushort local_cid, __IntPtr p_sdu_buf);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_l2cap_ch_flow_control", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleL2capChFlowControl(__IntPtr adapter, ushort conn_handle, ushort local_cid, ushort credits, ushort* p_credits);
        }

        public static uint SdBleL2capChSetup(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ref ushort p_local_cid, global::NrfBleDriver.BleL2capChSetupParamsT p_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (ushort* __p_local_cid2 = &p_local_cid)
            {
                var __arg2 = __p_local_cid2;
                var __arg3 = p_params is null ? __IntPtr.Zero : p_params.__Instance;
                var __ret = __Internal.SdBleL2capChSetup(__arg0, conn_handle, __arg2, __arg3);
                return __ret;
            }
        }

        public static uint SdBleL2capChRelease(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort local_cid)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleL2capChRelease(__arg0, conn_handle, local_cid);
            return __ret;
        }

        public static uint SdBleL2capChRx(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort local_cid, global::NrfBleDriver.BleDataT p_sdu_buf)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg3 = p_sdu_buf is null ? __IntPtr.Zero : p_sdu_buf.__Instance;
            var __ret = __Internal.SdBleL2capChRx(__arg0, conn_handle, local_cid, __arg3);
            return __ret;
        }

        public static uint SdBleL2capChTx(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort local_cid, global::NrfBleDriver.BleDataT p_sdu_buf)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg3 = p_sdu_buf is null ? __IntPtr.Zero : p_sdu_buf.__Instance;
            var __ret = __Internal.SdBleL2capChTx(__arg0, conn_handle, local_cid, __arg3);
            return __ret;
        }

        public static uint SdBleL2capChFlowControl(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort local_cid, ushort credits, ref ushort p_credits)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (ushort* __p_credits4 = &p_credits)
            {
                var __arg4 = __p_credits4;
                var __ret = __Internal.SdBleL2capChFlowControl(__arg0, conn_handle, local_cid, credits, __arg4);
                return __ret;
            }
        }
    }

    /// <summary>BLE GATT connection configuration parameters, set with</summary>
    /// <remarks>NRF_ERROR_INVALID_PARAM att_mtu is smaller than</remarks>
    /// <summary>GATT Characteristic Properties.</summary>
    /// <summary>GATT Characteristic Extended Properties.</summary>
    /// <summary>BLE GATT connection configuration parameters, set with</summary>
    /// <remarks>NRF_ERROR_INVALID_PARAM att_mtu is smaller than</remarks>
    public unsafe partial class BleGattConnCfgT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal ushort att_mtu;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatt_conn_cfg_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattConnCfgT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattConnCfgT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattConnCfgT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattConnCfgT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattConnCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattConnCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleGattConnCfgT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattConnCfgT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattConnCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattConnCfgT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattConnCfgT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattConnCfgT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattConnCfgT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattConnCfgT(global::NrfBleDriver.BleGattConnCfgT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattConnCfgT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattConnCfgT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Maximum size of ATT packet the SoftDevice can send or receive.</para>
        /// <para>The default and minimum value is</para>
        /// </summary>
        /// <remarks>s</remarks>
        public ushort AttMtu
        {
            get
            {
                return ((__Internal*)__Instance)->att_mtu;
            }

            set
            {
                ((__Internal*)__Instance)->att_mtu = value;
            }
        }
    }

    /// <summary>GATT Characteristic Properties.</summary>
    public unsafe partial class BleGattCharPropsT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte broadcast;

            [FieldOffset(0)]
            internal byte read;

            [FieldOffset(0)]
            internal byte write_wo_resp;

            [FieldOffset(0)]
            internal byte write;

            [FieldOffset(0)]
            internal byte notify;

            [FieldOffset(0)]
            internal byte indicate;

            [FieldOffset(0)]
            internal byte auth_signed_wr;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatt_char_props_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattCharPropsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattCharPropsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattCharPropsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattCharPropsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattCharPropsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattCharPropsT(native.ToPointer(), skipVTables);
        }

        internal static BleGattCharPropsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattCharPropsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattCharPropsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattCharPropsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattCharPropsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattCharPropsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattCharPropsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattCharPropsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattCharPropsT(global::NrfBleDriver.BleGattCharPropsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattCharPropsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattCharPropsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattCharPropsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Broadcasting of the value permitted.</summary>
        public byte Broadcast
        {
            get
            {
                return ((__Internal*)__Instance)->broadcast;
            }

            set
            {
                ((__Internal*)__Instance)->broadcast = value;
            }
        }

        /// <summary>Reading the value permitted.</summary>
        public byte Read
        {
            get
            {
                return ((__Internal*)__Instance)->read;
            }

            set
            {
                ((__Internal*)__Instance)->read = value;
            }
        }

        /// <summary>Writing the value with Write Command permitted.</summary>
        public byte WriteWoResp
        {
            get
            {
                return ((__Internal*)__Instance)->write_wo_resp;
            }

            set
            {
                ((__Internal*)__Instance)->write_wo_resp = value;
            }
        }

        /// <summary>Writing the value with Write Request permitted.</summary>
        public byte Write
        {
            get
            {
                return ((__Internal*)__Instance)->write;
            }

            set
            {
                ((__Internal*)__Instance)->write = value;
            }
        }

        /// <summary>Notification of the value permitted.</summary>
        public byte Notify
        {
            get
            {
                return ((__Internal*)__Instance)->notify;
            }

            set
            {
                ((__Internal*)__Instance)->notify = value;
            }
        }

        /// <summary>Indications of the value permitted.</summary>
        public byte Indicate
        {
            get
            {
                return ((__Internal*)__Instance)->indicate;
            }

            set
            {
                ((__Internal*)__Instance)->indicate = value;
            }
        }

        /// <summary>Writing the value with Signed Write Command permitted.</summary>
        public byte AuthSignedWr
        {
            get
            {
                return ((__Internal*)__Instance)->auth_signed_wr;
            }

            set
            {
                ((__Internal*)__Instance)->auth_signed_wr = value;
            }
        }
    }

    /// <summary>GATT Characteristic Extended Properties.</summary>
    public unsafe partial class BleGattCharExtPropsT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte reliable_wr;

            [FieldOffset(0)]
            internal byte wr_aux;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatt_char_ext_props_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattCharExtPropsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattCharExtPropsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattCharExtPropsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattCharExtPropsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattCharExtPropsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattCharExtPropsT(native.ToPointer(), skipVTables);
        }

        internal static BleGattCharExtPropsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattCharExtPropsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattCharExtPropsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattCharExtPropsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattCharExtPropsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattCharExtPropsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattCharExtPropsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattCharExtPropsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattCharExtPropsT(global::NrfBleDriver.BleGattCharExtPropsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattCharExtPropsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattCharExtPropsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattCharExtPropsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Writing the value with Queued Write operations permitted.</summary>
        public byte ReliableWr
        {
            get
            {
                return ((__Internal*)__Instance)->reliable_wr;
            }

            set
            {
                ((__Internal*)__Instance)->reliable_wr = value;
            }
        }

        /// <summary>Writing the Characteristic User Description descriptor permitted.</summary>
        public byte WrAux
        {
            get
            {
                return ((__Internal*)__Instance)->wr_aux;
            }

            set
            {
                ((__Internal*)__Instance)->wr_aux = value;
            }
        }
    }

    /// <summary>GATTC API SVC numbers.</summary>
    public enum BLE_GATTC_SVCS
    {
        /// <summary>Primary Service Discovery.</summary>
        SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER = 148,
        /// <summary>Relationship Discovery.</summary>
        SD_BLE_GATTC_RELATIONSHIPS_DISCOVER = 149,
        /// <summary>Characteristic Discovery.</summary>
        SD_BLE_GATTC_CHARACTERISTICS_DISCOVER = 150,
        /// <summary>Characteristic Descriptor Discovery.</summary>
        SD_BLE_GATTC_DESCRIPTORS_DISCOVER = 151,
        /// <summary>Attribute Information Discovery.</summary>
        SD_BLE_GATTC_ATTR_INFO_DISCOVER = 152,
        /// <summary>Read Characteristic Value by UUID.</summary>
        SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ = 153,
        /// <summary>Generic read.</summary>
        SD_BLE_GATTC_READ = 154,
        /// <summary>Read multiple Characteristic Values.</summary>
        SD_BLE_GATTC_CHAR_VALUES_READ = 155,
        /// <summary>Generic write.</summary>
        SD_BLE_GATTC_WRITE = 156,
        /// <summary>Handle Value Confirmation.</summary>
        SD_BLE_GATTC_HV_CONFIRM = 157,
        /// <summary>Exchange MTU Request.</summary>
        SD_BLE_GATTC_EXCHANGE_MTU_REQUEST = 158
    }

    /// <summary>GATT Client Event IDs.</summary>
    public enum BLE_GATTC_EVTS
    {
        /// <summary>Primary Service Discovery Response event.See</summary>
        BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP = 48,
        /// <summary>Relationship Discovery Response event.See</summary>
        BLE_GATTC_EVT_REL_DISC_RSP = 49,
        /// <summary>Characteristic Discovery Response event.See</summary>
        BLE_GATTC_EVT_CHAR_DISC_RSP = 50,
        /// <summary>Descriptor Discovery Response event.See</summary>
        BLE_GATTC_EVT_DESC_DISC_RSP = 51,
        /// <summary>Attribute Information Response event.See</summary>
        BLE_GATTC_EVT_ATTR_INFO_DISC_RSP = 52,
        /// <summary>Read By UUID Response event.See</summary>
        BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP = 53,
        /// <summary>Read Response event.See</summary>
        BLE_GATTC_EVT_READ_RSP = 54,
        /// <summary>Read multiple Response event.See</summary>
        BLE_GATTC_EVT_CHAR_VALS_READ_RSP = 55,
        /// <summary>Write Response event.See</summary>
        BLE_GATTC_EVT_WRITE_RSP = 56,
        /// <summary>Handle Value Notification or Indication event.Confirm indication withSee</summary>
        BLE_GATTC_EVT_HVX = 57,
        /// <summary>Exchange MTU Response event.See</summary>
        BLE_GATTC_EVT_EXCHANGE_MTU_RSP = 58,
        /// <summary>Timeout event.See</summary>
        BLE_GATTC_EVT_TIMEOUT = 59,
        /// <summary>Write without Response transmission complete.See</summary>
        BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE = 60
    }

    /// <summary>BLE GATTC connection configuration parameters, set with</summary>
    /// <summary>Operation Handle Range.</summary>
    /// <summary>GATT service.</summary>
    /// <summary>GATT include.</summary>
    /// <summary>GATT characteristic.</summary>
    /// <summary>GATT descriptor.</summary>
    /// <summary>Write Parameters.</summary>
    /// <summary>Attribute Information for 16-bit Attribute UUID.</summary>
    /// <summary>Attribute Information for 128-bit Attribute UUID.</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>GATT read by UUID handle value pair.</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>GATTC event structure.</summary>
    /// <summary>BLE GATTC connection configuration parameters, set with</summary>
    public unsafe partial class BleGattcConnCfgT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte write_cmd_tx_queue_size;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_conn_cfg_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcConnCfgT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcConnCfgT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcConnCfgT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcConnCfgT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcConnCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcConnCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcConnCfgT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcConnCfgT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcConnCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcConnCfgT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcConnCfgT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcConnCfgT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcConnCfgT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcConnCfgT(global::NrfBleDriver.BleGattcConnCfgT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcConnCfgT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcConnCfgT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The guaranteed minimum number of Write without Response that can be queued for transmission.</para>
        /// <para>The default value is</para>
        /// </summary>
        public byte WriteCmdTxQueueSize
        {
            get
            {
                return ((__Internal*)__Instance)->write_cmd_tx_queue_size;
            }

            set
            {
                ((__Internal*)__Instance)->write_cmd_tx_queue_size = value;
            }
        }
    }

    /// <summary>Operation Handle Range.</summary>
    public unsafe partial class BleGattcHandleRangeT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal ushort start_handle;
            internal ushort end_handle;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_handle_range_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcHandleRangeT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcHandleRangeT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcHandleRangeT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcHandleRangeT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcHandleRangeT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcHandleRangeT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcHandleRangeT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcHandleRangeT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcHandleRangeT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcHandleRangeT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcHandleRangeT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcHandleRangeT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcHandleRangeT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcHandleRangeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcHandleRangeT(global::NrfBleDriver.BleGattcHandleRangeT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcHandleRangeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcHandleRangeT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcHandleRangeT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Start Handle.</summary>
        public ushort StartHandle
        {
            get
            {
                return ((__Internal*)__Instance)->start_handle;
            }

            set
            {
                ((__Internal*)__Instance)->start_handle = value;
            }
        }

        /// <summary>End Handle.</summary>
        public ushort EndHandle
        {
            get
            {
                return ((__Internal*)__Instance)->end_handle;
            }

            set
            {
                ((__Internal*)__Instance)->end_handle = value;
            }
        }
    }

    /// <summary>GATT service.</summary>
    public unsafe partial class BleGattcServiceT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleUuidT.__Internal uuid;
            internal global::NrfBleDriver.BleGattcHandleRangeT.__Internal handle_range;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_service_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcServiceT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcServiceT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcServiceT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcServiceT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcServiceT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcServiceT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcServiceT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcServiceT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcServiceT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcServiceT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcServiceT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcServiceT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcServiceT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcServiceT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcServiceT(global::NrfBleDriver.BleGattcServiceT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcServiceT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcServiceT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcServiceT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Service UUID.</summary>
        public global::NrfBleDriver.BleUuidT Uuid
        {
            get
            {
                return global::NrfBleDriver.BleUuidT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uuid));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uuid = *(global::NrfBleDriver.BleUuidT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Service Handle Range.</summary>
        public global::NrfBleDriver.BleGattcHandleRangeT HandleRange
        {
            get
            {
                return global::NrfBleDriver.BleGattcHandleRangeT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->handle_range));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->handle_range = *(global::NrfBleDriver.BleGattcHandleRangeT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>GATT include.</summary>
    public unsafe partial class BleGattcIncludeT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 10)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal global::NrfBleDriver.BleGattcServiceT.__Internal included_srvc;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_include_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcIncludeT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcIncludeT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcIncludeT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcIncludeT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcIncludeT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcIncludeT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcIncludeT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcIncludeT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcIncludeT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcIncludeT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcIncludeT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcIncludeT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcIncludeT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcIncludeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcIncludeT(global::NrfBleDriver.BleGattcIncludeT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcIncludeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcIncludeT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcIncludeT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Include Handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Handle of the included service.</summary>
        public global::NrfBleDriver.BleGattcServiceT IncludedSrvc
        {
            get
            {
                return global::NrfBleDriver.BleGattcServiceT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->included_srvc));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->included_srvc = *(global::NrfBleDriver.BleGattcServiceT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>GATT characteristic.</summary>
    public unsafe partial class BleGattcCharT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 10)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleUuidT.__Internal uuid;
            internal global::NrfBleDriver.BleGattCharPropsT.__Internal char_props;
            internal byte char_ext_props;
            internal ushort handle_decl;
            internal ushort handle_value;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_char_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcCharT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcCharT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcCharT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcCharT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcCharT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcCharT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcCharT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcCharT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcCharT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcCharT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcCharT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcCharT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcCharT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcCharT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcCharT(global::NrfBleDriver.BleGattcCharT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcCharT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcCharT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcCharT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Characteristic UUID.</summary>
        public global::NrfBleDriver.BleUuidT Uuid
        {
            get
            {
                return global::NrfBleDriver.BleUuidT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uuid));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uuid = *(global::NrfBleDriver.BleUuidT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Characteristic Properties.</summary>
        public global::NrfBleDriver.BleGattCharPropsT CharProps
        {
            get
            {
                return global::NrfBleDriver.BleGattCharPropsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->char_props));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->char_props = *(global::NrfBleDriver.BleGattCharPropsT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Extended properties present.</summary>
        public byte CharExtProps
        {
            get
            {
                return ((__Internal*)__Instance)->char_ext_props;
            }

            set
            {
                ((__Internal*)__Instance)->char_ext_props = value;
            }
        }

        /// <summary>Handle of the Characteristic Declaration.</summary>
        public ushort HandleDecl
        {
            get
            {
                return ((__Internal*)__Instance)->handle_decl;
            }

            set
            {
                ((__Internal*)__Instance)->handle_decl = value;
            }
        }

        /// <summary>Handle of the Characteristic Value.</summary>
        public ushort HandleValue
        {
            get
            {
                return ((__Internal*)__Instance)->handle_value;
            }

            set
            {
                ((__Internal*)__Instance)->handle_value = value;
            }
        }
    }

    /// <summary>GATT descriptor.</summary>
    public unsafe partial class BleGattcDescT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 6)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal global::NrfBleDriver.BleUuidT.__Internal uuid;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_desc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcDescT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcDescT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcDescT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcDescT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcDescT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcDescT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcDescT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcDescT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcDescT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcDescT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcDescT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcDescT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcDescT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcDescT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcDescT(global::NrfBleDriver.BleGattcDescT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcDescT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcDescT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcDescT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Descriptor Handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Descriptor UUID.</summary>
        public global::NrfBleDriver.BleUuidT Uuid
        {
            get
            {
                return global::NrfBleDriver.BleUuidT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uuid));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uuid = *(global::NrfBleDriver.BleUuidT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Write Parameters.</summary>
    public unsafe partial class BleGattcWriteParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal byte write_op;
            internal byte flags;
            internal ushort handle;
            internal ushort offset;
            internal ushort len;
            internal __IntPtr p_value;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_write_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcWriteParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcWriteParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcWriteParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcWriteParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcWriteParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcWriteParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcWriteParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcWriteParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcWriteParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcWriteParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcWriteParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcWriteParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcWriteParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcWriteParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcWriteParamsT(global::NrfBleDriver.BleGattcWriteParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcWriteParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcWriteParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcWriteParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Write Operation to be performed, see</summary>
        public byte WriteOp
        {
            get
            {
                return ((__Internal*)__Instance)->write_op;
            }

            set
            {
                ((__Internal*)__Instance)->write_op = value;
            }
        }

        /// <summary>Flags, see</summary>
        public byte Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        /// <summary>Handle to the attribute to be written.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Offset in bytes.</summary>
        /// <remarks>For WRITE_CMD and WRITE_REQ, offset must be 0.</remarks>
        public ushort Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }

        /// <summary>Length of data in bytes.</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        /// <summary>Pointer to the value data.</summary>
        public byte* PValue
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_value;
            }
        }
    }

    /// <summary>Attribute Information for 16-bit Attribute UUID.</summary>
    public unsafe partial class BleGattcAttrInfo16T : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 6)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal global::NrfBleDriver.BleUuidT.__Internal uuid;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_attr_info16_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcAttrInfo16T> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcAttrInfo16T>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcAttrInfo16T managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcAttrInfo16T managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcAttrInfo16T __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcAttrInfo16T(native.ToPointer(), skipVTables);
        }

        internal static BleGattcAttrInfo16T __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcAttrInfo16T)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcAttrInfo16T __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcAttrInfo16T(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcAttrInfo16T(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcAttrInfo16T(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcAttrInfo16T()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcAttrInfo16T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcAttrInfo16T(global::NrfBleDriver.BleGattcAttrInfo16T __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcAttrInfo16T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcAttrInfo16T.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcAttrInfo16T.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>16-bit Attribute UUID.</summary>
        public global::NrfBleDriver.BleUuidT Uuid
        {
            get
            {
                return global::NrfBleDriver.BleUuidT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uuid));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uuid = *(global::NrfBleDriver.BleUuidT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Attribute Information for 128-bit Attribute UUID.</summary>
    public unsafe partial class BleGattcAttrInfo128T : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 18)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal global::NrfBleDriver.BleUuid128T.__Internal uuid;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_attr_info128_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcAttrInfo128T> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcAttrInfo128T>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcAttrInfo128T managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcAttrInfo128T managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcAttrInfo128T __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcAttrInfo128T(native.ToPointer(), skipVTables);
        }

        internal static BleGattcAttrInfo128T __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcAttrInfo128T)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcAttrInfo128T __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcAttrInfo128T(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcAttrInfo128T(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcAttrInfo128T(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcAttrInfo128T()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcAttrInfo128T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcAttrInfo128T(global::NrfBleDriver.BleGattcAttrInfo128T __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcAttrInfo128T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcAttrInfo128T.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcAttrInfo128T.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>128-bit Attribute UUID.</summary>
        public global::NrfBleDriver.BleUuid128T Uuid
        {
            get
            {
                return global::NrfBleDriver.BleUuid128T.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uuid));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uuid = *(global::NrfBleDriver.BleUuid128T.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtPrimSrvcDiscRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 10)]
        public partial struct __Internal
        {
            internal ushort count;
            internal fixed byte services[8];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_prim_srvc_disc_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtPrimSrvcDiscRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtPrimSrvcDiscRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtPrimSrvcDiscRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtPrimSrvcDiscRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtPrimSrvcDiscRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtPrimSrvcDiscRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtPrimSrvcDiscRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtPrimSrvcDiscRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtPrimSrvcDiscRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtPrimSrvcDiscRspT(global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Service count.</summary>
        public ushort Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        /// <summary>Service data.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public global::NrfBleDriver.BleGattcServiceT[] Services
        {
            get
            {
                global::NrfBleDriver.BleGattcServiceT[] __value = null;
                if (((__Internal*)__Instance)->services != null)
                {
                    __value = new global::NrfBleDriver.BleGattcServiceT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::NrfBleDriver.BleGattcServiceT.__GetOrCreateInstance((IntPtr)((global::NrfBleDriver.BleGattcServiceT.__Internal*)&(((__Internal*)__Instance)->services[i * sizeof(global::NrfBleDriver.BleGattcServiceT.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::NrfBleDriver.BleGattcServiceT.__Internal*) &((__Internal*)__Instance)->services[i * sizeof(global::NrfBleDriver.BleGattcServiceT.__Internal)] = *(global::NrfBleDriver.BleGattcServiceT.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtRelDiscRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal ushort count;
            internal fixed byte includes[10];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_rel_disc_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtRelDiscRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtRelDiscRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtRelDiscRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtRelDiscRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtRelDiscRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtRelDiscRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtRelDiscRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtRelDiscRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtRelDiscRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtRelDiscRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtRelDiscRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtRelDiscRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtRelDiscRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtRelDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtRelDiscRspT(global::NrfBleDriver.BleGattcEvtRelDiscRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtRelDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtRelDiscRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtRelDiscRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Include count.</summary>
        public ushort Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        /// <summary>Include data.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public global::NrfBleDriver.BleGattcIncludeT[] Includes
        {
            get
            {
                global::NrfBleDriver.BleGattcIncludeT[] __value = null;
                if (((__Internal*)__Instance)->includes != null)
                {
                    __value = new global::NrfBleDriver.BleGattcIncludeT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::NrfBleDriver.BleGattcIncludeT.__GetOrCreateInstance((IntPtr)((global::NrfBleDriver.BleGattcIncludeT.__Internal*)&(((__Internal*)__Instance)->includes[i * sizeof(global::NrfBleDriver.BleGattcIncludeT.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::NrfBleDriver.BleGattcIncludeT.__Internal*) &((__Internal*)__Instance)->includes[i * sizeof(global::NrfBleDriver.BleGattcIncludeT.__Internal)] = *(global::NrfBleDriver.BleGattcIncludeT.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtCharDiscRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal ushort count;
            internal fixed byte chars[10];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_char_disc_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtCharDiscRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtCharDiscRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtCharDiscRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtCharDiscRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtCharDiscRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtCharDiscRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtCharDiscRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtCharDiscRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtCharDiscRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtCharDiscRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtCharDiscRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtCharDiscRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtCharDiscRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtCharDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtCharDiscRspT(global::NrfBleDriver.BleGattcEvtCharDiscRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtCharDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtCharDiscRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtCharDiscRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Characteristic count.</summary>
        public ushort Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        /// <summary>Characteristic data.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public global::NrfBleDriver.BleGattcCharT[] Chars
        {
            get
            {
                global::NrfBleDriver.BleGattcCharT[] __value = null;
                if (((__Internal*)__Instance)->chars != null)
                {
                    __value = new global::NrfBleDriver.BleGattcCharT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::NrfBleDriver.BleGattcCharT.__GetOrCreateInstance((IntPtr)((global::NrfBleDriver.BleGattcCharT.__Internal*)&(((__Internal*)__Instance)->chars[i * sizeof(global::NrfBleDriver.BleGattcCharT.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::NrfBleDriver.BleGattcCharT.__Internal*) &((__Internal*)__Instance)->chars[i * sizeof(global::NrfBleDriver.BleGattcCharT.__Internal)] = *(global::NrfBleDriver.BleGattcCharT.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtDescDiscRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort count;
            internal fixed byte descs[6];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_desc_disc_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtDescDiscRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtDescDiscRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtDescDiscRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtDescDiscRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtDescDiscRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtDescDiscRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtDescDiscRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtDescDiscRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtDescDiscRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtDescDiscRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtDescDiscRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtDescDiscRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtDescDiscRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtDescDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtDescDiscRspT(global::NrfBleDriver.BleGattcEvtDescDiscRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtDescDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtDescDiscRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtDescDiscRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Descriptor count.</summary>
        public ushort Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        /// <summary>Descriptor data.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public global::NrfBleDriver.BleGattcDescT[] Descs
        {
            get
            {
                global::NrfBleDriver.BleGattcDescT[] __value = null;
                if (((__Internal*)__Instance)->descs != null)
                {
                    __value = new global::NrfBleDriver.BleGattcDescT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::NrfBleDriver.BleGattcDescT.__GetOrCreateInstance((IntPtr)((global::NrfBleDriver.BleGattcDescT.__Internal*)&(((__Internal*)__Instance)->descs[i * sizeof(global::NrfBleDriver.BleGattcDescT.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::NrfBleDriver.BleGattcDescT.__Internal*) &((__Internal*)__Instance)->descs[i * sizeof(global::NrfBleDriver.BleGattcDescT.__Internal)] = *(global::NrfBleDriver.BleGattcDescT.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtAttrInfoDiscRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 22)]
        public partial struct __Internal
        {
            internal ushort count;
            internal byte format;
            internal global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.Info.__Internal info;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_attr_info_disc_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Info
        {
            [StructLayout(LayoutKind.Explicit, Size = 18)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal fixed byte attr_info16[6];

                [FieldOffset(0)]
                internal fixed byte attr_info128[18];

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-info>@ble_gattc_evt_attr_info_disc_rsp_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Info.__Internal __instance;
            internal Info.__Internal __Instance => __instance;

            internal static Info __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Info(native.ToPointer(), skipVTables);
            }

            internal static Info __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Info(native, skipVTables);
            }

            private Info(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Info(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.Info.__Internal*) native;
            }

            public Info(global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.Info __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>Attribute information for 16-bit Attribute UUID.</summary>
            /// <remarks>
            /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
            /// <para>Seefor more information on how to use event structures with variable length array members.</para>
            /// </remarks>
            public global::NrfBleDriver.BleGattcAttrInfo16T[] AttrInfo16
            {
                get
                {
                    fixed (global::NrfBleDriver.BleGattcAttrInfo16T __arrPtr = __instance.attr_info16)
                    {
                        global::NrfBleDriver.BleGattcAttrInfo16T[] __value = null;
                        if (__arrPtr != null)
                        {
                            __value = new global::NrfBleDriver.BleGattcAttrInfo16T[1];
                            for (int i = 0; i < 1; i++)
                                __value[i] = global::NrfBleDriver.BleGattcAttrInfo16T.__GetOrCreateInstance((IntPtr)((global::NrfBleDriver.BleGattcAttrInfo16T.__Internal*)&(__arrPtr[i * sizeof(global::NrfBleDriver.BleGattcAttrInfo16T.__Internal)])), true, true);
                        }
                        return __value;
                    }
                }

                set
                {
                    fixed (global::NrfBleDriver.BleGattcAttrInfo16T __arrPtr = __instance.attr_info16)
                    {
                        if (value != null)
                        {
                            if (value.Length != 1)
                                throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                            for (int i = 0; i < 1; i++)
                                *(global::NrfBleDriver.BleGattcAttrInfo16T.__Internal*) &__arrPtr[i * sizeof(global::NrfBleDriver.BleGattcAttrInfo16T.__Internal)] = *(global::NrfBleDriver.BleGattcAttrInfo16T.__Internal*)value[i].__Instance;
                        }
                    }
                }
            }

            /// <summary>Attribute information for 128-bit Attribute UUID.</summary>
            /// <remarks>
            /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
            /// <para>Seefor more information on how to use event structures with variable length array members.</para>
            /// </remarks>
            public global::NrfBleDriver.BleGattcAttrInfo128T[] AttrInfo128
            {
                get
                {
                    fixed (global::NrfBleDriver.BleGattcAttrInfo128T __arrPtr = __instance.attr_info128)
                    {
                        global::NrfBleDriver.BleGattcAttrInfo128T[] __value = null;
                        if (__arrPtr != null)
                        {
                            __value = new global::NrfBleDriver.BleGattcAttrInfo128T[1];
                            for (int i = 0; i < 1; i++)
                                __value[i] = global::NrfBleDriver.BleGattcAttrInfo128T.__GetOrCreateInstance((IntPtr)((global::NrfBleDriver.BleGattcAttrInfo128T.__Internal*)&(__arrPtr[i * sizeof(global::NrfBleDriver.BleGattcAttrInfo128T.__Internal)])), true, true);
                        }
                        return __value;
                    }
                }

                set
                {
                    fixed (global::NrfBleDriver.BleGattcAttrInfo128T __arrPtr = __instance.attr_info128)
                    {
                        if (value != null)
                        {
                            if (value.Length != 1)
                                throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                            for (int i = 0; i < 1; i++)
                                *(global::NrfBleDriver.BleGattcAttrInfo128T.__Internal*) &__arrPtr[i * sizeof(global::NrfBleDriver.BleGattcAttrInfo128T.__Internal)] = *(global::NrfBleDriver.BleGattcAttrInfo128T.__Internal*)value[i].__Instance;
                        }
                    }
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtAttrInfoDiscRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtAttrInfoDiscRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtAttrInfoDiscRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtAttrInfoDiscRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtAttrInfoDiscRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtAttrInfoDiscRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtAttrInfoDiscRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtAttrInfoDiscRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtAttrInfoDiscRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtAttrInfoDiscRspT(global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute count.</summary>
        public ushort Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        /// <summary>Attribute information format, see</summary>
        public byte Format
        {
            get
            {
                return ((__Internal*)__Instance)->format;
            }

            set
            {
                ((__Internal*)__Instance)->format = value;
            }
        }

        /// <summary>Attribute information union.</summary>
        public global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.Info info
        {
            get
            {
                return global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.Info.__CreateInstance(((__Internal*)__Instance)->info);
            }

            set
            {
                ((__Internal*)__Instance)->info = value.__Instance;
            }
        }
    }

    /// <summary>GATT read by UUID handle value pair.</summary>
    public unsafe partial class BleGattcHandleValueT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal __IntPtr p_value;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_handle_value_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcHandleValueT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcHandleValueT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcHandleValueT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcHandleValueT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcHandleValueT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcHandleValueT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcHandleValueT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcHandleValueT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcHandleValueT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcHandleValueT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcHandleValueT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcHandleValueT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcHandleValueT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcHandleValueT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcHandleValueT(global::NrfBleDriver.BleGattcHandleValueT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcHandleValueT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcHandleValueT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcHandleValueT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute Handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Pointer to the Attribute Value, length is available in</summary>
        public byte* PValue
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_value;
            }

            set
            {
                ((__Internal*)__Instance)->p_value = (__IntPtr) value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtCharValByUuidReadRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 6)]
        public partial struct __Internal
        {
            internal ushort count;
            internal ushort value_len;
            internal fixed byte handle_value[1];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_char_val_by_uuid_read_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtCharValByUuidReadRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtCharValByUuidReadRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtCharValByUuidReadRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtCharValByUuidReadRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtCharValByUuidReadRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtCharValByUuidReadRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtCharValByUuidReadRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtCharValByUuidReadRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtCharValByUuidReadRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtCharValByUuidReadRspT(global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Handle-Value Pair Count.</summary>
        public ushort Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        /// <summary>Length of the value in Handle-Value(s) list.</summary>
        public ushort ValueLen
        {
            get
            {
                return ((__Internal*)__Instance)->value_len;
            }

            set
            {
                ((__Internal*)__Instance)->value_len = value;
            }
        }

        /// <summary>Handle-Value(s) list. To iterate through the list use</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public byte[] HandleValue
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->handle_value, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->handle_value[i] = value[i];
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtReadRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal ushort offset;
            internal ushort len;
            internal fixed byte data[1];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_read_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtReadRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtReadRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtReadRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtReadRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtReadRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtReadRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtReadRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtReadRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtReadRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtReadRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtReadRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtReadRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtReadRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtReadRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtReadRspT(global::NrfBleDriver.BleGattcEvtReadRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtReadRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtReadRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtReadRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute Handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Offset of the attribute data.</summary>
        public ushort Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }

        /// <summary>Attribute data length.</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        /// <summary>Attribute data.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public byte[] Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->data, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->data[i] = value[i];
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtCharValsReadRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal ushort len;
            internal fixed byte values[1];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_char_vals_read_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtCharValsReadRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtCharValsReadRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtCharValsReadRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtCharValsReadRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtCharValsReadRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtCharValsReadRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtCharValsReadRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtCharValsReadRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtCharValsReadRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtCharValsReadRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtCharValsReadRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtCharValsReadRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtCharValsReadRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtCharValsReadRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtCharValsReadRspT(global::NrfBleDriver.BleGattcEvtCharValsReadRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtCharValsReadRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtCharValsReadRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtCharValsReadRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Concatenated Attribute values length.</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        /// <summary>Attribute values.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public byte[] Values
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->values, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->values[i] = value[i];
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtWriteRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 10)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal byte write_op;
            internal ushort offset;
            internal ushort len;
            internal fixed byte data[1];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_write_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtWriteRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtWriteRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtWriteRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtWriteRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtWriteRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtWriteRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtWriteRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtWriteRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtWriteRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtWriteRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtWriteRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtWriteRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtWriteRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtWriteRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtWriteRspT(global::NrfBleDriver.BleGattcEvtWriteRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtWriteRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtWriteRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtWriteRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute Handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Type of write operation, see</summary>
        public byte WriteOp
        {
            get
            {
                return ((__Internal*)__Instance)->write_op;
            }

            set
            {
                ((__Internal*)__Instance)->write_op = value;
            }
        }

        /// <summary>Data offset.</summary>
        public ushort Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }

        /// <summary>Data length.</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        /// <summary>Data.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public byte[] Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->data, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->data[i] = value[i];
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtHvxT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal byte type;
            internal ushort len;
            internal fixed byte data[1];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_hvx_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtHvxT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtHvxT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtHvxT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtHvxT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtHvxT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtHvxT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtHvxT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtHvxT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtHvxT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtHvxT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtHvxT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtHvxT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtHvxT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtHvxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtHvxT(global::NrfBleDriver.BleGattcEvtHvxT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtHvxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtHvxT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtHvxT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Handle to which the HVx operation applies.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Indication or Notification, see</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Attribute data length.</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        /// <summary>Attribute data.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public byte[] Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->data, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->data[i] = value[i];
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtExchangeMtuRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal ushort server_rx_mtu;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_exchange_mtu_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtExchangeMtuRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtExchangeMtuRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtExchangeMtuRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtExchangeMtuRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtExchangeMtuRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtExchangeMtuRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtExchangeMtuRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtExchangeMtuRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtExchangeMtuRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtExchangeMtuRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtExchangeMtuRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtExchangeMtuRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtExchangeMtuRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtExchangeMtuRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtExchangeMtuRspT(global::NrfBleDriver.BleGattcEvtExchangeMtuRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtExchangeMtuRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtExchangeMtuRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtExchangeMtuRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Server RX MTU size.</summary>
        public ushort ServerRxMtu
        {
            get
            {
                return ((__Internal*)__Instance)->server_rx_mtu;
            }

            set
            {
                ((__Internal*)__Instance)->server_rx_mtu = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtTimeoutT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte src;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_timeout_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtTimeoutT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtTimeoutT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtTimeoutT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtTimeoutT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtTimeoutT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtTimeoutT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtTimeoutT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtTimeoutT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtTimeoutT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtTimeoutT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtTimeoutT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtTimeoutT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtTimeoutT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtTimeoutT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtTimeoutT(global::NrfBleDriver.BleGattcEvtTimeoutT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtTimeoutT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtTimeoutT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtTimeoutT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Timeout source, see</summary>
        public byte Src
        {
            get
            {
                return ((__Internal*)__Instance)->src;
            }

            set
            {
                ((__Internal*)__Instance)->src = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtWriteCmdTxCompleteT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte count;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_write_cmd_tx_complete_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtWriteCmdTxCompleteT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtWriteCmdTxCompleteT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtWriteCmdTxCompleteT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtWriteCmdTxCompleteT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtWriteCmdTxCompleteT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtWriteCmdTxCompleteT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtWriteCmdTxCompleteT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtWriteCmdTxCompleteT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtWriteCmdTxCompleteT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtWriteCmdTxCompleteT(global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Number of write without response transmissions completed.</summary>
        public byte Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }
    }

    /// <summary>GATTC event structure.</summary>
    public unsafe partial class BleGattcEvtT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal ushort gatt_status;
            internal ushort error_handle;
            internal global::NrfBleDriver.BleGattcEvtT.Params.__Internal @params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Params
        {
            [StructLayout(LayoutKind.Explicit, Size = 22)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT.__Internal prim_srvc_disc_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtRelDiscRspT.__Internal rel_disc_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtCharDiscRspT.__Internal char_disc_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtDescDiscRspT.__Internal desc_disc_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT.__Internal char_val_by_uuid_read_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtReadRspT.__Internal read_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtCharValsReadRspT.__Internal char_vals_read_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtWriteRspT.__Internal write_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtHvxT.__Internal hvx;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtExchangeMtuRspT.__Internal exchange_mtu_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtTimeoutT.__Internal timeout;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.__Internal attr_info_disc_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT.__Internal write_cmd_tx_complete;

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-params>@ble_gattc_evt_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Params.__Internal __instance;
            internal Params.__Internal __Instance => __instance;

            internal static Params __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Params(native.ToPointer(), skipVTables);
            }

            internal static Params __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Params(native, skipVTables);
            }

            private Params(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Params(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleGattcEvtT.Params.__Internal*) native;
            }

            public Params(global::NrfBleDriver.BleGattcEvtT.Params __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>Primary Service Discovery Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT PrimSrvcDiscRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT.__CreateInstance(__instance.prim_srvc_disc_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.prim_srvc_disc_rsp = *(global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Relationship Discovery Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtRelDiscRspT RelDiscRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtRelDiscRspT.__CreateInstance(__instance.rel_disc_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.rel_disc_rsp = *(global::NrfBleDriver.BleGattcEvtRelDiscRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Characteristic Discovery Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtCharDiscRspT CharDiscRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtCharDiscRspT.__CreateInstance(__instance.char_disc_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.char_disc_rsp = *(global::NrfBleDriver.BleGattcEvtCharDiscRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Descriptor Discovery Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtDescDiscRspT DescDiscRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtDescDiscRspT.__CreateInstance(__instance.desc_disc_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.desc_disc_rsp = *(global::NrfBleDriver.BleGattcEvtDescDiscRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Characteristic Value Read by UUID Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT CharValByUuidReadRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT.__CreateInstance(__instance.char_val_by_uuid_read_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.char_val_by_uuid_read_rsp = *(global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Read Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtReadRspT ReadRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtReadRspT.__CreateInstance(__instance.read_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.read_rsp = *(global::NrfBleDriver.BleGattcEvtReadRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Characteristic Values Read Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtCharValsReadRspT CharValsReadRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtCharValsReadRspT.__CreateInstance(__instance.char_vals_read_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.char_vals_read_rsp = *(global::NrfBleDriver.BleGattcEvtCharValsReadRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Write Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtWriteRspT WriteRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtWriteRspT.__CreateInstance(__instance.write_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.write_rsp = *(global::NrfBleDriver.BleGattcEvtWriteRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Handle Value Notification/Indication Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtHvxT Hvx
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtHvxT.__CreateInstance(__instance.hvx);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.hvx = *(global::NrfBleDriver.BleGattcEvtHvxT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Exchange MTU Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtExchangeMtuRspT ExchangeMtuRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtExchangeMtuRspT.__CreateInstance(__instance.exchange_mtu_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.exchange_mtu_rsp = *(global::NrfBleDriver.BleGattcEvtExchangeMtuRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Timeout Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtTimeoutT Timeout
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtTimeoutT.__CreateInstance(__instance.timeout);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.timeout = *(global::NrfBleDriver.BleGattcEvtTimeoutT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Attribute Information Discovery Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT AttrInfoDiscRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.__CreateInstance(__instance.attr_info_disc_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.attr_info_disc_rsp = *(global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Write without Response transmission complete Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT WriteCmdTxComplete
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT.__CreateInstance(__instance.write_cmd_tx_complete);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.write_cmd_tx_complete = *(global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtT(global::NrfBleDriver.BleGattcEvtT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle on which event occurred.</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>GATT status code for the operation, see</summary>
        public ushort GattStatus
        {
            get
            {
                return ((__Internal*)__Instance)->gatt_status;
            }

            set
            {
                ((__Internal*)__Instance)->gatt_status = value;
            }
        }

        /// <summary>In case of error: The handle causing the error. In all other cases</summary>
        public ushort ErrorHandle
        {
            get
            {
                return ((__Internal*)__Instance)->error_handle;
            }

            set
            {
                ((__Internal*)__Instance)->error_handle = value;
            }
        }

        /// <summary>Event Parameters.</summary>
        /// <remarks>Only valid if==</remarks>
        public global::NrfBleDriver.BleGattcEvtT.Params @params
        {
            get
            {
                return global::NrfBleDriver.BleGattcEvtT.Params.__CreateInstance(((__Internal*)__Instance)->@params);
            }

            set
            {
                ((__Internal*)__Instance)->@params = value.__Instance;
            }
        }
    }

    public unsafe partial class ble_gattc
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_primary_services_discover", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcPrimaryServicesDiscover(__IntPtr adapter, ushort conn_handle, ushort start_handle, __IntPtr p_srvc_uuid);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_relationships_discover", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcRelationshipsDiscover(__IntPtr adapter, ushort conn_handle, __IntPtr p_handle_range);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_characteristics_discover", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcCharacteristicsDiscover(__IntPtr adapter, ushort conn_handle, __IntPtr p_handle_range);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_descriptors_discover", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcDescriptorsDiscover(__IntPtr adapter, ushort conn_handle, __IntPtr p_handle_range);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_char_value_by_uuid_read", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcCharValueByUuidRead(__IntPtr adapter, ushort conn_handle, __IntPtr p_uuid, __IntPtr p_handle_range);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_read", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcRead(__IntPtr adapter, ushort conn_handle, ushort handle, ushort offset);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_char_values_read", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcCharValuesRead(__IntPtr adapter, ushort conn_handle, ushort* p_handles, ushort handle_count);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_write", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcWrite(__IntPtr adapter, ushort conn_handle, __IntPtr p_write_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_hv_confirm", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcHvConfirm(__IntPtr adapter, ushort conn_handle, ushort handle);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_attr_info_discover", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcAttrInfoDiscover(__IntPtr adapter, ushort conn_handle, __IntPtr p_handle_range);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_exchange_mtu_request", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcExchangeMtuRequest(__IntPtr adapter, ushort conn_handle, ushort client_rx_mtu);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "?sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter@@YAIPEAUble_gattc_evt_t@@PEAUble_gattc_handle_value_t@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcEvtCharValByUuidReadRspIter(__IntPtr p_gattc_evt, __IntPtr p_iter);
        }

        public static uint SdBleGattcPrimaryServicesDiscover(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort start_handle, global::NrfBleDriver.BleUuidT p_srvc_uuid)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg3 = p_srvc_uuid is null ? __IntPtr.Zero : p_srvc_uuid.__Instance;
            var __ret = __Internal.SdBleGattcPrimaryServicesDiscover(__arg0, conn_handle, start_handle, __arg3);
            return __ret;
        }

        public static uint SdBleGattcRelationshipsDiscover(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGattcHandleRangeT p_handle_range)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_handle_range is null ? __IntPtr.Zero : p_handle_range.__Instance;
            var __ret = __Internal.SdBleGattcRelationshipsDiscover(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGattcCharacteristicsDiscover(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGattcHandleRangeT p_handle_range)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_handle_range is null ? __IntPtr.Zero : p_handle_range.__Instance;
            var __ret = __Internal.SdBleGattcCharacteristicsDiscover(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGattcDescriptorsDiscover(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGattcHandleRangeT p_handle_range)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_handle_range is null ? __IntPtr.Zero : p_handle_range.__Instance;
            var __ret = __Internal.SdBleGattcDescriptorsDiscover(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGattcCharValueByUuidRead(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleUuidT p_uuid, global::NrfBleDriver.BleGattcHandleRangeT p_handle_range)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_uuid is null ? __IntPtr.Zero : p_uuid.__Instance;
            var __arg3 = p_handle_range is null ? __IntPtr.Zero : p_handle_range.__Instance;
            var __ret = __Internal.SdBleGattcCharValueByUuidRead(__arg0, conn_handle, __arg2, __arg3);
            return __ret;
        }

        public static uint SdBleGattcRead(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort handle, ushort offset)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGattcRead(__arg0, conn_handle, handle, offset);
            return __ret;
        }

        public static uint SdBleGattcCharValuesRead(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ref ushort p_handles, ushort handle_count)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (ushort* __p_handles2 = &p_handles)
            {
                var __arg2 = __p_handles2;
                var __ret = __Internal.SdBleGattcCharValuesRead(__arg0, conn_handle, __arg2, handle_count);
                return __ret;
            }
        }

        public static uint SdBleGattcWrite(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGattcWriteParamsT p_write_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_write_params is null ? __IntPtr.Zero : p_write_params.__Instance;
            var __ret = __Internal.SdBleGattcWrite(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGattcHvConfirm(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort handle)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGattcHvConfirm(__arg0, conn_handle, handle);
            return __ret;
        }

        public static uint SdBleGattcAttrInfoDiscover(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGattcHandleRangeT p_handle_range)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_handle_range is null ? __IntPtr.Zero : p_handle_range.__Instance;
            var __ret = __Internal.SdBleGattcAttrInfoDiscover(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGattcExchangeMtuRequest(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort client_rx_mtu)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGattcExchangeMtuRequest(__arg0, conn_handle, client_rx_mtu);
            return __ret;
        }

        /// <summary>Iterate through Handle-Value(s) list inevent.</summary>
        /// <param name="p_gattc_evt">Pointer to event buffer containingevent.</param>
        /// <param name="p_iter">
        /// <para>Iterator, points tostructure that will be filled in with</para>
        /// <para>the next Handle-Value pair in each iteration. If the function returns other than</para>
        /// <para>it will not be changed.</para>
        /// <para>- To start iteration, initialize the structure to zero.</para>
        /// <para>- To continue, pass the value from previous iteration.</para>
        /// </param>
        /// <remarks>
        /// <para>If the buffer contains different event, behavior is undefined.</para>
        /// <para>::NRF_SUCCESS Successfully retrieved the next Handle-Value pair.</para>
        /// <para>::NRF_ERROR_NOT_FOUND No more Handle-Value pairs available in the list.</para>
        /// </remarks>
        public static uint SdBleGattcEvtCharValByUuidReadRspIter(global::NrfBleDriver.BleGattcEvtT p_gattc_evt, global::NrfBleDriver.BleGattcHandleValueT p_iter)
        {
            var __arg0 = p_gattc_evt is null ? __IntPtr.Zero : p_gattc_evt.__Instance;
            var __arg1 = p_iter is null ? __IntPtr.Zero : p_iter.__Instance;
            var __ret = __Internal.SdBleGattcEvtCharValByUuidReadRspIter(__arg0, __arg1);
            return __ret;
        }
    }

    /// <summary>GATTS API SVC numbers.</summary>
    public enum BLE_GATTS_SVCS
    {
        /// <summary>Add a service.</summary>
        SD_BLE_GATTS_SERVICE_ADD = 160,
        /// <summary>Add an included service.</summary>
        SD_BLE_GATTS_INCLUDE_ADD = 161,
        /// <summary>Add a characteristic.</summary>
        SD_BLE_GATTS_CHARACTERISTIC_ADD = 162,
        /// <summary>Add a generic attribute.</summary>
        SD_BLE_GATTS_DESCRIPTOR_ADD = 163,
        /// <summary>Set an attribute value.</summary>
        SD_BLE_GATTS_VALUE_SET = 164,
        /// <summary>Get an attribute value.</summary>
        SD_BLE_GATTS_VALUE_GET = 165,
        /// <summary>Handle Value Notification or Indication.</summary>
        SD_BLE_GATTS_HVX = 166,
        /// <summary>Perform a Service Changed Indication to one or more peers.</summary>
        SD_BLE_GATTS_SERVICE_CHANGED = 167,
        /// <summary>Reply to an authorization request for a read or write operation on one or more attributes.</summary>
        SD_BLE_GATTS_RW_AUTHORIZE_REPLY = 168,
        /// <summary>Set the persistent system attributes for a connection.</summary>
        SD_BLE_GATTS_SYS_ATTR_SET = 169,
        /// <summary>Retrieve the persistent system attributes.</summary>
        SD_BLE_GATTS_SYS_ATTR_GET = 170,
        /// <summary>Retrieve the first valid user handle.</summary>
        SD_BLE_GATTS_INITIAL_USER_HANDLE_GET = 171,
        /// <summary>Retrieve the UUID and/or metadata of an attribute.</summary>
        SD_BLE_GATTS_ATTR_GET = 172,
        /// <summary>Reply to Exchange MTU Request.</summary>
        SD_BLE_GATTS_EXCHANGE_MTU_REPLY = 173
    }

    /// <summary>GATT Server Event IDs.</summary>
    public enum BLE_GATTS_EVTS
    {
        /// <summary>Write operation performed.See</summary>
        BLE_GATTS_EVT_WRITE = 80,
        /// <summary>Read/Write Authorization request.Reply withSee</summary>
        BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST = 81,
        /// <summary>A persistent system attribute access is pending.Respond withSee</summary>
        BLE_GATTS_EVT_SYS_ATTR_MISSING = 82,
        /// <summary>Handle Value Confirmation.See</summary>
        BLE_GATTS_EVT_HVC = 83,
        /// <summary>Service Changed Confirmation.No additional event structure applies.</summary>
        BLE_GATTS_EVT_SC_CONFIRM = 84,
        /// <summary>Exchange MTU Request.Reply withSee</summary>
        BLE_GATTS_EVT_EXCHANGE_MTU_REQUEST = 85,
        /// <summary>Peer failed to respond to an ATT request in time.See</summary>
        BLE_GATTS_EVT_TIMEOUT = 86,
        /// <summary>Handle Value Notification transmission complete.See</summary>
        BLE_GATTS_EVT_HVN_TX_COMPLETE = 87
    }

    /// <summary>GATTS Configuration IDs.</summary>
    /// <remarks>IDs that uniquely identify a GATTS configuration.</remarks>
    public enum BLE_GATTS_CFGS
    {
        /// <summary>Service changed configuration.</summary>
        BLE_GATTS_CFG_SERVICE_CHANGED = 160,
        /// <summary>Attribute table size configuration.</summary>
        BLE_GATTS_CFG_ATTR_TAB_SIZE = 161
    }

    /// <summary>BLE GATTS connection configuration parameters, set with</summary>
    /// <summary>Attribute metadata.</summary>
    /// <summary>GATT Attribute.</summary>
    /// <summary>GATT Attribute Value.</summary>
    /// <summary>GATT Characteristic Presentation Format.</summary>
    /// <summary>GATT Characteristic metadata.</summary>
    /// <summary>GATT Characteristic Definition Handles.</summary>
    /// <summary>GATT HVx parameters.</summary>
    /// <summary>GATT Authorization parameters.</summary>
    /// <summary>GATT Read or Write Authorize Reply parameters.</summary>
    /// <summary>Service Changed Inclusion configuration parameters, set with</summary>
    /// <summary>Attribute table size configuration parameters, set with</summary>
    /// <remarks>
    /// <para>::NRF_ERROR_INVALID_LENGTH One or more of the following is true:</para>
    /// <para>- The specified Attribute Table size is too small.</para>
    /// <para>The minimum acceptable size is defined by- The specified Attribute Table size is not a multiple of 4.</para>
    /// </remarks>
    /// <summary>Config structure for GATTS configurations.</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event substructure for authorized read requests, see</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>GATTS event structure.</summary>
    /// <summary>BLE GATTS connection configuration parameters, set with</summary>
    public unsafe partial class BleGattsConnCfgT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte hvn_tx_queue_size;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_conn_cfg_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsConnCfgT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsConnCfgT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsConnCfgT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsConnCfgT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsConnCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsConnCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsConnCfgT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsConnCfgT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsConnCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsConnCfgT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsConnCfgT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsConnCfgT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsConnCfgT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsConnCfgT(global::NrfBleDriver.BleGattsConnCfgT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsConnCfgT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsConnCfgT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Minimum guaranteed number of Handle Value Notifications that can be queued for transmission.</para>
        /// <para>The default value is</para>
        /// </summary>
        public byte HvnTxQueueSize
        {
            get
            {
                return ((__Internal*)__Instance)->hvn_tx_queue_size;
            }

            set
            {
                ((__Internal*)__Instance)->hvn_tx_queue_size = value;
            }
        }
    }

    /// <summary>Attribute metadata.</summary>
    public unsafe partial class BleGattsAttrMdT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 3)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapConnSecModeT.__Internal read_perm;

            [FieldOffset(1)]
            internal global::NrfBleDriver.BleGapConnSecModeT.__Internal write_perm;

            [FieldOffset(2)]
            internal byte vlen;

            [FieldOffset(2)]
            internal byte vloc;

            [FieldOffset(2)]
            internal byte rd_auth;

            [FieldOffset(2)]
            internal byte wr_auth;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_attr_md_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsAttrMdT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsAttrMdT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsAttrMdT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsAttrMdT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsAttrMdT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsAttrMdT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsAttrMdT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsAttrMdT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsAttrMdT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsAttrMdT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsAttrMdT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsAttrMdT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsAttrMdT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsAttrMdT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsAttrMdT(global::NrfBleDriver.BleGattsAttrMdT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsAttrMdT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsAttrMdT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsAttrMdT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Read permissions.</summary>
        public global::NrfBleDriver.BleGapConnSecModeT ReadPerm
        {
            get
            {
                return global::NrfBleDriver.BleGapConnSecModeT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->read_perm));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->read_perm = *(global::NrfBleDriver.BleGapConnSecModeT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Write permissions.</summary>
        public global::NrfBleDriver.BleGapConnSecModeT WritePerm
        {
            get
            {
                return global::NrfBleDriver.BleGapConnSecModeT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->write_perm));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->write_perm = *(global::NrfBleDriver.BleGapConnSecModeT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Variable length attribute.</summary>
        public byte Vlen
        {
            get
            {
                return ((__Internal*)__Instance)->vlen;
            }

            set
            {
                ((__Internal*)__Instance)->vlen = value;
            }
        }

        /// <summary>Value location, see</summary>
        public byte Vloc
        {
            get
            {
                return ((__Internal*)__Instance)->vloc;
            }

            set
            {
                ((__Internal*)__Instance)->vloc = value;
            }
        }

        /// <summary>Read authorization and value will be requested from the application on every read operation.</summary>
        public byte RdAuth
        {
            get
            {
                return ((__Internal*)__Instance)->rd_auth;
            }

            set
            {
                ((__Internal*)__Instance)->rd_auth = value;
            }
        }

        /// <summary>Write authorization will be requested from the application on every Write Request operation (but not Write Command).</summary>
        public byte WrAuth
        {
            get
            {
                return ((__Internal*)__Instance)->wr_auth;
            }

            set
            {
                ((__Internal*)__Instance)->wr_auth = value;
            }
        }
    }

    /// <summary>GATT Attribute.</summary>
    public unsafe partial class BleGattsAttrT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr p_uuid;
            internal __IntPtr p_attr_md;
            internal ushort init_len;
            internal ushort init_offs;
            internal ushort max_len;
            internal __IntPtr p_value;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_attr_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsAttrT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsAttrT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsAttrT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsAttrT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsAttrT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsAttrT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsAttrT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsAttrT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsAttrT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsAttrT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsAttrT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsAttrT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsAttrT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsAttrT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsAttrT(global::NrfBleDriver.BleGattsAttrT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsAttrT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsAttrT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsAttrT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Pointer to the attribute UUID.</summary>
        public global::NrfBleDriver.BleUuidT PUuid
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleUuidT.__GetOrCreateInstance(((__Internal*)__Instance)->p_uuid, false);
                return __result0;
            }
        }

        /// <summary>Pointer to the attribute metadata structure.</summary>
        public global::NrfBleDriver.BleGattsAttrMdT PAttrMd
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGattsAttrMdT.__GetOrCreateInstance(((__Internal*)__Instance)->p_attr_md, false);
                return __result0;
            }
        }

        /// <summary>Initial attribute value length in bytes.</summary>
        public ushort InitLen
        {
            get
            {
                return ((__Internal*)__Instance)->init_len;
            }

            set
            {
                ((__Internal*)__Instance)->init_len = value;
            }
        }

        /// <summary>Initial attribute value offset in bytes. If different from zero, the first init_offs bytes of the attribute value will be left uninitialized.</summary>
        public ushort InitOffs
        {
            get
            {
                return ((__Internal*)__Instance)->init_offs;
            }

            set
            {
                ((__Internal*)__Instance)->init_offs = value;
            }
        }

        /// <summary>Maximum attribute value length in bytes, seefor maximum values.</summary>
        public ushort MaxLen
        {
            get
            {
                return ((__Internal*)__Instance)->max_len;
            }

            set
            {
                ((__Internal*)__Instance)->max_len = value;
            }
        }

        /// <summary>
        /// <para>Pointer to the attribute data. Please note that if thevalue location is selected in the attribute metadata, this will have to point to a buffer</para>
        /// <para>that remains valid through the lifetime of the attribute. This excludes usage of automatic variables that may go out of scope or any other temporary location.</para>
        /// <para>The stack may access that memory directly without the application's knowledge. For writable characteristics, this value must not be a location in flash memory.</para>
        /// </summary>
        public byte* PValue
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_value;
            }

            set
            {
                ((__Internal*)__Instance)->p_value = (__IntPtr) value;
            }
        }
    }

    /// <summary>GATT Attribute Value.</summary>
    public unsafe partial class BleGattsValueT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal ushort len;
            internal ushort offset;
            internal __IntPtr p_value;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_value_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsValueT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsValueT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsValueT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsValueT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsValueT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsValueT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsValueT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsValueT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsValueT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsValueT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsValueT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsValueT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsValueT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsValueT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsValueT(global::NrfBleDriver.BleGattsValueT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsValueT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsValueT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsValueT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Length in bytes to be written or read. Length in bytes written or read after successful return.</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        /// <summary>Attribute value offset.</summary>
        public ushort Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }

        /// <summary>
        /// <para>Pointer to where value is stored or will be stored.</para>
        /// <para>If value is stored in user memory, only the attribute length is updated when p_value == NULL.</para>
        /// <para>Set to NULL when reading to obtain the complete length of the attribute value</para>
        /// </summary>
        public byte* PValue
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_value;
            }

            set
            {
                ((__Internal*)__Instance)->p_value = (__IntPtr) value;
            }
        }
    }

    /// <summary>GATT Characteristic Presentation Format.</summary>
    public unsafe partial class BleGattsCharPfT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal byte format;
            internal sbyte exponent;
            internal ushort unit;
            internal byte name_space;
            internal ushort desc;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_char_pf_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsCharPfT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsCharPfT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsCharPfT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsCharPfT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsCharPfT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsCharPfT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsCharPfT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsCharPfT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsCharPfT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsCharPfT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsCharPfT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsCharPfT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsCharPfT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsCharPfT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsCharPfT(global::NrfBleDriver.BleGattsCharPfT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsCharPfT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsCharPfT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsCharPfT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Format of the value, see</summary>
        public byte Format
        {
            get
            {
                return ((__Internal*)__Instance)->format;
            }

            set
            {
                ((__Internal*)__Instance)->format = value;
            }
        }

        /// <summary>Exponent for integer data types.</summary>
        public sbyte Exponent
        {
            get
            {
                return ((__Internal*)__Instance)->exponent;
            }

            set
            {
                ((__Internal*)__Instance)->exponent = value;
            }
        }

        /// <summary>Unit from Bluetooth Assigned Numbers.</summary>
        public ushort Unit
        {
            get
            {
                return ((__Internal*)__Instance)->unit;
            }

            set
            {
                ((__Internal*)__Instance)->unit = value;
            }
        }

        /// <summary>Namespace from Bluetooth Assigned Numbers, see</summary>
        public byte NameSpace
        {
            get
            {
                return ((__Internal*)__Instance)->name_space;
            }

            set
            {
                ((__Internal*)__Instance)->name_space = value;
            }
        }

        /// <summary>Namespace description from Bluetooth Assigned Numbers, see</summary>
        public ushort Desc
        {
            get
            {
                return ((__Internal*)__Instance)->desc;
            }

            set
            {
                ((__Internal*)__Instance)->desc = value;
            }
        }
    }

    /// <summary>GATT Characteristic metadata.</summary>
    public unsafe partial class BleGattsCharMdT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGattCharPropsT.__Internal char_props;
            internal global::NrfBleDriver.BleGattCharExtPropsT.__Internal char_ext_props;
            internal __IntPtr p_char_user_desc;
            internal ushort char_user_desc_max_size;
            internal ushort char_user_desc_size;
            internal __IntPtr p_char_pf;
            internal __IntPtr p_user_desc_md;
            internal __IntPtr p_cccd_md;
            internal __IntPtr p_sccd_md;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_char_md_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsCharMdT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsCharMdT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsCharMdT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsCharMdT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsCharMdT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsCharMdT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsCharMdT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsCharMdT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsCharMdT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsCharMdT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsCharMdT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsCharMdT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsCharMdT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsCharMdT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsCharMdT(global::NrfBleDriver.BleGattsCharMdT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsCharMdT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsCharMdT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsCharMdT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Characteristic Properties.</summary>
        public global::NrfBleDriver.BleGattCharPropsT CharProps
        {
            get
            {
                return global::NrfBleDriver.BleGattCharPropsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->char_props));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->char_props = *(global::NrfBleDriver.BleGattCharPropsT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Characteristic Extended Properties.</summary>
        public global::NrfBleDriver.BleGattCharExtPropsT CharExtProps
        {
            get
            {
                return global::NrfBleDriver.BleGattCharExtPropsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->char_ext_props));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->char_ext_props = *(global::NrfBleDriver.BleGattCharExtPropsT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Pointer to a UTF-8 encoded string (non-NULL terminated), NULL if the descriptor is not required.</summary>
        public byte* PCharUserDesc
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_char_user_desc;
            }
        }

        /// <summary>The maximum size in bytes of the user description descriptor.</summary>
        public ushort CharUserDescMaxSize
        {
            get
            {
                return ((__Internal*)__Instance)->char_user_desc_max_size;
            }

            set
            {
                ((__Internal*)__Instance)->char_user_desc_max_size = value;
            }
        }

        /// <summary>The size of the user description, must be smaller or equal to char_user_desc_max_size.</summary>
        public ushort CharUserDescSize
        {
            get
            {
                return ((__Internal*)__Instance)->char_user_desc_size;
            }

            set
            {
                ((__Internal*)__Instance)->char_user_desc_size = value;
            }
        }

        /// <summary>Pointer to a presentation format structure or NULL if the CPF descriptor is not required.</summary>
        public global::NrfBleDriver.BleGattsCharPfT PCharPf
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGattsCharPfT.__GetOrCreateInstance(((__Internal*)__Instance)->p_char_pf, false);
                return __result0;
            }
        }

        /// <summary>Attribute metadata for the User Description descriptor, or NULL for default values.</summary>
        public global::NrfBleDriver.BleGattsAttrMdT PUserDescMd
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGattsAttrMdT.__GetOrCreateInstance(((__Internal*)__Instance)->p_user_desc_md, false);
                return __result0;
            }
        }

        /// <summary>Attribute metadata for the Client Characteristic Configuration Descriptor, or NULL for default values.</summary>
        public global::NrfBleDriver.BleGattsAttrMdT PCccdMd
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGattsAttrMdT.__GetOrCreateInstance(((__Internal*)__Instance)->p_cccd_md, false);
                return __result0;
            }
        }

        /// <summary>Attribute metadata for the Server Characteristic Configuration Descriptor, or NULL for default values.</summary>
        public global::NrfBleDriver.BleGattsAttrMdT PSccdMd
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGattsAttrMdT.__GetOrCreateInstance(((__Internal*)__Instance)->p_sccd_md, false);
                return __result0;
            }
        }
    }

    /// <summary>GATT Characteristic Definition Handles.</summary>
    public unsafe partial class BleGattsCharHandlesT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort value_handle;
            internal ushort user_desc_handle;
            internal ushort cccd_handle;
            internal ushort sccd_handle;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_char_handles_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsCharHandlesT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsCharHandlesT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsCharHandlesT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsCharHandlesT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsCharHandlesT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsCharHandlesT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsCharHandlesT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsCharHandlesT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsCharHandlesT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsCharHandlesT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsCharHandlesT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsCharHandlesT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsCharHandlesT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsCharHandlesT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsCharHandlesT(global::NrfBleDriver.BleGattsCharHandlesT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsCharHandlesT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsCharHandlesT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsCharHandlesT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Handle to the characteristic value.</summary>
        public ushort ValueHandle
        {
            get
            {
                return ((__Internal*)__Instance)->value_handle;
            }

            set
            {
                ((__Internal*)__Instance)->value_handle = value;
            }
        }

        /// <summary>Handle to the User Description descriptor, orif not present.</summary>
        public ushort UserDescHandle
        {
            get
            {
                return ((__Internal*)__Instance)->user_desc_handle;
            }

            set
            {
                ((__Internal*)__Instance)->user_desc_handle = value;
            }
        }

        /// <summary>Handle to the Client Characteristic Configuration Descriptor, orif not present.</summary>
        public ushort CccdHandle
        {
            get
            {
                return ((__Internal*)__Instance)->cccd_handle;
            }

            set
            {
                ((__Internal*)__Instance)->cccd_handle = value;
            }
        }

        /// <summary>Handle to the Server Characteristic Configuration Descriptor, orif not present.</summary>
        public ushort SccdHandle
        {
            get
            {
                return ((__Internal*)__Instance)->sccd_handle;
            }

            set
            {
                ((__Internal*)__Instance)->sccd_handle = value;
            }
        }
    }

    /// <summary>GATT HVx parameters.</summary>
    public unsafe partial class BleGattsHvxParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal byte type;
            internal ushort offset;
            internal __IntPtr p_len;
            internal __IntPtr p_data;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_hvx_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsHvxParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsHvxParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsHvxParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsHvxParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsHvxParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsHvxParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsHvxParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsHvxParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsHvxParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsHvxParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsHvxParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsHvxParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsHvxParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsHvxParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsHvxParamsT(global::NrfBleDriver.BleGattsHvxParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsHvxParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsHvxParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsHvxParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Characteristic Value Handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Indication or Notification, see</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Offset within the attribute value.</summary>
        public ushort Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }

        /// <summary>Length in bytes to be written, length in bytes written after successful return.</summary>
        public ushort* PLen
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->p_len;
            }

            set
            {
                ((__Internal*)__Instance)->p_len = (__IntPtr) value;
            }
        }

        /// <summary>Actual data content, use NULL to use the current attribute value.</summary>
        public byte* PData
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_data;
            }
        }
    }

    /// <summary>GATT Authorization parameters.</summary>
    public unsafe partial class BleGattsAuthorizeParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal ushort gatt_status;
            internal byte update;
            internal ushort offset;
            internal ushort len;
            internal __IntPtr p_data;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_authorize_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsAuthorizeParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsAuthorizeParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsAuthorizeParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsAuthorizeParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsAuthorizeParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsAuthorizeParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsAuthorizeParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsAuthorizeParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsAuthorizeParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsAuthorizeParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsAuthorizeParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsAuthorizeParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsAuthorizeParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsAuthorizeParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsAuthorizeParamsT(global::NrfBleDriver.BleGattsAuthorizeParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsAuthorizeParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsAuthorizeParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsAuthorizeParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>GATT status code for the operation, see</summary>
        public ushort GattStatus
        {
            get
            {
                return ((__Internal*)__Instance)->gatt_status;
            }

            set
            {
                ((__Internal*)__Instance)->gatt_status = value;
            }
        }

        /// <summary>
        /// <para>If set, data supplied in p_data will be used to update the attribute value.</para>
        /// <para>Please note that foroperations this bit must always be set,</para>
        /// <para>as the data to be written needs to be stored and later provided by the application.</para>
        /// </summary>
        public byte Update
        {
            get
            {
                return ((__Internal*)__Instance)->update;
            }

            set
            {
                ((__Internal*)__Instance)->update = value;
            }
        }

        /// <summary>Offset of the attribute value being updated.</summary>
        public ushort Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }

        /// <summary>Length in bytes of the value in p_data pointer, see</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        /// <summary>Pointer to new value used to update the attribute value.</summary>
        public byte* PData
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_data;
            }
        }
    }

    /// <summary>GATT Read or Write Authorize Reply parameters.</summary>
    public unsafe partial class BleGattsRwAuthorizeReplyParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal byte type;
            internal global::NrfBleDriver.BleGattsRwAuthorizeReplyParamsT.Params.__Internal @params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_rw_authorize_reply_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Params
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattsAuthorizeParamsT.__Internal read;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattsAuthorizeParamsT.__Internal write;

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-params>@ble_gatts_rw_authorize_reply_params_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Params.__Internal __instance;
            internal Params.__Internal __Instance => __instance;

            internal static Params __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Params(native.ToPointer(), skipVTables);
            }

            internal static Params __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Params(native, skipVTables);
            }

            private Params(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Params(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleGattsRwAuthorizeReplyParamsT.Params.__Internal*) native;
            }

            public Params(global::NrfBleDriver.BleGattsRwAuthorizeReplyParamsT.Params __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>Read authorization parameters.</summary>
            public global::NrfBleDriver.BleGattsAuthorizeParamsT Read
            {
                get
                {
                    return global::NrfBleDriver.BleGattsAuthorizeParamsT.__CreateInstance(__instance.read);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.read = *(global::NrfBleDriver.BleGattsAuthorizeParamsT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Write authorization parameters.</summary>
            public global::NrfBleDriver.BleGattsAuthorizeParamsT Write
            {
                get
                {
                    return global::NrfBleDriver.BleGattsAuthorizeParamsT.__CreateInstance(__instance.write);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.write = *(global::NrfBleDriver.BleGattsAuthorizeParamsT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsRwAuthorizeReplyParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsRwAuthorizeReplyParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsRwAuthorizeReplyParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsRwAuthorizeReplyParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsRwAuthorizeReplyParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsRwAuthorizeReplyParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsRwAuthorizeReplyParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsRwAuthorizeReplyParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsRwAuthorizeReplyParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsRwAuthorizeReplyParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsRwAuthorizeReplyParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsRwAuthorizeReplyParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsRwAuthorizeReplyParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsRwAuthorizeReplyParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsRwAuthorizeReplyParamsT(global::NrfBleDriver.BleGattsRwAuthorizeReplyParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsRwAuthorizeReplyParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsRwAuthorizeReplyParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsRwAuthorizeReplyParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Type of authorize operation, see</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Reply Parameters.</summary>
        public global::NrfBleDriver.BleGattsRwAuthorizeReplyParamsT.Params @params
        {
            get
            {
                return global::NrfBleDriver.BleGattsRwAuthorizeReplyParamsT.Params.__CreateInstance(((__Internal*)__Instance)->@params);
            }

            set
            {
                ((__Internal*)__Instance)->@params = value.__Instance;
            }
        }
    }

    /// <summary>Service Changed Inclusion configuration parameters, set with</summary>
    public unsafe partial class BleGattsCfgServiceChangedT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte service_changed;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_cfg_service_changed_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsCfgServiceChangedT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsCfgServiceChangedT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsCfgServiceChangedT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsCfgServiceChangedT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsCfgServiceChangedT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsCfgServiceChangedT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsCfgServiceChangedT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsCfgServiceChangedT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsCfgServiceChangedT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsCfgServiceChangedT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsCfgServiceChangedT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsCfgServiceChangedT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsCfgServiceChangedT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsCfgServiceChangedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsCfgServiceChangedT(global::NrfBleDriver.BleGattsCfgServiceChangedT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsCfgServiceChangedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsCfgServiceChangedT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsCfgServiceChangedT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>If 1, include the Service Changed characteristic in the Attribute Table. Default is</summary>
        public byte ServiceChanged
        {
            get
            {
                return ((__Internal*)__Instance)->service_changed;
            }

            set
            {
                ((__Internal*)__Instance)->service_changed = value;
            }
        }
    }

    /// <summary>Attribute table size configuration parameters, set with</summary>
    /// <remarks>
    /// <para>::NRF_ERROR_INVALID_LENGTH One or more of the following is true:</para>
    /// <para>- The specified Attribute Table size is too small.</para>
    /// <para>The minimum acceptable size is defined by- The specified Attribute Table size is not a multiple of 4.</para>
    /// </remarks>
    public unsafe partial class BleGattsCfgAttrTabSizeT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal uint attr_tab_size;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_cfg_attr_tab_size_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsCfgAttrTabSizeT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsCfgAttrTabSizeT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsCfgAttrTabSizeT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsCfgAttrTabSizeT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsCfgAttrTabSizeT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsCfgAttrTabSizeT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsCfgAttrTabSizeT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsCfgAttrTabSizeT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsCfgAttrTabSizeT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsCfgAttrTabSizeT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsCfgAttrTabSizeT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsCfgAttrTabSizeT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsCfgAttrTabSizeT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsCfgAttrTabSizeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsCfgAttrTabSizeT(global::NrfBleDriver.BleGattsCfgAttrTabSizeT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsCfgAttrTabSizeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsCfgAttrTabSizeT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsCfgAttrTabSizeT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute table size. Default isminimum is</summary>
        public uint AttrTabSize
        {
            get
            {
                return ((__Internal*)__Instance)->attr_tab_size;
            }

            set
            {
                ((__Internal*)__Instance)->attr_tab_size = value;
            }
        }
    }

    /// <summary>Config structure for GATTS configurations.</summary>
    public unsafe partial struct BleGattsCfgT
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGattsCfgServiceChangedT.__Internal service_changed;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGattsCfgAttrTabSizeT.__Internal attr_tab_size;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_cfg_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        private BleGattsCfgT.__Internal __instance;
        internal BleGattsCfgT.__Internal __Instance => __instance;

        internal static BleGattsCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsCfgT(native, skipVTables);
        }

        private BleGattsCfgT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private BleGattsCfgT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NrfBleDriver.BleGattsCfgT.__Internal*) native;
        }

        public BleGattsCfgT(global::NrfBleDriver.BleGattsCfgT __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>Include service changed characteristic, cfg_id is</summary>
        public global::NrfBleDriver.BleGattsCfgServiceChangedT ServiceChanged
        {
            get
            {
                return global::NrfBleDriver.BleGattsCfgServiceChangedT.__CreateInstance(__instance.service_changed);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.service_changed = *(global::NrfBleDriver.BleGattsCfgServiceChangedT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Attribute table size, cfg_id is</summary>
        public global::NrfBleDriver.BleGattsCfgAttrTabSizeT AttrTabSize
        {
            get
            {
                return global::NrfBleDriver.BleGattsCfgAttrTabSizeT.__CreateInstance(__instance.attr_tab_size);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.attr_tab_size = *(global::NrfBleDriver.BleGattsCfgAttrTabSizeT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattsEvtWriteT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 14)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal global::NrfBleDriver.BleUuidT.__Internal uuid;
            internal byte op;
            internal byte auth_required;
            internal ushort offset;
            internal ushort len;
            internal fixed byte data[1];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_evt_write_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtWriteT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtWriteT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsEvtWriteT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsEvtWriteT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsEvtWriteT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsEvtWriteT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsEvtWriteT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsEvtWriteT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsEvtWriteT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsEvtWriteT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsEvtWriteT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsEvtWriteT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsEvtWriteT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtWriteT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsEvtWriteT(global::NrfBleDriver.BleGattsEvtWriteT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtWriteT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsEvtWriteT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsEvtWriteT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute Handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Attribute UUID.</summary>
        public global::NrfBleDriver.BleUuidT Uuid
        {
            get
            {
                return global::NrfBleDriver.BleUuidT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uuid));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uuid = *(global::NrfBleDriver.BleUuidT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Type of write operation, see</summary>
        public byte Op
        {
            get
            {
                return ((__Internal*)__Instance)->op;
            }

            set
            {
                ((__Internal*)__Instance)->op = value;
            }
        }

        /// <summary>Writing operation deferred due to authorization requirement. Application may useto finalize the writing operation.</summary>
        public byte AuthRequired
        {
            get
            {
                return ((__Internal*)__Instance)->auth_required;
            }

            set
            {
                ((__Internal*)__Instance)->auth_required = value;
            }
        }

        /// <summary>Offset for the write operation.</summary>
        public ushort Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }

        /// <summary>Length of the received data.</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        /// <summary>Received data.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public byte[] Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->data, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->data[i] = value[i];
                }
            }
        }
    }

    /// <summary>Event substructure for authorized read requests, see</summary>
    public unsafe partial class BleGattsEvtReadT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal global::NrfBleDriver.BleUuidT.__Internal uuid;
            internal ushort offset;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_evt_read_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtReadT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtReadT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsEvtReadT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsEvtReadT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsEvtReadT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsEvtReadT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsEvtReadT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsEvtReadT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsEvtReadT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsEvtReadT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsEvtReadT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsEvtReadT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsEvtReadT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtReadT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsEvtReadT(global::NrfBleDriver.BleGattsEvtReadT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtReadT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsEvtReadT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsEvtReadT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute Handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Attribute UUID.</summary>
        public global::NrfBleDriver.BleUuidT Uuid
        {
            get
            {
                return global::NrfBleDriver.BleUuidT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uuid));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uuid = *(global::NrfBleDriver.BleUuidT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Offset for the read operation.</summary>
        public ushort Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattsEvtRwAuthorizeRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal byte type;
            internal global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT.Request.__Internal request;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_evt_rw_authorize_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Request
        {
            [StructLayout(LayoutKind.Explicit, Size = 14)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattsEvtReadT.__Internal read;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattsEvtWriteT.__Internal write;

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-request>@ble_gatts_evt_rw_authorize_request_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Request.__Internal __instance;
            internal Request.__Internal __Instance => __instance;

            internal static Request __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Request(native.ToPointer(), skipVTables);
            }

            internal static Request __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Request(native, skipVTables);
            }

            private Request(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Request(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT.Request.__Internal*) native;
            }

            public Request(global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT.Request __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>Attribute Read Parameters.</summary>
            public global::NrfBleDriver.BleGattsEvtReadT Read
            {
                get
                {
                    return global::NrfBleDriver.BleGattsEvtReadT.__CreateInstance(__instance.read);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.read = *(global::NrfBleDriver.BleGattsEvtReadT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Attribute Write Parameters.</summary>
            public global::NrfBleDriver.BleGattsEvtWriteT Write
            {
                get
                {
                    return global::NrfBleDriver.BleGattsEvtWriteT.__CreateInstance(__instance.write);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.write = *(global::NrfBleDriver.BleGattsEvtWriteT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsEvtRwAuthorizeRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsEvtRwAuthorizeRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsEvtRwAuthorizeRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsEvtRwAuthorizeRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsEvtRwAuthorizeRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsEvtRwAuthorizeRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsEvtRwAuthorizeRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsEvtRwAuthorizeRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsEvtRwAuthorizeRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsEvtRwAuthorizeRequestT(global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Type of authorize operation, see</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Request Parameters.</summary>
        public global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT.Request request
        {
            get
            {
                return global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT.Request.__CreateInstance(((__Internal*)__Instance)->request);
            }

            set
            {
                ((__Internal*)__Instance)->request = value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattsEvtSysAttrMissingT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte hint;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_evt_sys_attr_missing_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtSysAttrMissingT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtSysAttrMissingT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsEvtSysAttrMissingT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsEvtSysAttrMissingT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsEvtSysAttrMissingT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsEvtSysAttrMissingT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsEvtSysAttrMissingT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsEvtSysAttrMissingT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsEvtSysAttrMissingT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsEvtSysAttrMissingT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsEvtSysAttrMissingT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsEvtSysAttrMissingT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsEvtSysAttrMissingT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtSysAttrMissingT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsEvtSysAttrMissingT(global::NrfBleDriver.BleGattsEvtSysAttrMissingT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtSysAttrMissingT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsEvtSysAttrMissingT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsEvtSysAttrMissingT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Hint (currently unused).</summary>
        public byte Hint
        {
            get
            {
                return ((__Internal*)__Instance)->hint;
            }

            set
            {
                ((__Internal*)__Instance)->hint = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattsEvtHvcT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal ushort handle;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_evt_hvc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtHvcT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtHvcT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsEvtHvcT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsEvtHvcT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsEvtHvcT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsEvtHvcT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsEvtHvcT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsEvtHvcT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsEvtHvcT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsEvtHvcT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsEvtHvcT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsEvtHvcT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsEvtHvcT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtHvcT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsEvtHvcT(global::NrfBleDriver.BleGattsEvtHvcT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtHvcT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsEvtHvcT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsEvtHvcT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute Handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattsEvtExchangeMtuRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal ushort client_rx_mtu;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_evt_exchange_mtu_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtExchangeMtuRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtExchangeMtuRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsEvtExchangeMtuRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsEvtExchangeMtuRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsEvtExchangeMtuRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsEvtExchangeMtuRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsEvtExchangeMtuRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsEvtExchangeMtuRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsEvtExchangeMtuRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsEvtExchangeMtuRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsEvtExchangeMtuRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsEvtExchangeMtuRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsEvtExchangeMtuRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtExchangeMtuRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsEvtExchangeMtuRequestT(global::NrfBleDriver.BleGattsEvtExchangeMtuRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtExchangeMtuRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsEvtExchangeMtuRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsEvtExchangeMtuRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Client RX MTU size.</summary>
        public ushort ClientRxMtu
        {
            get
            {
                return ((__Internal*)__Instance)->client_rx_mtu;
            }

            set
            {
                ((__Internal*)__Instance)->client_rx_mtu = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattsEvtTimeoutT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte src;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_evt_timeout_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtTimeoutT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtTimeoutT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsEvtTimeoutT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsEvtTimeoutT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsEvtTimeoutT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsEvtTimeoutT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsEvtTimeoutT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsEvtTimeoutT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsEvtTimeoutT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsEvtTimeoutT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsEvtTimeoutT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsEvtTimeoutT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsEvtTimeoutT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtTimeoutT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsEvtTimeoutT(global::NrfBleDriver.BleGattsEvtTimeoutT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtTimeoutT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsEvtTimeoutT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsEvtTimeoutT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Timeout source, see</summary>
        public byte Src
        {
            get
            {
                return ((__Internal*)__Instance)->src;
            }

            set
            {
                ((__Internal*)__Instance)->src = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattsEvtHvnTxCompleteT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte count;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_evt_hvn_tx_complete_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtHvnTxCompleteT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtHvnTxCompleteT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsEvtHvnTxCompleteT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsEvtHvnTxCompleteT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsEvtHvnTxCompleteT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsEvtHvnTxCompleteT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsEvtHvnTxCompleteT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsEvtHvnTxCompleteT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsEvtHvnTxCompleteT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsEvtHvnTxCompleteT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsEvtHvnTxCompleteT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsEvtHvnTxCompleteT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsEvtHvnTxCompleteT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtHvnTxCompleteT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsEvtHvnTxCompleteT(global::NrfBleDriver.BleGattsEvtHvnTxCompleteT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtHvnTxCompleteT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsEvtHvnTxCompleteT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsEvtHvnTxCompleteT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Number of notification transmissions completed.</summary>
        public byte Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }
    }

    /// <summary>GATTS event structure.</summary>
    public unsafe partial class BleGattsEvtT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 18)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal global::NrfBleDriver.BleGattsEvtT.Params.__Internal @params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gatts_evt_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Params
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattsEvtWriteT.__Internal write;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT.__Internal authorize_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattsEvtSysAttrMissingT.__Internal sys_attr_missing;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattsEvtHvcT.__Internal hvc;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattsEvtExchangeMtuRequestT.__Internal exchange_mtu_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattsEvtTimeoutT.__Internal timeout;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattsEvtHvnTxCompleteT.__Internal hvn_tx_complete;

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-params>@ble_gatts_evt_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Params.__Internal __instance;
            internal Params.__Internal __Instance => __instance;

            internal static Params __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Params(native.ToPointer(), skipVTables);
            }

            internal static Params __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Params(native, skipVTables);
            }

            private Params(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Params(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleGattsEvtT.Params.__Internal*) native;
            }

            public Params(global::NrfBleDriver.BleGattsEvtT.Params __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>Write Event Parameters.</summary>
            public global::NrfBleDriver.BleGattsEvtWriteT Write
            {
                get
                {
                    return global::NrfBleDriver.BleGattsEvtWriteT.__CreateInstance(__instance.write);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.write = *(global::NrfBleDriver.BleGattsEvtWriteT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Read or Write Authorize Request Parameters.</summary>
            public global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT AuthorizeRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT.__CreateInstance(__instance.authorize_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.authorize_request = *(global::NrfBleDriver.BleGattsEvtRwAuthorizeRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>System attributes missing.</summary>
            public global::NrfBleDriver.BleGattsEvtSysAttrMissingT SysAttrMissing
            {
                get
                {
                    return global::NrfBleDriver.BleGattsEvtSysAttrMissingT.__CreateInstance(__instance.sys_attr_missing);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.sys_attr_missing = *(global::NrfBleDriver.BleGattsEvtSysAttrMissingT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Handle Value Confirmation Event Parameters.</summary>
            public global::NrfBleDriver.BleGattsEvtHvcT Hvc
            {
                get
                {
                    return global::NrfBleDriver.BleGattsEvtHvcT.__CreateInstance(__instance.hvc);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.hvc = *(global::NrfBleDriver.BleGattsEvtHvcT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Exchange MTU Request Event Parameters.</summary>
            public global::NrfBleDriver.BleGattsEvtExchangeMtuRequestT ExchangeMtuRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGattsEvtExchangeMtuRequestT.__CreateInstance(__instance.exchange_mtu_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.exchange_mtu_request = *(global::NrfBleDriver.BleGattsEvtExchangeMtuRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Timeout Event.</summary>
            public global::NrfBleDriver.BleGattsEvtTimeoutT Timeout
            {
                get
                {
                    return global::NrfBleDriver.BleGattsEvtTimeoutT.__CreateInstance(__instance.timeout);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.timeout = *(global::NrfBleDriver.BleGattsEvtTimeoutT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Handle Value Notification transmission complete Event Parameters.</summary>
            public global::NrfBleDriver.BleGattsEvtHvnTxCompleteT HvnTxComplete
            {
                get
                {
                    return global::NrfBleDriver.BleGattsEvtHvnTxCompleteT.__CreateInstance(__instance.hvn_tx_complete);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.hvn_tx_complete = *(global::NrfBleDriver.BleGattsEvtHvnTxCompleteT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattsEvtT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattsEvtT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattsEvtT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattsEvtT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattsEvtT(native.ToPointer(), skipVTables);
        }

        internal static BleGattsEvtT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattsEvtT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattsEvtT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattsEvtT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattsEvtT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattsEvtT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattsEvtT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattsEvtT(global::NrfBleDriver.BleGattsEvtT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattsEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattsEvtT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattsEvtT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle on which the event occurred.</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>Event Parameters.</summary>
        public global::NrfBleDriver.BleGattsEvtT.Params @params
        {
            get
            {
                return global::NrfBleDriver.BleGattsEvtT.Params.__CreateInstance(((__Internal*)__Instance)->@params);
            }

            set
            {
                ((__Internal*)__Instance)->@params = value.__Instance;
            }
        }
    }

    public unsafe partial class ble_gatts
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gatts_service_add", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattsServiceAdd(__IntPtr adapter, byte type, __IntPtr p_uuid, ushort* p_handle);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gatts_include_add", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattsIncludeAdd(__IntPtr adapter, ushort service_handle, ushort inc_srvc_handle, ushort* p_include_handle);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gatts_characteristic_add", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattsCharacteristicAdd(__IntPtr adapter, ushort service_handle, __IntPtr p_char_md, __IntPtr p_attr_char_value, __IntPtr p_handles);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gatts_descriptor_add", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattsDescriptorAdd(__IntPtr adapter, ushort char_handle, __IntPtr p_attr, ushort* p_handle);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gatts_value_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattsValueSet(__IntPtr adapter, ushort conn_handle, ushort handle, __IntPtr p_value);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gatts_value_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattsValueGet(__IntPtr adapter, ushort conn_handle, ushort handle, __IntPtr p_value);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gatts_hvx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattsHvx(__IntPtr adapter, ushort conn_handle, __IntPtr p_hvx_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gatts_service_changed", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattsServiceChanged(__IntPtr adapter, ushort conn_handle, ushort start_handle, ushort end_handle);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gatts_rw_authorize_reply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattsRwAuthorizeReply(__IntPtr adapter, ushort conn_handle, __IntPtr p_rw_authorize_reply_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gatts_sys_attr_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattsSysAttrSet(__IntPtr adapter, ushort conn_handle, byte* p_sys_attr_data, ushort len, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gatts_sys_attr_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattsSysAttrGet(__IntPtr adapter, ushort conn_handle, byte* p_sys_attr_data, ushort* p_sys_attr_data_len, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gatts_initial_user_handle_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattsInitialUserHandleGet(__IntPtr adapter, ushort* p_handle);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gatts_attr_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattsAttrGet(__IntPtr adapter, ushort handle, __IntPtr p_uuid, __IntPtr p_md);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gatts_exchange_mtu_reply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattsExchangeMtuReply(__IntPtr adapter, ushort conn_handle, ushort server_rx_mtu);
        }

        public static uint SdBleGattsServiceAdd(global::NrfBleDriver.AdapterT adapter, byte type, global::NrfBleDriver.BleUuidT p_uuid, ref ushort p_handle)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_uuid is null ? __IntPtr.Zero : p_uuid.__Instance;
            fixed (ushort* __p_handle3 = &p_handle)
            {
                var __arg3 = __p_handle3;
                var __ret = __Internal.SdBleGattsServiceAdd(__arg0, type, __arg2, __arg3);
                return __ret;
            }
        }

        public static uint SdBleGattsIncludeAdd(global::NrfBleDriver.AdapterT adapter, ushort service_handle, ushort inc_srvc_handle, ref ushort p_include_handle)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (ushort* __p_include_handle3 = &p_include_handle)
            {
                var __arg3 = __p_include_handle3;
                var __ret = __Internal.SdBleGattsIncludeAdd(__arg0, service_handle, inc_srvc_handle, __arg3);
                return __ret;
            }
        }

        public static uint SdBleGattsCharacteristicAdd(global::NrfBleDriver.AdapterT adapter, ushort service_handle, global::NrfBleDriver.BleGattsCharMdT p_char_md, global::NrfBleDriver.BleGattsAttrT p_attr_char_value, global::NrfBleDriver.BleGattsCharHandlesT p_handles)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_char_md is null ? __IntPtr.Zero : p_char_md.__Instance;
            var __arg3 = p_attr_char_value is null ? __IntPtr.Zero : p_attr_char_value.__Instance;
            var __arg4 = p_handles is null ? __IntPtr.Zero : p_handles.__Instance;
            var __ret = __Internal.SdBleGattsCharacteristicAdd(__arg0, service_handle, __arg2, __arg3, __arg4);
            return __ret;
        }

        public static uint SdBleGattsDescriptorAdd(global::NrfBleDriver.AdapterT adapter, ushort char_handle, global::NrfBleDriver.BleGattsAttrT p_attr, ref ushort p_handle)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_attr is null ? __IntPtr.Zero : p_attr.__Instance;
            fixed (ushort* __p_handle3 = &p_handle)
            {
                var __arg3 = __p_handle3;
                var __ret = __Internal.SdBleGattsDescriptorAdd(__arg0, char_handle, __arg2, __arg3);
                return __ret;
            }
        }

        public static uint SdBleGattsValueSet(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort handle, global::NrfBleDriver.BleGattsValueT p_value)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg3 = p_value is null ? __IntPtr.Zero : p_value.__Instance;
            var __ret = __Internal.SdBleGattsValueSet(__arg0, conn_handle, handle, __arg3);
            return __ret;
        }

        public static uint SdBleGattsValueGet(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort handle, global::NrfBleDriver.BleGattsValueT p_value)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg3 = p_value is null ? __IntPtr.Zero : p_value.__Instance;
            var __ret = __Internal.SdBleGattsValueGet(__arg0, conn_handle, handle, __arg3);
            return __ret;
        }

        public static uint SdBleGattsHvx(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGattsHvxParamsT p_hvx_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_hvx_params is null ? __IntPtr.Zero : p_hvx_params.__Instance;
            var __ret = __Internal.SdBleGattsHvx(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGattsServiceChanged(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort start_handle, ushort end_handle)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGattsServiceChanged(__arg0, conn_handle, start_handle, end_handle);
            return __ret;
        }

        public static uint SdBleGattsRwAuthorizeReply(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGattsRwAuthorizeReplyParamsT p_rw_authorize_reply_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_rw_authorize_reply_params is null ? __IntPtr.Zero : p_rw_authorize_reply_params.__Instance;
            var __ret = __Internal.SdBleGattsRwAuthorizeReply(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGattsSysAttrSet(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, byte* p_sys_attr_data, ushort len, uint flags)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGattsSysAttrSet(__arg0, conn_handle, p_sys_attr_data, len, flags);
            return __ret;
        }

        public static uint SdBleGattsSysAttrGet(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, byte* p_sys_attr_data, ref ushort p_sys_attr_data_len, uint flags)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (ushort* __p_sys_attr_data_len3 = &p_sys_attr_data_len)
            {
                var __arg3 = __p_sys_attr_data_len3;
                var __ret = __Internal.SdBleGattsSysAttrGet(__arg0, conn_handle, p_sys_attr_data, __arg3, flags);
                return __ret;
            }
        }

        public static uint SdBleGattsInitialUserHandleGet(global::NrfBleDriver.AdapterT adapter, ref ushort p_handle)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (ushort* __p_handle1 = &p_handle)
            {
                var __arg1 = __p_handle1;
                var __ret = __Internal.SdBleGattsInitialUserHandleGet(__arg0, __arg1);
                return __ret;
            }
        }

        public static uint SdBleGattsAttrGet(global::NrfBleDriver.AdapterT adapter, ushort handle, global::NrfBleDriver.BleUuidT p_uuid, global::NrfBleDriver.BleGattsAttrMdT p_md)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_uuid is null ? __IntPtr.Zero : p_uuid.__Instance;
            var __arg3 = p_md is null ? __IntPtr.Zero : p_md.__Instance;
            var __ret = __Internal.SdBleGattsAttrGet(__arg0, handle, __arg2, __arg3);
            return __ret;
        }

        public static uint SdBleGattsExchangeMtuReply(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort server_rx_mtu)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGattsExchangeMtuReply(__arg0, conn_handle, server_rx_mtu);
            return __ret;
        }
    }

    public unsafe partial class sd_rpc
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_rpc_serial_port_enum", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdRpcSerialPortEnum(global::NrfBleDriver.SdRpcSerialPortDescT.__Internal[] serial_port_descs, uint* size);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_rpc_physical_layer_create_uart", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SdRpcPhysicalLayerCreateUart([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string port_name, uint baud_rate, global::NrfBleDriver.SdRpcFlowControlT flow_control, global::NrfBleDriver.SdRpcParityT parity);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_rpc_data_link_layer_create_bt_three_wire", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SdRpcDataLinkLayerCreateBtThreeWire(__IntPtr physical_layer, uint retransmission_interval);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_rpc_transport_layer_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SdRpcTransportLayerCreate(__IntPtr data_link_layer, uint response_timeout);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_rpc_adapter_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr SdRpcAdapterCreate(__IntPtr transport_layer);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_rpc_adapter_delete", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SdRpcAdapterDelete(__IntPtr adapter);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_rpc_open", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdRpcOpen(__IntPtr adapter, __IntPtr status_handler, __IntPtr event_handler, __IntPtr log_handler);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_rpc_close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdRpcClose(__IntPtr adapter);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_rpc_log_handler_severity_filter_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdRpcLogHandlerSeverityFilterSet(__IntPtr adapter, global::NrfBleDriver.SdRpcLogSeverityT severity_filter);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_rpc_conn_reset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdRpcConnReset(__IntPtr adapter, global::NrfBleDriver.SdRpcResetT reset_mode);
        }

        /// <summary>Enumerate available serial ports.</summary>
        /// <param name="serial_port_descs">The array of serial port descriptors to be filled in.</param>
        /// <param name="size">The size of the array. The number of ports found is stored here.</param>
        /// <remarks>
        /// <para>NRF_SUCCESS  The serial ports were enumerated successfully.</para>
        /// <para>NRF_ERROR_NULL size was a null pointer.</para>
        /// <para>NRF_ERROR_DATA_SIZE The size of the array was not large enough to keep all descriptors found.</para>
        /// <para>No descriptors where copied. Call again with an larger array.</para>
        /// <para>NRF_ERROR    There was an error enumerating the serial ports.</para>
        /// </remarks>
        public static uint SdRpcSerialPortEnum(global::NrfBleDriver.SdRpcSerialPortDescT[] serial_port_descs, ref uint size)
        {
            global::NrfBleDriver.SdRpcSerialPortDescT.__Internal[] __serial_port_descs;
            if (serial_port_descs == null)
                __serial_port_descs = null;
            else
            {
                __serial_port_descs = new global::NrfBleDriver.SdRpcSerialPortDescT.__Internal[serial_port_descs.Length];
                for (int i = 0; i < __serial_port_descs.Length; i++)
                {
                    var __element = serial_port_descs[i];
                    __serial_port_descs[i] = __element is null ? new global::NrfBleDriver.SdRpcSerialPortDescT.__Internal() : *(global::NrfBleDriver.SdRpcSerialPortDescT.__Internal*) __element.__Instance;
                }
            }
            var __arg0 = __serial_port_descs;
            fixed (uint* __size1 = &size)
            {
                var __arg1 = __size1;
                var __ret = __Internal.SdRpcSerialPortEnum(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>Create a new serial physical layer.</summary>
        /// <param name="port_name">The serial port name.</param>
        /// <param name="baud_rate">The serial port speed.</param>
        /// <param name="flow_control">The flow control scheme to use.</param>
        /// <param name="parity">The parity scheme to use.</param>
        /// <remarks>The physical layer or NULL.</remarks>
        public static global::NrfBleDriver.PhysicalLayerT SdRpcPhysicalLayerCreateUart(string port_name, uint baud_rate, global::NrfBleDriver.SdRpcFlowControlT flow_control, global::NrfBleDriver.SdRpcParityT parity)
        {
            var __ret = __Internal.SdRpcPhysicalLayerCreateUart(port_name, baud_rate, flow_control, parity);
            var __result0 = global::NrfBleDriver.PhysicalLayerT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Create a new data link layer.</summary>
        /// <param name="physical_layer">The physical layer to use with this data link layer.</param>
        /// <param name="response_timeout">Response timeout of the data link layer.</param>
        /// <remarks>The data link layer or NULL.</remarks>
        public static global::NrfBleDriver.DataLinkLayerT SdRpcDataLinkLayerCreateBtThreeWire(global::NrfBleDriver.PhysicalLayerT physical_layer, uint retransmission_interval)
        {
            var __arg0 = physical_layer is null ? __IntPtr.Zero : physical_layer.__Instance;
            var __ret = __Internal.SdRpcDataLinkLayerCreateBtThreeWire(__arg0, retransmission_interval);
            var __result0 = global::NrfBleDriver.DataLinkLayerT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Create a new transport layer.</summary>
        /// <param name="data_link_layer">The data linkk layer to use with this transport.</param>
        /// <param name="response_timeout">Response timeout.</param>
        /// <remarks>The transport layer or NULL.</remarks>
        public static global::NrfBleDriver.TransportLayerT SdRpcTransportLayerCreate(global::NrfBleDriver.DataLinkLayerT data_link_layer, uint response_timeout)
        {
            var __arg0 = data_link_layer is null ? __IntPtr.Zero : data_link_layer.__Instance;
            var __ret = __Internal.SdRpcTransportLayerCreate(__arg0, response_timeout);
            var __result0 = global::NrfBleDriver.TransportLayerT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Create a new transport adapter.</summary>
        /// <param name="transport_layer">The transport layer to use with this adapter.</param>
        /// <remarks>The adapter or NULL.</remarks>
        public static global::NrfBleDriver.AdapterT SdRpcAdapterCreate(global::NrfBleDriver.TransportLayerT transport_layer)
        {
            var __arg0 = transport_layer is null ? __IntPtr.Zero : transport_layer.__Instance;
            var __ret = __Internal.SdRpcAdapterCreate(__arg0);
            var __result0 = global::NrfBleDriver.AdapterT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Delete a transport adapter.</summary>
        /// <param name="adapter">The transport adapter.</param>
        public static void SdRpcAdapterDelete(global::NrfBleDriver.AdapterT adapter)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            __Internal.SdRpcAdapterDelete(__arg0);
        }

        /// <summary>Initialize the SoftDevice RPC module.</summary>
        /// <param name="adapter">The transport adapter.</param>
        /// <param name="status_handler">The status handler callback.</param>
        /// <param name="evt_handler">The event handler callback.</param>
        /// <param name="log_handler">The log handler callback.</param>
        /// <remarks>
        /// <para>This function must be called prior to the sd_ble_* API commands.</para>
        /// <para>The serial port will be attempted opened with the configured serial port settings.</para>
        /// <para>NRF_SUCCESS  The module was opened successfully.</para>
        /// <para>NRF_ERROR    There was an error opening the module.</para>
        /// </remarks>
        public static uint SdRpcOpen(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.SdRpcStatusHandlerT status_handler, global::NrfBleDriver.SdRpcEvtHandlerT event_handler, global::NrfBleDriver.SdRpcLogHandlerT log_handler)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = status_handler == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(status_handler);
            var __arg2 = event_handler == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(event_handler);
            var __arg3 = log_handler == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(log_handler);
            var __ret = __Internal.SdRpcOpen(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }

        /// <summary>Close the SoftDevice RPC module.</summary>
        /// <param name="adapter">The transport adapter.</param>
        /// <remarks>
        /// <para>This function will close the serial port and release allocated resources.</para>
        /// <para>NRF_SUCCESS  The module was closed successfully.</para>
        /// <para>NRF_ERROR    There was an error closing the module.</para>
        /// </remarks>
        public static uint SdRpcClose(global::NrfBleDriver.AdapterT adapter)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdRpcClose(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set the lowest log level for messages to be logged to handler.</para>
        /// <para>Default log handler severity filter is LOG_INFO.</para>
        /// </summary>
        /// <param name="adapter">The transport adapter.</param>
        /// <param name="severity_filter">The lowest severity level messages should be logged.</param>
        /// <remarks>
        /// <para>NRF_SUCCESS              severity_filter is valid.</para>
        /// <para>NRF_ERROR_INVALID_PARAM  severity_filter is not one of the valid enum values</para>
        /// <para>in app_log_severity_t</para>
        /// </remarks>
        public static uint SdRpcLogHandlerSeverityFilterSet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.SdRpcLogSeverityT severity_filter)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdRpcLogHandlerSeverityFilterSet(__arg0, severity_filter);
            return __ret;
        }

        /// <summary>Reset the connectivity chip.</summary>
        /// <param name="adapter">The transport adapter.</param>
        /// <param name="reset_mode">The reset mode to perform in connectivity firmware.</param>
        /// <remarks>
        /// <para>NRF_SUCCESS  The connectivity chip was reset successfully.</para>
        /// <para>NRF_ERROR    There was an error reset the connectivity chip.</para>
        /// </remarks>
        public static uint SdRpcConnReset(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.SdRpcResetT reset_mode)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdRpcConnReset(__arg0, reset_mode);
            return __ret;
        }
    }

    /// <summary>Error codes that an error callback can be associated with.</summary>
    public enum SdRpcAppStatusT
    {
        PKT_SEND_MAX_RETRIES_REACHED = 0,
        PKT_UNEXPECTED = 1,
        PKT_ENCODE_ERROR = 2,
        PKT_DECODE_ERROR = 3,
        PKT_SEND_ERROR = 4,
        IO_RESOURCES_UNAVAILABLE = 5,
        RESET_PERFORMED = 6,
        CONNECTION_ACTIVE = 7
    }

    /// <summary>Levels of severity that a log message can be associated with.</summary>
    public enum SdRpcLogSeverityT
    {
        SD_RPC_LOG_TRACE = 0,
        SD_RPC_LOG_DEBUG = 1,
        SD_RPC_LOG_INFO = 2,
        SD_RPC_LOG_WARNING = 3,
        SD_RPC_LOG_ERROR = 4,
        SD_RPC_LOG_FATAL = 5
    }

    /// <summary>Flow control modes</summary>
    public enum SdRpcFlowControlT
    {
        SD_RPC_FLOW_CONTROL_NONE = 0,
        SD_RPC_FLOW_CONTROL_HARDWARE = 1
    }

    /// <summary>Parity modes</summary>
    public enum SdRpcParityT
    {
        SD_RPC_PARITY_NONE = 0,
        SD_RPC_PARITY_EVEN = 1
    }

    /// <summary>Reset modes to specify how the connectivity firmware will perform a reset.</summary>
    public enum SdRpcResetT
    {
        SYS_RESET = 0,
        /// <summary>System reset of the connectivity chip, all state is reset.</summary>
        SOFT_RESET = 1
    }

    /// <summary>Error codes that an error callback can be associated with.</summary>
    /// <summary>Error codes that an error callback can be associated with.</summary>
    /// <summary>Levels of severity that a log message can be associated with.</summary>
    /// <summary>Flow control modes</summary>
    /// <summary>Parity modes</summary>
    /// <summary>Reset modes to specify how the connectivity firmware will perform a reset.</summary>
    /// <summary>Function pointer type for event callbacks.</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void SdRpcStatusHandlerT(__IntPtr adapter, global::NrfBleDriver.SdRpcAppStatusT code, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string message);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void SdRpcEvtHandlerT(__IntPtr adapter, __IntPtr p_ble_evt);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void SdRpcLogHandlerT(__IntPtr adapter, global::NrfBleDriver.SdRpcLogSeverityT severity, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string log_message);

    /// <summary>Error codes that an error callback can be associated with.</summary>
    public unsafe partial class SdRpcSerialPortDescT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 3584)]
        public partial struct __Internal
        {
            internal fixed sbyte port[512];
            internal fixed sbyte manufacturer[512];
            internal fixed sbyte serialNumber[512];
            internal fixed sbyte pnpId[512];
            internal fixed sbyte locationId[512];
            internal fixed sbyte vendorId[512];
            internal fixed sbyte productId[512];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0sd_rpc_serial_port_desc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.SdRpcSerialPortDescT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.SdRpcSerialPortDescT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.SdRpcSerialPortDescT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.SdRpcSerialPortDescT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SdRpcSerialPortDescT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SdRpcSerialPortDescT(native.ToPointer(), skipVTables);
        }

        internal static SdRpcSerialPortDescT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SdRpcSerialPortDescT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SdRpcSerialPortDescT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SdRpcSerialPortDescT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SdRpcSerialPortDescT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SdRpcSerialPortDescT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SdRpcSerialPortDescT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.SdRpcSerialPortDescT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public SdRpcSerialPortDescT(global::NrfBleDriver.SdRpcSerialPortDescT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.SdRpcSerialPortDescT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.SdRpcSerialPortDescT.__Internal*) __Instance) = *((global::NrfBleDriver.SdRpcSerialPortDescT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] Port
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->port, 512);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((__Internal*)__Instance)->port[i] = value[i];
                }
            }
        }

        public sbyte[] Manufacturer
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->manufacturer, 512);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((__Internal*)__Instance)->manufacturer[i] = value[i];
                }
            }
        }

        public sbyte[] SerialNumber
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->serialNumber, 512);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((__Internal*)__Instance)->serialNumber[i] = value[i];
                }
            }
        }

        public sbyte[] PnpId
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->pnpId, 512);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((__Internal*)__Instance)->pnpId[i] = value[i];
                }
            }
        }

        public sbyte[] LocationId
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->locationId, 512);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((__Internal*)__Instance)->locationId[i] = value[i];
                }
            }
        }

        public sbyte[] VendorId
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->vendorId, 512);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((__Internal*)__Instance)->vendorId[i] = value[i];
                }
            }
        }

        public sbyte[] ProductId
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->productId, 512);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((__Internal*)__Instance)->productId[i] = value[i];
                }
            }
        }
    }
}
