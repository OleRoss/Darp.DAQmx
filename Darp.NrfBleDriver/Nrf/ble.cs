// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace NrfBleDriver
{
    /// <summary>Common API SVC numbers.</summary>
    public enum BLE_COMMON_SVCS
    {
        /// <summary>Enable and initialize the BLE stack</summary>
        SD_BLE_ENABLE = 96,
        /// <summary>Get an event from the pending events queue.</summary>
        SD_BLE_EVT_GET = 97,
        /// <summary>Add a Vendor Specific UUID.</summary>
        SD_BLE_UUID_VS_ADD = 98,
        /// <summary>Decode UUID bytes.</summary>
        SD_BLE_UUID_DECODE = 99,
        /// <summary>Encode UUID bytes.</summary>
        SD_BLE_UUID_ENCODE = 100,
        /// <summary>Get the local version information (company ID, Link Layer Version, Link Layer Subversion).</summary>
        SD_BLE_VERSION_GET = 101,
        /// <summary>User Memory Reply.</summary>
        SD_BLE_USER_MEM_REPLY = 102,
        /// <summary>Set a BLE option.</summary>
        SD_BLE_OPT_SET = 103,
        /// <summary>Get a BLE option.</summary>
        SD_BLE_OPT_GET = 104,
        /// <summary>Add a configuration to the BLE stack.</summary>
        SD_BLE_CFG_SET = 105
    }

    /// <summary>BLE Module Independent Event IDs.</summary>
    public enum BLE_COMMON_EVTS
    {
        /// <summary>User Memory request.</summary>
        BLE_EVT_USER_MEM_REQUEST = 1,
        /// <summary>User Memory release.</summary>
        BLE_EVT_USER_MEM_RELEASE = 2
    }

    /// <summary>BLE Connection Configuration IDs.</summary>
    /// <remarks>IDs that uniquely identify a connection configuration.</remarks>
    public enum BLE_CONN_CFGS
    {
        /// <summary>BLE GAP specific connection configuration.</summary>
        BLE_CONN_CFG_GAP = 32,
        /// <summary>BLE GATTC specific connection configuration.</summary>
        BLE_CONN_CFG_GATTC = 33,
        /// <summary>BLE GATTS specific connection configuration.</summary>
        BLE_CONN_CFG_GATTS = 34,
        /// <summary>BLE GATT specific connection configuration.</summary>
        BLE_CONN_CFG_GATT = 35,
        /// <summary>BLE L2CAP specific connection configuration.</summary>
        BLE_CONN_CFG_L2CAP = 36
    }

    /// <summary>BLE Common Configuration IDs.</summary>
    /// <remarks>IDs that uniquely identify a common configuration.</remarks>
    public enum BLE_COMMON_CFGS
    {
        /// <summary>Vendor specific UUID configuration</summary>
        BLE_COMMON_CFG_VS_UUID = 1
    }

    /// <summary>
    /// <para>Common Option IDs.</para>
    /// <para>IDs that uniquely identify a common option.</para>
    /// </summary>
    public enum BLE_COMMON_OPTS
    {
        /// <summary>PA and LNA options</summary>
        BLE_COMMON_OPT_PA_LNA = 1,
        /// <summary>Extended connection events option</summary>
        BLE_COMMON_OPT_CONN_EVT_EXT = 2
    }

    /// <summary>User Memory Block.</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for events not associated with a specific function module.</summary>
    /// <summary>BLE Event header.</summary>
    /// <summary>Common BLE Event type, wrapping the module specific event reports.</summary>
    /// <summary>Version Information.</summary>
    /// <summary>Configuration parameters for the PA and LNA.</summary>
    /// <summary>PA&amp;LNA GPIO toggle configuration</summary>
    /// <remarks>
    /// <para>This option configures the SoftDevice to toggle pins when the radio is active for use with a power amplifier and/or</para>
    /// <para>a low noise amplifier.</para>
    /// <para>Toggling the pins is achieved by using two PPI channels and a GPIOTE channel. The hardware channel IDs are provided</para>
    /// <para>by the application and should be regarded as reserved as long as any PA/LNA toggling is enabled.</para>
    /// <para>is not supported for this option.</para>
    /// <para>Setting this option while the radio is in use (i.e. any of the roles are active) may have undefined consequences</para>
    /// <para>and must be avoided by the application.</para>
    /// </remarks>
    /// <summary>Configuration of extended BLE connection events.</summary>
    /// <remarks>
    /// <para>When enabled the SoftDevice will dynamically extend the connection event when possible.</para>
    /// <para>The connection event length is controlled by the connection configuration as set byThe connection event can be extended if there is time to send another packet pair before the start of the next connection interval,</para>
    /// <para>and if there are no conflicts with other BLE roles requesting radio time.</para>
    /// <para>is not supported for this option.</para>
    /// </remarks>
    /// <summary>Option structure for common options.</summary>
    /// <summary>Common BLE Option type, wrapping the module specific options.</summary>
    /// <summary>BLE connection configuration type, wrapping the module specific configurations, set with</summary>
    /// <remarks>
    /// <para>Connection configurations don't have to be set.</para>
    /// <para>In the case that no configurations has been set, or fewer connection configurations has been set than enabled connections,</para>
    /// <para>the default connection configuration will be automatically added for the remaining connections.</para>
    /// <para>When creating connections with the default configuration,should be used in</para>
    /// <para>place ofSeeand</para>
    /// <para>s</para>
    /// </remarks>
    /// <summary>Configuration of Vendor Specific UUIDs, set with</summary>
    /// <remarks>::NRF_ERROR_INVALID_PARAM Too many UUIDs configured.</remarks>
    /// <summary>Common BLE Configuration type, wrapping the common configurations.</summary>
    /// <summary>BLE Configuration type, wrapping the module specific configurations.</summary>
    /// <summary>User Memory Block.</summary>
    public unsafe partial class BleUserMemBlockT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr p_mem;
            internal ushort len;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_user_mem_block_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleUserMemBlockT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleUserMemBlockT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleUserMemBlockT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleUserMemBlockT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleUserMemBlockT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleUserMemBlockT(native.ToPointer(), skipVTables);
        }

        internal static BleUserMemBlockT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleUserMemBlockT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleUserMemBlockT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleUserMemBlockT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleUserMemBlockT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleUserMemBlockT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleUserMemBlockT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleUserMemBlockT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleUserMemBlockT(global::NrfBleDriver.BleUserMemBlockT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleUserMemBlockT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleUserMemBlockT.__Internal*) __Instance) = *((global::NrfBleDriver.BleUserMemBlockT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Pointer to the start of the user memory block.</summary>
        public byte* PMem
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_mem;
            }

            set
            {
                ((__Internal*)__Instance)->p_mem = (__IntPtr) value;
            }
        }

        /// <summary>Length in bytes of the user memory block.</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleEvtUserMemRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte type;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_evt_user_mem_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtUserMemRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtUserMemRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleEvtUserMemRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleEvtUserMemRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleEvtUserMemRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleEvtUserMemRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleEvtUserMemRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleEvtUserMemRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleEvtUserMemRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleEvtUserMemRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleEvtUserMemRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleEvtUserMemRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleEvtUserMemRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtUserMemRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleEvtUserMemRequestT(global::NrfBleDriver.BleEvtUserMemRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtUserMemRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleEvtUserMemRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleEvtUserMemRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>User memory type, see</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleEvtUserMemReleaseT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal byte type;
            internal global::NrfBleDriver.BleUserMemBlockT.__Internal mem_block;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_evt_user_mem_release_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtUserMemReleaseT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtUserMemReleaseT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleEvtUserMemReleaseT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleEvtUserMemReleaseT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleEvtUserMemReleaseT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleEvtUserMemReleaseT(native.ToPointer(), skipVTables);
        }

        internal static BleEvtUserMemReleaseT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleEvtUserMemReleaseT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleEvtUserMemReleaseT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleEvtUserMemReleaseT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleEvtUserMemReleaseT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleEvtUserMemReleaseT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleEvtUserMemReleaseT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtUserMemReleaseT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleEvtUserMemReleaseT(global::NrfBleDriver.BleEvtUserMemReleaseT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtUserMemReleaseT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleEvtUserMemReleaseT.__Internal*) __Instance) = *((global::NrfBleDriver.BleEvtUserMemReleaseT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>User memory type, see</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>User memory block</summary>
        public global::NrfBleDriver.BleUserMemBlockT MemBlock
        {
            get
            {
                return global::NrfBleDriver.BleUserMemBlockT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->mem_block));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->mem_block = *(global::NrfBleDriver.BleUserMemBlockT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for events not associated with a specific function module.</summary>
    public unsafe partial class BleCommonEvtT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal global::NrfBleDriver.BleCommonEvtT.Params.__Internal @params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_common_evt_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Params
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::NrfBleDriver.BleEvtUserMemRequestT.__Internal user_mem_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleEvtUserMemReleaseT.__Internal user_mem_release;

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-params>@ble_common_evt_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Params.__Internal __instance;
            internal Params.__Internal __Instance => __instance;

            internal static Params __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Params(native.ToPointer(), skipVTables);
            }

            internal static Params __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Params(native, skipVTables);
            }

            private Params(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Params(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleCommonEvtT.Params.__Internal*) native;
            }

            public Params(global::NrfBleDriver.BleCommonEvtT.Params __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>User Memory Request Event Parameters.</summary>
            public global::NrfBleDriver.BleEvtUserMemRequestT UserMemRequest
            {
                get
                {
                    return global::NrfBleDriver.BleEvtUserMemRequestT.__CreateInstance(__instance.user_mem_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.user_mem_request = *(global::NrfBleDriver.BleEvtUserMemRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>User Memory Release Event Parameters.</summary>
            public global::NrfBleDriver.BleEvtUserMemReleaseT UserMemRelease
            {
                get
                {
                    return global::NrfBleDriver.BleEvtUserMemReleaseT.__CreateInstance(__instance.user_mem_release);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.user_mem_release = *(global::NrfBleDriver.BleEvtUserMemReleaseT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonEvtT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonEvtT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleCommonEvtT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleCommonEvtT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleCommonEvtT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleCommonEvtT(native.ToPointer(), skipVTables);
        }

        internal static BleCommonEvtT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleCommonEvtT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleCommonEvtT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleCommonEvtT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleCommonEvtT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleCommonEvtT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleCommonEvtT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleCommonEvtT(global::NrfBleDriver.BleCommonEvtT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleCommonEvtT.__Internal*) __Instance) = *((global::NrfBleDriver.BleCommonEvtT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle on which this event occurred.</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>Event parameter union.</summary>
        public global::NrfBleDriver.BleCommonEvtT.Params @params
        {
            get
            {
                return global::NrfBleDriver.BleCommonEvtT.Params.__CreateInstance(((__Internal*)__Instance)->@params);
            }

            set
            {
                ((__Internal*)__Instance)->@params = value.__Instance;
            }
        }
    }

    /// <summary>BLE Event header.</summary>
    public unsafe partial class BleEvtHdrT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal ushort evt_id;
            internal ushort evt_len;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_evt_hdr_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtHdrT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtHdrT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleEvtHdrT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleEvtHdrT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleEvtHdrT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleEvtHdrT(native.ToPointer(), skipVTables);
        }

        internal static BleEvtHdrT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleEvtHdrT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleEvtHdrT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleEvtHdrT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleEvtHdrT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleEvtHdrT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleEvtHdrT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtHdrT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleEvtHdrT(global::NrfBleDriver.BleEvtHdrT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtHdrT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleEvtHdrT.__Internal*) __Instance) = *((global::NrfBleDriver.BleEvtHdrT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Value from a BLE_&gt;_EVT series.</summary>
        public ushort EvtId
        {
            get
            {
                return ((__Internal*)__Instance)->evt_id;
            }

            set
            {
                ((__Internal*)__Instance)->evt_id = value;
            }
        }

        /// <summary>Length in octets including this header.</summary>
        public ushort EvtLen
        {
            get
            {
                return ((__Internal*)__Instance)->evt_len;
            }

            set
            {
                ((__Internal*)__Instance)->evt_len = value;
            }
        }
    }

    /// <summary>Common BLE Event type, wrapping the module specific event reports.</summary>
    public unsafe partial class BleEvtT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleEvtHdrT.__Internal header;
            internal global::NrfBleDriver.BleEvtT.Evt.__Internal evt;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_evt_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Evt
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::NrfBleDriver.BleCommonEvtT.__Internal common_evt;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtT.__Internal gap_evt;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtT.__Internal gattc_evt;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattsEvtT.__Internal gatts_evt;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtT.__Internal l2cap_evt;

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-evt>@ble_evt_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Evt.__Internal __instance;
            internal Evt.__Internal __Instance => __instance;

            internal static Evt __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Evt(native.ToPointer(), skipVTables);
            }

            internal static Evt __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Evt(native, skipVTables);
            }

            private Evt(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Evt(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleEvtT.Evt.__Internal*) native;
            }

            public Evt(global::NrfBleDriver.BleEvtT.Evt __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>Common Event, evt_id in BLE_EVT_* series.</summary>
            public global::NrfBleDriver.BleCommonEvtT CommonEvt
            {
                get
                {
                    return global::NrfBleDriver.BleCommonEvtT.__CreateInstance(__instance.common_evt);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.common_evt = *(global::NrfBleDriver.BleCommonEvtT.__Internal*) value.__Instance;
                }
            }

            /// <summary>GAP originated event, evt_id in BLE_GAP_EVT_* series.</summary>
            public global::NrfBleDriver.BleGapEvtT GapEvt
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtT.__CreateInstance(__instance.gap_evt);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.gap_evt = *(global::NrfBleDriver.BleGapEvtT.__Internal*) value.__Instance;
                }
            }

            /// <summary>GATT client originated event, evt_id in BLE_GATTC_EVT* series.</summary>
            public global::NrfBleDriver.BleGattcEvtT GattcEvt
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtT.__CreateInstance(__instance.gattc_evt);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.gattc_evt = *(global::NrfBleDriver.BleGattcEvtT.__Internal*) value.__Instance;
                }
            }

            /// <summary>GATT server originated event, evt_id in BLE_GATTS_EVT* series.</summary>
            public global::NrfBleDriver.BleGattsEvtT GattsEvt
            {
                get
                {
                    return global::NrfBleDriver.BleGattsEvtT.__CreateInstance(__instance.gatts_evt);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.gatts_evt = *(global::NrfBleDriver.BleGattsEvtT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP originated event, evt_id in BLE_L2CAP_EVT* series.</summary>
            public global::NrfBleDriver.BleL2capEvtT L2capEvt
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtT.__CreateInstance(__instance.l2cap_evt);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.l2cap_evt = *(global::NrfBleDriver.BleL2capEvtT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleEvtT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleEvtT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleEvtT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleEvtT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleEvtT(native.ToPointer(), skipVTables);
        }

        internal static BleEvtT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleEvtT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleEvtT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleEvtT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleEvtT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleEvtT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleEvtT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleEvtT(global::NrfBleDriver.BleEvtT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleEvtT.__Internal*) __Instance) = *((global::NrfBleDriver.BleEvtT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Event header.</summary>
        public global::NrfBleDriver.BleEvtHdrT Header
        {
            get
            {
                return global::NrfBleDriver.BleEvtHdrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->header));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->header = *(global::NrfBleDriver.BleEvtHdrT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Event union.</summary>
        public global::NrfBleDriver.BleEvtT.Evt evt
        {
            get
            {
                return global::NrfBleDriver.BleEvtT.Evt.__CreateInstance(((__Internal*)__Instance)->evt);
            }

            set
            {
                ((__Internal*)__Instance)->evt = value.__Instance;
            }
        }
    }

    /// <summary>Version Information.</summary>
    public unsafe partial class BleVersionT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 6)]
        public partial struct __Internal
        {
            internal byte version_number;
            internal ushort company_id;
            internal ushort subversion_number;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_version_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleVersionT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleVersionT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleVersionT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleVersionT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleVersionT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleVersionT(native.ToPointer(), skipVTables);
        }

        internal static BleVersionT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleVersionT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleVersionT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleVersionT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleVersionT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleVersionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleVersionT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleVersionT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleVersionT(global::NrfBleDriver.BleVersionT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleVersionT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleVersionT.__Internal*) __Instance) = *((global::NrfBleDriver.BleVersionT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Link Layer Version number. See https://www.bluetooth.org/en-us/specification/assigned-numbers/link-layer for assigned values.</summary>
        public byte VersionNumber
        {
            get
            {
                return ((__Internal*)__Instance)->version_number;
            }

            set
            {
                ((__Internal*)__Instance)->version_number = value;
            }
        }

        /// <summary>Company ID, Nordic Semiconductor's company ID is 89 (0x0059) (https://www.bluetooth.org/apps/content/Default.aspx?doc_id=49708).</summary>
        public ushort CompanyId
        {
            get
            {
                return ((__Internal*)__Instance)->company_id;
            }

            set
            {
                ((__Internal*)__Instance)->company_id = value;
            }
        }

        /// <summary>Link Layer Sub Version number, corresponds to the SoftDevice Config ID or Firmware ID (FWID).</summary>
        public ushort SubversionNumber
        {
            get
            {
                return ((__Internal*)__Instance)->subversion_number;
            }

            set
            {
                ((__Internal*)__Instance)->subversion_number = value;
            }
        }
    }

    /// <summary>Configuration parameters for the PA and LNA.</summary>
    public unsafe partial class BlePaLnaCfgT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte enable;

            [FieldOffset(0)]
            internal byte active_high;

            [FieldOffset(0)]
            internal byte gpio_pin;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_pa_lna_cfg_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BlePaLnaCfgT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BlePaLnaCfgT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BlePaLnaCfgT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BlePaLnaCfgT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BlePaLnaCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BlePaLnaCfgT(native.ToPointer(), skipVTables);
        }

        internal static BlePaLnaCfgT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BlePaLnaCfgT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BlePaLnaCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BlePaLnaCfgT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BlePaLnaCfgT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BlePaLnaCfgT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BlePaLnaCfgT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BlePaLnaCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BlePaLnaCfgT(global::NrfBleDriver.BlePaLnaCfgT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BlePaLnaCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BlePaLnaCfgT.__Internal*) __Instance) = *((global::NrfBleDriver.BlePaLnaCfgT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Enable toggling for this amplifier</summary>
        public byte Enable
        {
            get
            {
                return ((__Internal*)__Instance)->enable;
            }

            set
            {
                ((__Internal*)__Instance)->enable = value;
            }
        }

        /// <summary>Set the pin to be active high</summary>
        public byte ActiveHigh
        {
            get
            {
                return ((__Internal*)__Instance)->active_high;
            }

            set
            {
                ((__Internal*)__Instance)->active_high = value;
            }
        }

        /// <summary>The GPIO pin to toggle for this amplifier</summary>
        public byte GpioPin
        {
            get
            {
                return ((__Internal*)__Instance)->gpio_pin;
            }

            set
            {
                ((__Internal*)__Instance)->gpio_pin = value;
            }
        }
    }

    /// <summary>PA&amp;LNA GPIO toggle configuration</summary>
    /// <remarks>
    /// <para>This option configures the SoftDevice to toggle pins when the radio is active for use with a power amplifier and/or</para>
    /// <para>a low noise amplifier.</para>
    /// <para>Toggling the pins is achieved by using two PPI channels and a GPIOTE channel. The hardware channel IDs are provided</para>
    /// <para>by the application and should be regarded as reserved as long as any PA/LNA toggling is enabled.</para>
    /// <para>is not supported for this option.</para>
    /// <para>Setting this option while the radio is in use (i.e. any of the roles are active) may have undefined consequences</para>
    /// <para>and must be avoided by the application.</para>
    /// </remarks>
    public unsafe partial class BleCommonOptPaLnaT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 5)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BlePaLnaCfgT.__Internal pa_cfg;
            internal global::NrfBleDriver.BlePaLnaCfgT.__Internal lna_cfg;
            internal byte ppi_ch_id_set;
            internal byte ppi_ch_id_clr;
            internal byte gpiote_ch_id;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_common_opt_pa_lna_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonOptPaLnaT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonOptPaLnaT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleCommonOptPaLnaT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleCommonOptPaLnaT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleCommonOptPaLnaT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleCommonOptPaLnaT(native.ToPointer(), skipVTables);
        }

        internal static BleCommonOptPaLnaT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleCommonOptPaLnaT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleCommonOptPaLnaT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleCommonOptPaLnaT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleCommonOptPaLnaT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleCommonOptPaLnaT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleCommonOptPaLnaT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonOptPaLnaT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleCommonOptPaLnaT(global::NrfBleDriver.BleCommonOptPaLnaT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonOptPaLnaT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleCommonOptPaLnaT.__Internal*) __Instance) = *((global::NrfBleDriver.BleCommonOptPaLnaT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Power Amplifier configuration</summary>
        public global::NrfBleDriver.BlePaLnaCfgT PaCfg
        {
            get
            {
                return global::NrfBleDriver.BlePaLnaCfgT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->pa_cfg));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->pa_cfg = *(global::NrfBleDriver.BlePaLnaCfgT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Low Noise Amplifier configuration</summary>
        public global::NrfBleDriver.BlePaLnaCfgT LnaCfg
        {
            get
            {
                return global::NrfBleDriver.BlePaLnaCfgT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->lna_cfg));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->lna_cfg = *(global::NrfBleDriver.BlePaLnaCfgT.__Internal*) value.__Instance;
            }
        }

        /// <summary>PPI channel used for radio pin setting</summary>
        public byte PpiChIdSet
        {
            get
            {
                return ((__Internal*)__Instance)->ppi_ch_id_set;
            }

            set
            {
                ((__Internal*)__Instance)->ppi_ch_id_set = value;
            }
        }

        /// <summary>PPI channel used for radio pin clearing</summary>
        public byte PpiChIdClr
        {
            get
            {
                return ((__Internal*)__Instance)->ppi_ch_id_clr;
            }

            set
            {
                ((__Internal*)__Instance)->ppi_ch_id_clr = value;
            }
        }

        /// <summary>GPIOTE channel used for radio pin toggling</summary>
        public byte GpioteChId
        {
            get
            {
                return ((__Internal*)__Instance)->gpiote_ch_id;
            }

            set
            {
                ((__Internal*)__Instance)->gpiote_ch_id = value;
            }
        }
    }

    /// <summary>Configuration of extended BLE connection events.</summary>
    /// <remarks>
    /// <para>When enabled the SoftDevice will dynamically extend the connection event when possible.</para>
    /// <para>The connection event length is controlled by the connection configuration as set byThe connection event can be extended if there is time to send another packet pair before the start of the next connection interval,</para>
    /// <para>and if there are no conflicts with other BLE roles requesting radio time.</para>
    /// <para>is not supported for this option.</para>
    /// </remarks>
    public unsafe partial class BleCommonOptConnEvtExtT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte enable;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_common_opt_conn_evt_ext_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonOptConnEvtExtT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonOptConnEvtExtT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleCommonOptConnEvtExtT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleCommonOptConnEvtExtT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleCommonOptConnEvtExtT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleCommonOptConnEvtExtT(native.ToPointer(), skipVTables);
        }

        internal static BleCommonOptConnEvtExtT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleCommonOptConnEvtExtT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleCommonOptConnEvtExtT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleCommonOptConnEvtExtT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleCommonOptConnEvtExtT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleCommonOptConnEvtExtT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleCommonOptConnEvtExtT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonOptConnEvtExtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleCommonOptConnEvtExtT(global::NrfBleDriver.BleCommonOptConnEvtExtT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonOptConnEvtExtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleCommonOptConnEvtExtT.__Internal*) __Instance) = *((global::NrfBleDriver.BleCommonOptConnEvtExtT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Enable extended BLE connection events, disabled by default.</summary>
        public byte Enable
        {
            get
            {
                return ((__Internal*)__Instance)->enable;
            }

            set
            {
                ((__Internal*)__Instance)->enable = value;
            }
        }
    }

    /// <summary>Option structure for common options.</summary>
    public unsafe partial struct BleCommonOptT
    {
        [StructLayout(LayoutKind.Explicit, Size = 5)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleCommonOptPaLnaT.__Internal pa_lna;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleCommonOptConnEvtExtT.__Internal conn_evt_ext;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_common_opt_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        private BleCommonOptT.__Internal __instance;
        internal BleCommonOptT.__Internal __Instance => __instance;

        internal static BleCommonOptT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleCommonOptT(native.ToPointer(), skipVTables);
        }

        internal static BleCommonOptT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleCommonOptT(native, skipVTables);
        }

        private BleCommonOptT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private BleCommonOptT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NrfBleDriver.BleCommonOptT.__Internal*) native;
        }

        public BleCommonOptT(global::NrfBleDriver.BleCommonOptT __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>Parameters for controlling PA and LNA pin toggling.</summary>
        public global::NrfBleDriver.BleCommonOptPaLnaT PaLna
        {
            get
            {
                return global::NrfBleDriver.BleCommonOptPaLnaT.__CreateInstance(__instance.pa_lna);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.pa_lna = *(global::NrfBleDriver.BleCommonOptPaLnaT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Parameters for enabling extended connection events.</summary>
        public global::NrfBleDriver.BleCommonOptConnEvtExtT ConnEvtExt
        {
            get
            {
                return global::NrfBleDriver.BleCommonOptConnEvtExtT.__CreateInstance(__instance.conn_evt_ext);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.conn_evt_ext = *(global::NrfBleDriver.BleCommonOptConnEvtExtT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Common BLE Option type, wrapping the module specific options.</summary>
    public unsafe partial struct BleOptT
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleCommonOptT.__Internal common_opt;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptT.__Internal gap_opt;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_opt_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        private BleOptT.__Internal __instance;
        internal BleOptT.__Internal __Instance => __instance;

        internal static BleOptT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleOptT(native.ToPointer(), skipVTables);
        }

        internal static BleOptT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleOptT(native, skipVTables);
        }

        private BleOptT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private BleOptT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NrfBleDriver.BleOptT.__Internal*) native;
        }

        public BleOptT(global::NrfBleDriver.BleOptT __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>COMMON options, opt_id inseries.</summary>
        public global::NrfBleDriver.BleCommonOptT CommonOpt;

        /// <summary>GAP option, opt_id inseries.</summary>
        public global::NrfBleDriver.BleGapOptT GapOpt;
    }

    /// <summary>BLE connection configuration type, wrapping the module specific configurations, set with</summary>
    /// <remarks>
    /// <para>Connection configurations don't have to be set.</para>
    /// <para>In the case that no configurations has been set, or fewer connection configurations has been set than enabled connections,</para>
    /// <para>the default connection configuration will be automatically added for the remaining connections.</para>
    /// <para>When creating connections with the default configuration,should be used in</para>
    /// <para>place ofSeeand</para>
    /// <para>s</para>
    /// </remarks>
    public unsafe partial class BleConnCfgT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 10)]
        public partial struct __Internal
        {
            internal byte conn_cfg_tag;
            internal global::NrfBleDriver.BleConnCfgT.Params.__Internal @params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_conn_cfg_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Params
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapConnCfgT.__Internal gap_conn_cfg;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcConnCfgT.__Internal gattc_conn_cfg;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattsConnCfgT.__Internal gatts_conn_cfg;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattConnCfgT.__Internal gatt_conn_cfg;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capConnCfgT.__Internal l2cap_conn_cfg;

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-params>@ble_conn_cfg_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Params.__Internal __instance;
            internal Params.__Internal __Instance => __instance;

            internal static Params __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Params(native.ToPointer(), skipVTables);
            }

            internal static Params __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Params(native, skipVTables);
            }

            private Params(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Params(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleConnCfgT.Params.__Internal*) native;
            }

            public Params(global::NrfBleDriver.BleConnCfgT.Params __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>GAP connection configuration, cfg_id is</summary>
            public global::NrfBleDriver.BleGapConnCfgT GapConnCfg
            {
                get
                {
                    return global::NrfBleDriver.BleGapConnCfgT.__CreateInstance(__instance.gap_conn_cfg);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.gap_conn_cfg = *(global::NrfBleDriver.BleGapConnCfgT.__Internal*) value.__Instance;
                }
            }

            /// <summary>GATTC connection configuration, cfg_id is</summary>
            public global::NrfBleDriver.BleGattcConnCfgT GattcConnCfg
            {
                get
                {
                    return global::NrfBleDriver.BleGattcConnCfgT.__CreateInstance(__instance.gattc_conn_cfg);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.gattc_conn_cfg = *(global::NrfBleDriver.BleGattcConnCfgT.__Internal*) value.__Instance;
                }
            }

            /// <summary>GATTS connection configuration, cfg_id is</summary>
            public global::NrfBleDriver.BleGattsConnCfgT GattsConnCfg
            {
                get
                {
                    return global::NrfBleDriver.BleGattsConnCfgT.__CreateInstance(__instance.gatts_conn_cfg);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.gatts_conn_cfg = *(global::NrfBleDriver.BleGattsConnCfgT.__Internal*) value.__Instance;
                }
            }

            /// <summary>GATT connection configuration, cfg_id is</summary>
            public global::NrfBleDriver.BleGattConnCfgT GattConnCfg
            {
                get
                {
                    return global::NrfBleDriver.BleGattConnCfgT.__CreateInstance(__instance.gatt_conn_cfg);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.gatt_conn_cfg = *(global::NrfBleDriver.BleGattConnCfgT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP connection configuration, cfg_id is</summary>
            public global::NrfBleDriver.BleL2capConnCfgT L2capConnCfg
            {
                get
                {
                    return global::NrfBleDriver.BleL2capConnCfgT.__CreateInstance(__instance.l2cap_conn_cfg);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.l2cap_conn_cfg = *(global::NrfBleDriver.BleL2capConnCfgT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleConnCfgT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleConnCfgT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleConnCfgT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleConnCfgT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleConnCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleConnCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleConnCfgT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleConnCfgT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleConnCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleConnCfgT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleConnCfgT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleConnCfgT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleConnCfgT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleConnCfgT(global::NrfBleDriver.BleConnCfgT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleConnCfgT.__Internal*) __Instance) = *((global::NrfBleDriver.BleConnCfgT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The application chosen tag it can use with theandcalls to select this configuration when creating a connection.</para>
        /// <para>Must be different for all connection configurations added and not</para>
        /// </summary>
        public byte ConnCfgTag
        {
            get
            {
                return ((__Internal*)__Instance)->conn_cfg_tag;
            }

            set
            {
                ((__Internal*)__Instance)->conn_cfg_tag = value;
            }
        }

        /// <summary>Connection configuration union.</summary>
        public global::NrfBleDriver.BleConnCfgT.Params @params
        {
            get
            {
                return global::NrfBleDriver.BleConnCfgT.Params.__CreateInstance(((__Internal*)__Instance)->@params);
            }

            set
            {
                ((__Internal*)__Instance)->@params = value.__Instance;
            }
        }
    }

    /// <summary>Configuration of Vendor Specific UUIDs, set with</summary>
    /// <remarks>::NRF_ERROR_INVALID_PARAM Too many UUIDs configured.</remarks>
    public unsafe partial class BleCommonCfgVsUuidT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte vs_uuid_count;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_common_cfg_vs_uuid_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonCfgVsUuidT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleCommonCfgVsUuidT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleCommonCfgVsUuidT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleCommonCfgVsUuidT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleCommonCfgVsUuidT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleCommonCfgVsUuidT(native.ToPointer(), skipVTables);
        }

        internal static BleCommonCfgVsUuidT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleCommonCfgVsUuidT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleCommonCfgVsUuidT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleCommonCfgVsUuidT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleCommonCfgVsUuidT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleCommonCfgVsUuidT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleCommonCfgVsUuidT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonCfgVsUuidT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleCommonCfgVsUuidT(global::NrfBleDriver.BleCommonCfgVsUuidT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleCommonCfgVsUuidT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleCommonCfgVsUuidT.__Internal*) __Instance) = *((global::NrfBleDriver.BleCommonCfgVsUuidT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Number of 128-bit Vendor Specific UUID bases to allocate memory for.</para>
        /// <para>Default value isMaximum value is</para>
        /// </summary>
        public byte VsUuidCount
        {
            get
            {
                return ((__Internal*)__Instance)->vs_uuid_count;
            }

            set
            {
                ((__Internal*)__Instance)->vs_uuid_count = value;
            }
        }
    }

    /// <summary>Common BLE Configuration type, wrapping the common configurations.</summary>
    public unsafe partial struct BleCommonCfgT
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleCommonCfgVsUuidT.__Internal vs_uuid_cfg;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_common_cfg_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        private BleCommonCfgT.__Internal __instance;
        internal BleCommonCfgT.__Internal __Instance => __instance;

        internal static BleCommonCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleCommonCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleCommonCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleCommonCfgT(native, skipVTables);
        }

        private BleCommonCfgT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private BleCommonCfgT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NrfBleDriver.BleCommonCfgT.__Internal*) native;
        }

        public BleCommonCfgT(global::NrfBleDriver.BleCommonCfgT __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>Vendor specific UUID configuration, cfg_id is</summary>
        public global::NrfBleDriver.BleCommonCfgVsUuidT VsUuidCfg
        {
            get
            {
                return global::NrfBleDriver.BleCommonCfgVsUuidT.__CreateInstance(__instance.vs_uuid_cfg);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.vs_uuid_cfg = *(global::NrfBleDriver.BleCommonCfgVsUuidT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>BLE Configuration type, wrapping the module specific configurations.</summary>
    public unsafe partial struct BleCfgT
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleConnCfgT.__Internal conn_cfg;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleCommonCfgT.__Internal common_cfg;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapCfgT.__Internal gap_cfg;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGattsCfgT.__Internal gatts_cfg;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_cfg_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        private BleCfgT.__Internal __instance;
        internal BleCfgT.__Internal __Instance => __instance;

        internal static BleCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleCfgT(native, skipVTables);
        }

        private BleCfgT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private BleCfgT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NrfBleDriver.BleCfgT.__Internal*) native;
        }

        public BleCfgT(global::NrfBleDriver.BleCfgT __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>Connection specific configurations, cfg_id inseries.</summary>
        public global::NrfBleDriver.BleConnCfgT ConnCfg
        {
            get
            {
                return global::NrfBleDriver.BleConnCfgT.__CreateInstance(__instance.conn_cfg);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.conn_cfg = *(global::NrfBleDriver.BleConnCfgT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Global common configurations, cfg_id inseries.</summary>
        public global::NrfBleDriver.BleCommonCfgT CommonCfg;

        /// <summary>Global GAP configurations, cfg_id inseries.</summary>
        public global::NrfBleDriver.BleGapCfgT GapCfg;

        /// <summary>Global GATTS configuration, cfg_id inseries.</summary>
        public global::NrfBleDriver.BleGattsCfgT GattsCfg;
    }

    public unsafe partial class ble
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_enable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleEnable(__IntPtr adapter, uint* p_app_ram_base);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_cfg_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleCfgSet(__IntPtr adapter, uint cfg_id, __IntPtr p_cfg, uint app_ram_base);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_evt_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleEvtGet(__IntPtr adapter, byte* p_dest, ushort* p_len);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_uuid_vs_add", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleUuidVsAdd(__IntPtr adapter, __IntPtr p_vs_uuid, byte* p_uuid_type);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_uuid_decode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleUuidDecode(__IntPtr adapter, byte uuid_le_len, byte* p_uuid_le, __IntPtr p_uuid);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_uuid_encode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleUuidEncode(__IntPtr adapter, __IntPtr p_uuid, byte* p_uuid_le_len, byte* p_uuid_le);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_version_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleVersionGet(__IntPtr adapter, __IntPtr p_version);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_user_mem_reply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleUserMemReply(__IntPtr adapter, ushort conn_handle, __IntPtr p_block);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_opt_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleOptSet(__IntPtr adapter, uint opt_id, __IntPtr p_opt);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_opt_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleOptGet(__IntPtr adapter, uint opt_id, __IntPtr p_opt);
        }

        public static uint SdBleEnable(global::NrfBleDriver.AdapterT adapter, ref uint p_app_ram_base)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (uint* __p_app_ram_base1 = &p_app_ram_base)
            {
                var __arg1 = __p_app_ram_base1;
                var __ret = __Internal.SdBleEnable(__arg0, __arg1);
                return __ret;
            }
        }

        public static uint SdBleCfgSet(global::NrfBleDriver.AdapterT adapter, uint cfg_id, global::NrfBleDriver.BleCfgT p_cfg, uint app_ram_base)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var ____arg2 = p_cfg.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var __ret = __Internal.SdBleCfgSet(__arg0, cfg_id, __arg2, app_ram_base);
            return __ret;
        }

        public static uint SdBleEvtGet(global::NrfBleDriver.AdapterT adapter, byte* p_dest, ref ushort p_len)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (ushort* __p_len2 = &p_len)
            {
                var __arg2 = __p_len2;
                var __ret = __Internal.SdBleEvtGet(__arg0, p_dest, __arg2);
                return __ret;
            }
        }

        public static uint SdBleUuidVsAdd(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleUuid128T p_vs_uuid, byte* p_uuid_type)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_vs_uuid is null ? __IntPtr.Zero : p_vs_uuid.__Instance;
            var __ret = __Internal.SdBleUuidVsAdd(__arg0, __arg1, p_uuid_type);
            return __ret;
        }

        public static uint SdBleUuidDecode(global::NrfBleDriver.AdapterT adapter, byte uuid_le_len, byte* p_uuid_le, global::NrfBleDriver.BleUuidT p_uuid)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg3 = p_uuid is null ? __IntPtr.Zero : p_uuid.__Instance;
            var __ret = __Internal.SdBleUuidDecode(__arg0, uuid_le_len, p_uuid_le, __arg3);
            return __ret;
        }

        public static uint SdBleUuidEncode(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleUuidT p_uuid, byte* p_uuid_le_len, byte* p_uuid_le)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_uuid is null ? __IntPtr.Zero : p_uuid.__Instance;
            var __ret = __Internal.SdBleUuidEncode(__arg0, __arg1, p_uuid_le_len, p_uuid_le);
            return __ret;
        }

        public static uint SdBleVersionGet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleVersionT p_version)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_version is null ? __IntPtr.Zero : p_version.__Instance;
            var __ret = __Internal.SdBleVersionGet(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleUserMemReply(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleUserMemBlockT p_block)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_block is null ? __IntPtr.Zero : p_block.__Instance;
            var __ret = __Internal.SdBleUserMemReply(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleOptSet(global::NrfBleDriver.AdapterT adapter, uint opt_id, global::NrfBleDriver.BleOptT p_opt)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var ____arg2 = p_opt.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var __ret = __Internal.SdBleOptSet(__arg0, opt_id, __arg2);
            return __ret;
        }

        public static uint SdBleOptGet(global::NrfBleDriver.AdapterT adapter, uint opt_id, global::NrfBleDriver.BleOptT p_opt)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var ____arg2 = p_opt.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var __ret = __Internal.SdBleOptGet(__arg0, opt_id, __arg2);
            return __ret;
        }
    }
}
