// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace NrfBleDriver
{
    /// <summary>L2CAP API SVC numbers.</summary>
    public enum BLE_L2CAP_SVCS
    {
        /// <summary>Set up an L2CAP channel.</summary>
        SD_BLE_L2CAP_CH_SETUP = 184,
        /// <summary>Release an L2CAP channel.</summary>
        SD_BLE_L2CAP_CH_RELEASE = 185,
        /// <summary>Receive an SDU on an L2CAP channel.</summary>
        SD_BLE_L2CAP_CH_RX = 186,
        /// <summary>Transmit an SDU on an L2CAP channel.</summary>
        SD_BLE_L2CAP_CH_TX = 187,
        /// <summary>Advanced SDU reception flow control.</summary>
        SD_BLE_L2CAP_CH_FLOW_CONTROL = 188
    }

    /// <summary>L2CAP Event IDs.</summary>
    public enum BLE_L2CAP_EVTS
    {
        /// <summary>
        /// <para>L2CAP Channel Setup Request event.</para>
        /// <para>See</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_SETUP_REQUEST = 112,
        /// <summary>
        /// <para>L2CAP Channel Setup Refused event.</para>
        /// <para>See</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_SETUP_REFUSED = 113,
        /// <summary>
        /// <para>L2CAP Channel Setup Completed event.</para>
        /// <para>See</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_SETUP = 114,
        /// <summary>
        /// <para>L2CAP Channel Released event.</para>
        /// <para>No additional event structure applies.</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_RELEASED = 115,
        /// <summary>
        /// <para>L2CAP Channel SDU data buffer released event.</para>
        /// <para>See</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_SDU_BUF_RELEASED = 116,
        /// <summary>
        /// <para>L2CAP Channel Credit received.</para>
        /// <para>See</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_CREDIT = 117,
        /// <summary>
        /// <para>L2CAP Channel SDU received.</para>
        /// <para>See</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_RX = 118,
        /// <summary>
        /// <para>L2CAP Channel SDU transmitted.</para>
        /// <para>See</para>
        /// </summary>
        BLE_L2CAP_EVT_CH_TX = 119
    }

    /// <summary>BLE L2CAP connection configuration parameters, set with</summary>
    /// <remarks>
    /// <para>These parameters are set per connection, so all L2CAP channels created on this connection</para>
    /// <para>will have the same parameters.</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  One or more of the following is true:</para>
    /// <para>- rx_mps is smaller than- tx_mps is smaller than- ch_count is greater than</para>
    /// <para>::NRF_ERROR_NO_MEM         rx_mps or tx_mps is set too high.</para>
    /// </remarks>
    /// <summary>L2CAP channel RX parameters.</summary>
    /// <summary>L2CAP channel setup parameters.</summary>
    /// <summary>L2CAP channel TX parameters.</summary>
    /// <summary>L2CAP Channel Setup Request event.</summary>
    /// <summary>L2CAP Channel Setup Refused event.</summary>
    /// <summary>L2CAP Channel Setup Completed event.</summary>
    /// <summary>L2CAP Channel SDU Data Buffer Released event.</summary>
    /// <summary>L2CAP Channel Credit received event.</summary>
    /// <summary>L2CAP Channel received SDU event.</summary>
    /// <summary>L2CAP Channel transmitted SDU event.</summary>
    /// <summary>L2CAP event structure.</summary>
    /// <summary>BLE L2CAP connection configuration parameters, set with</summary>
    /// <remarks>
    /// <para>These parameters are set per connection, so all L2CAP channels created on this connection</para>
    /// <para>will have the same parameters.</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  One or more of the following is true:</para>
    /// <para>- rx_mps is smaller than- tx_mps is smaller than- ch_count is greater than</para>
    /// <para>::NRF_ERROR_NO_MEM         rx_mps or tx_mps is set too high.</para>
    /// </remarks>
    public unsafe partial class BleL2capConnCfgT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort rx_mps;
            internal ushort tx_mps;
            internal byte rx_queue_size;
            internal byte tx_queue_size;
            internal byte ch_count;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_conn_cfg_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capConnCfgT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capConnCfgT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capConnCfgT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capConnCfgT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capConnCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capConnCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capConnCfgT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capConnCfgT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capConnCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capConnCfgT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capConnCfgT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capConnCfgT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capConnCfgT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capConnCfgT(global::NrfBleDriver.BleL2capConnCfgT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capConnCfgT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capConnCfgT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The maximum L2CAP PDU payload size, in bytes, that L2CAP shall</para>
        /// <para>be able to receive on L2CAP channels on connections with this</para>
        /// <para>configuration. The minimum value is</para>
        /// </summary>
        public ushort RxMps
        {
            get
            {
                return ((__Internal*)__Instance)->rx_mps;
            }

            set
            {
                ((__Internal*)__Instance)->rx_mps = value;
            }
        }

        /// <summary>
        /// <para>The maximum L2CAP PDU payload size, in bytes, that L2CAP shall</para>
        /// <para>be able to transmit on L2CAP channels on connections with this</para>
        /// <para>configuration. The minimum value is</para>
        /// </summary>
        public ushort TxMps
        {
            get
            {
                return ((__Internal*)__Instance)->tx_mps;
            }

            set
            {
                ((__Internal*)__Instance)->tx_mps = value;
            }
        }

        /// <summary>
        /// <para>Number of SDU data buffers that can be queued for reception per</para>
        /// <para>L2CAP channel. The minimum value is one.</para>
        /// </summary>
        public byte RxQueueSize
        {
            get
            {
                return ((__Internal*)__Instance)->rx_queue_size;
            }

            set
            {
                ((__Internal*)__Instance)->rx_queue_size = value;
            }
        }

        /// <summary>
        /// <para>Number of SDU data buffers that can be queued for transmission</para>
        /// <para>per L2CAP channel. The minimum value is one.</para>
        /// </summary>
        public byte TxQueueSize
        {
            get
            {
                return ((__Internal*)__Instance)->tx_queue_size;
            }

            set
            {
                ((__Internal*)__Instance)->tx_queue_size = value;
            }
        }

        /// <summary>
        /// <para>Number of L2CAP channels the application can create per connection</para>
        /// <para>with this configuration. The default value is zero, the maximum</para>
        /// <para>value is</para>
        /// </summary>
        /// <remarks>
        /// <para>if this parameter is set to zero, all other parameters in</para>
        /// <para>are ignored.</para>
        /// </remarks>
        public byte ChCount
        {
            get
            {
                return ((__Internal*)__Instance)->ch_count;
            }

            set
            {
                ((__Internal*)__Instance)->ch_count = value;
            }
        }
    }

    /// <summary>L2CAP channel RX parameters.</summary>
    public unsafe partial class BleL2capChRxParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal ushort rx_mtu;
            internal ushort rx_mps;
            internal global::NrfBleDriver.BleDataT.__Internal sdu_buf;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_ch_rx_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capChRxParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capChRxParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capChRxParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capChRxParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capChRxParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capChRxParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capChRxParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capChRxParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capChRxParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capChRxParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capChRxParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capChRxParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capChRxParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capChRxParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capChRxParamsT(global::NrfBleDriver.BleL2capChRxParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capChRxParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capChRxParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capChRxParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The maximum L2CAP SDU size, in bytes, that L2CAP shall be able to</para>
        /// <para>receive on this L2CAP channel.</para>
        /// <para>- Must be equal to or greater than</para>
        /// </summary>
        public ushort RxMtu
        {
            get
            {
                return ((__Internal*)__Instance)->rx_mtu;
            }

            set
            {
                ((__Internal*)__Instance)->rx_mtu = value;
            }
        }

        /// <summary>
        /// <para>The maximum L2CAP PDU payload size, in bytes, that L2CAP shall be</para>
        /// <para>able to receive on this L2CAP channel.</para>
        /// <para>- Must be equal to or greater than- Must be equal to or less than</para>
        /// </summary>
        public ushort RxMps
        {
            get
            {
                return ((__Internal*)__Instance)->rx_mps;
            }

            set
            {
                ((__Internal*)__Instance)->rx_mps = value;
            }
        }

        /// <summary>
        /// <para>SDU data buffer for reception.</para>
        /// <para>- Ifis non-NULL, initial credits are</para>
        /// <para>issued to the peer.</para>
        /// <para>- Ifis NULL, no initial credits are</para>
        /// <para>issued to the peer.</para>
        /// </summary>
        public global::NrfBleDriver.BleDataT SduBuf
        {
            get
            {
                return global::NrfBleDriver.BleDataT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sdu_buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sdu_buf = *(global::NrfBleDriver.BleDataT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>L2CAP channel setup parameters.</summary>
    public unsafe partial class BleL2capChSetupParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleL2capChRxParamsT.__Internal rx_params;
            internal ushort le_psm;
            internal ushort status;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_ch_setup_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capChSetupParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capChSetupParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capChSetupParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capChSetupParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capChSetupParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capChSetupParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capChSetupParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capChSetupParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capChSetupParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capChSetupParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capChSetupParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capChSetupParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capChSetupParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capChSetupParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capChSetupParamsT(global::NrfBleDriver.BleL2capChSetupParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capChSetupParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capChSetupParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capChSetupParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>L2CAP channel RX parameters.</summary>
        public global::NrfBleDriver.BleL2capChRxParamsT RxParams
        {
            get
            {
                return global::NrfBleDriver.BleL2capChRxParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->rx_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->rx_params = *(global::NrfBleDriver.BleL2capChRxParamsT.__Internal*) value.__Instance;
            }
        }

        /// <summary>
        /// <para>LE Protocol/Service Multiplexer. Used when requesting</para>
        /// <para>setup of an L2CAP channel, ignored otherwise.</para>
        /// </summary>
        public ushort LePsm
        {
            get
            {
                return ((__Internal*)__Instance)->le_psm;
            }

            set
            {
                ((__Internal*)__Instance)->le_psm = value;
            }
        }

        /// <summary>
        /// <para>Status code, seeUsed when replying to a setup request of an L2CAP</para>
        /// <para>channel, ignored otherwise.</para>
        /// </summary>
        public ushort Status
        {
            get
            {
                return ((__Internal*)__Instance)->status;
            }

            set
            {
                ((__Internal*)__Instance)->status = value;
            }
        }
    }

    /// <summary>L2CAP channel TX parameters.</summary>
    public unsafe partial class BleL2capChTxParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort tx_mtu;
            internal ushort peer_mps;
            internal ushort tx_mps;
            internal ushort credits;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_ch_tx_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capChTxParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capChTxParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capChTxParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capChTxParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capChTxParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capChTxParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capChTxParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capChTxParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capChTxParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capChTxParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capChTxParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capChTxParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capChTxParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capChTxParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capChTxParamsT(global::NrfBleDriver.BleL2capChTxParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capChTxParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capChTxParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capChTxParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The maximum L2CAP SDU size, in bytes, that L2CAP is able to</para>
        /// <para>transmit on this L2CAP channel.</para>
        /// </summary>
        public ushort TxMtu
        {
            get
            {
                return ((__Internal*)__Instance)->tx_mtu;
            }

            set
            {
                ((__Internal*)__Instance)->tx_mtu = value;
            }
        }

        /// <summary>
        /// <para>The maximum L2CAP PDU payload size, in bytes, that the peer is</para>
        /// <para>able to receive on this L2CAP channel.</para>
        /// </summary>
        public ushort PeerMps
        {
            get
            {
                return ((__Internal*)__Instance)->peer_mps;
            }

            set
            {
                ((__Internal*)__Instance)->peer_mps = value;
            }
        }

        /// <summary>
        /// <para>The maximum L2CAP PDU payload size, in bytes, that L2CAP is able</para>
        /// <para>to transmit on this L2CAP channel. This is effective tx_mps,</para>
        /// <para>selected by the SoftDevice as</para>
        /// <para>MIN()</para>
        /// </summary>
        public ushort TxMps
        {
            get
            {
                return ((__Internal*)__Instance)->tx_mps;
            }

            set
            {
                ((__Internal*)__Instance)->tx_mps = value;
            }
        }

        /// <summary>Initial credits given by the peer.</summary>
        public ushort Credits
        {
            get
            {
                return ((__Internal*)__Instance)->credits;
            }

            set
            {
                ((__Internal*)__Instance)->credits = value;
            }
        }
    }

    /// <summary>L2CAP Channel Setup Request event.</summary>
    public unsafe partial class BleL2capEvtChSetupRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 10)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleL2capChTxParamsT.__Internal tx_params;
            internal ushort le_psm;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_ch_setup_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSetupRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSetupRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtChSetupRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtChSetupRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtChSetupRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtChSetupRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtChSetupRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtChSetupRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtChSetupRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtChSetupRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtChSetupRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtChSetupRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtChSetupRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSetupRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtChSetupRequestT(global::NrfBleDriver.BleL2capEvtChSetupRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSetupRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtChSetupRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtChSetupRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>L2CAP channel TX parameters.</summary>
        public global::NrfBleDriver.BleL2capChTxParamsT TxParams
        {
            get
            {
                return global::NrfBleDriver.BleL2capChTxParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->tx_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->tx_params = *(global::NrfBleDriver.BleL2capChTxParamsT.__Internal*) value.__Instance;
            }
        }

        /// <summary>LE Protocol/Service Multiplexer.</summary>
        public ushort LePsm
        {
            get
            {
                return ((__Internal*)__Instance)->le_psm;
            }

            set
            {
                ((__Internal*)__Instance)->le_psm = value;
            }
        }
    }

    /// <summary>L2CAP Channel Setup Refused event.</summary>
    public unsafe partial class BleL2capEvtChSetupRefusedT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal byte source;
            internal ushort status;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_ch_setup_refused_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSetupRefusedT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSetupRefusedT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtChSetupRefusedT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtChSetupRefusedT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtChSetupRefusedT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtChSetupRefusedT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtChSetupRefusedT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtChSetupRefusedT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtChSetupRefusedT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtChSetupRefusedT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtChSetupRefusedT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtChSetupRefusedT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtChSetupRefusedT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSetupRefusedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtChSetupRefusedT(global::NrfBleDriver.BleL2capEvtChSetupRefusedT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSetupRefusedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtChSetupRefusedT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtChSetupRefusedT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Source, see</summary>
        public byte Source
        {
            get
            {
                return ((__Internal*)__Instance)->source;
            }

            set
            {
                ((__Internal*)__Instance)->source = value;
            }
        }

        /// <summary>Status code, see</summary>
        public ushort Status
        {
            get
            {
                return ((__Internal*)__Instance)->status;
            }

            set
            {
                ((__Internal*)__Instance)->status = value;
            }
        }
    }

    /// <summary>L2CAP Channel Setup Completed event.</summary>
    public unsafe partial class BleL2capEvtChSetupT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleL2capChTxParamsT.__Internal tx_params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_ch_setup_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSetupT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSetupT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtChSetupT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtChSetupT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtChSetupT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtChSetupT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtChSetupT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtChSetupT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtChSetupT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtChSetupT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtChSetupT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtChSetupT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtChSetupT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSetupT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtChSetupT(global::NrfBleDriver.BleL2capEvtChSetupT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSetupT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtChSetupT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtChSetupT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>L2CAP channel TX parameters.</summary>
        public global::NrfBleDriver.BleL2capChTxParamsT TxParams
        {
            get
            {
                return global::NrfBleDriver.BleL2capChTxParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->tx_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->tx_params = *(global::NrfBleDriver.BleL2capChTxParamsT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>L2CAP Channel SDU Data Buffer Released event.</summary>
    public unsafe partial class BleL2capEvtChSduBufReleasedT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleDataT.__Internal sdu_buf;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_ch_sdu_buf_released_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSduBufReleasedT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChSduBufReleasedT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtChSduBufReleasedT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtChSduBufReleasedT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtChSduBufReleasedT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtChSduBufReleasedT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtChSduBufReleasedT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtChSduBufReleasedT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtChSduBufReleasedT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtChSduBufReleasedT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtChSduBufReleasedT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtChSduBufReleasedT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtChSduBufReleasedT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSduBufReleasedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtChSduBufReleasedT(global::NrfBleDriver.BleL2capEvtChSduBufReleasedT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChSduBufReleasedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtChSduBufReleasedT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtChSduBufReleasedT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Returned reception or transmission SDU data buffer. The SoftDevice</para>
        /// <para>returns SDU data buffers supplied by the application, which have</para>
        /// <para>not yet been returned previously via aor</para>
        /// <para>event.</para>
        /// </summary>
        public global::NrfBleDriver.BleDataT SduBuf
        {
            get
            {
                return global::NrfBleDriver.BleDataT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sdu_buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sdu_buf = *(global::NrfBleDriver.BleDataT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>L2CAP Channel Credit received event.</summary>
    public unsafe partial class BleL2capEvtChCreditT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal ushort credits;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_ch_credit_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChCreditT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChCreditT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtChCreditT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtChCreditT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtChCreditT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtChCreditT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtChCreditT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtChCreditT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtChCreditT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtChCreditT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtChCreditT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtChCreditT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtChCreditT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChCreditT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtChCreditT(global::NrfBleDriver.BleL2capEvtChCreditT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChCreditT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtChCreditT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtChCreditT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Additional credits given by the peer.</summary>
        public ushort Credits
        {
            get
            {
                return ((__Internal*)__Instance)->credits;
            }

            set
            {
                ((__Internal*)__Instance)->credits = value;
            }
        }
    }

    /// <summary>L2CAP Channel received SDU event.</summary>
    public unsafe partial class BleL2capEvtChRxT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal ushort sdu_len;
            internal global::NrfBleDriver.BleDataT.__Internal sdu_buf;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_ch_rx_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChRxT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChRxT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtChRxT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtChRxT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtChRxT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtChRxT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtChRxT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtChRxT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtChRxT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtChRxT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtChRxT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtChRxT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtChRxT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChRxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtChRxT(global::NrfBleDriver.BleL2capEvtChRxT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChRxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtChRxT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtChRxT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Total SDU length, in bytes.</summary>
        public ushort SduLen
        {
            get
            {
                return ((__Internal*)__Instance)->sdu_len;
            }

            set
            {
                ((__Internal*)__Instance)->sdu_len = value;
            }
        }

        /// <summary>SDU data buffer.</summary>
        /// <remarks>
        /// <para>If there is not enough space in the buffer</para>
        /// <para>(sdu_buf.len&lt;sdu_len) then the rest of the SDU will be</para>
        /// <para>silently discarded by the SoftDevice.</para>
        /// </remarks>
        public global::NrfBleDriver.BleDataT SduBuf
        {
            get
            {
                return global::NrfBleDriver.BleDataT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sdu_buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sdu_buf = *(global::NrfBleDriver.BleDataT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>L2CAP Channel transmitted SDU event.</summary>
    public unsafe partial class BleL2capEvtChTxT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleDataT.__Internal sdu_buf;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_ch_tx_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChTxT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtChTxT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtChTxT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtChTxT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtChTxT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtChTxT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtChTxT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtChTxT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtChTxT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtChTxT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtChTxT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtChTxT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtChTxT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChTxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtChTxT(global::NrfBleDriver.BleL2capEvtChTxT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtChTxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtChTxT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtChTxT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>SDU data buffer.</summary>
        public global::NrfBleDriver.BleDataT SduBuf
        {
            get
            {
                return global::NrfBleDriver.BleDataT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sdu_buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sdu_buf = *(global::NrfBleDriver.BleDataT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>L2CAP event structure.</summary>
    public unsafe partial class BleL2capEvtT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal ushort local_cid;
            internal global::NrfBleDriver.BleL2capEvtT.Params.__Internal @params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_l2cap_evt_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Params
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtChSetupRequestT.__Internal ch_setup_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtChSetupRefusedT.__Internal ch_setup_refused;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtChSetupT.__Internal ch_setup;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtChSduBufReleasedT.__Internal ch_sdu_buf_released;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtChCreditT.__Internal credit;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtChRxT.__Internal rx;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleL2capEvtChTxT.__Internal tx;

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-params>@ble_l2cap_evt_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Params.__Internal __instance;
            internal Params.__Internal __Instance => __instance;

            internal static Params __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Params(native.ToPointer(), skipVTables);
            }

            internal static Params __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Params(native, skipVTables);
            }

            private Params(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Params(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleL2capEvtT.Params.__Internal*) native;
            }

            public Params(global::NrfBleDriver.BleL2capEvtT.Params __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>L2CAP Channel Setup Request Event Parameters.</summary>
            public global::NrfBleDriver.BleL2capEvtChSetupRequestT ChSetupRequest
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtChSetupRequestT.__CreateInstance(__instance.ch_setup_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.ch_setup_request = *(global::NrfBleDriver.BleL2capEvtChSetupRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP Channel Setup Refused Event Parameters.</summary>
            public global::NrfBleDriver.BleL2capEvtChSetupRefusedT ChSetupRefused
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtChSetupRefusedT.__CreateInstance(__instance.ch_setup_refused);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.ch_setup_refused = *(global::NrfBleDriver.BleL2capEvtChSetupRefusedT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP Channel Setup Completed Event Parameters.</summary>
            public global::NrfBleDriver.BleL2capEvtChSetupT ChSetup
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtChSetupT.__CreateInstance(__instance.ch_setup);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.ch_setup = *(global::NrfBleDriver.BleL2capEvtChSetupT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP Channel SDU Data Buffer Released Event Parameters.</summary>
            public global::NrfBleDriver.BleL2capEvtChSduBufReleasedT ChSduBufReleased
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtChSduBufReleasedT.__CreateInstance(__instance.ch_sdu_buf_released);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.ch_sdu_buf_released = *(global::NrfBleDriver.BleL2capEvtChSduBufReleasedT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP Channel Credit Received Event Parameters.</summary>
            public global::NrfBleDriver.BleL2capEvtChCreditT Credit
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtChCreditT.__CreateInstance(__instance.credit);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.credit = *(global::NrfBleDriver.BleL2capEvtChCreditT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP Channel SDU Received Event Parameters.</summary>
            public global::NrfBleDriver.BleL2capEvtChRxT Rx
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtChRxT.__CreateInstance(__instance.rx);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.rx = *(global::NrfBleDriver.BleL2capEvtChRxT.__Internal*) value.__Instance;
                }
            }

            /// <summary>L2CAP Channel SDU Transmitted Event Parameters.</summary>
            public global::NrfBleDriver.BleL2capEvtChTxT Tx
            {
                get
                {
                    return global::NrfBleDriver.BleL2capEvtChTxT.__CreateInstance(__instance.tx);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.tx = *(global::NrfBleDriver.BleL2capEvtChTxT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleL2capEvtT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleL2capEvtT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleL2capEvtT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleL2capEvtT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleL2capEvtT(native.ToPointer(), skipVTables);
        }

        internal static BleL2capEvtT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleL2capEvtT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleL2capEvtT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleL2capEvtT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleL2capEvtT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleL2capEvtT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleL2capEvtT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleL2capEvtT(global::NrfBleDriver.BleL2capEvtT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleL2capEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleL2capEvtT.__Internal*) __Instance) = *((global::NrfBleDriver.BleL2capEvtT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle on which the event occured.</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>
        /// <para>Local Channel ID of the L2CAP channel, or</para>
        /// <para>if not present.</para>
        /// </summary>
        public ushort LocalCid
        {
            get
            {
                return ((__Internal*)__Instance)->local_cid;
            }

            set
            {
                ((__Internal*)__Instance)->local_cid = value;
            }
        }

        /// <summary>Event Parameters.</summary>
        public global::NrfBleDriver.BleL2capEvtT.Params @params
        {
            get
            {
                return global::NrfBleDriver.BleL2capEvtT.Params.__CreateInstance(((__Internal*)__Instance)->@params);
            }

            set
            {
                ((__Internal*)__Instance)->@params = value.__Instance;
            }
        }
    }

    public unsafe partial class ble_l2cap
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_l2cap_ch_setup", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleL2capChSetup(__IntPtr adapter, ushort conn_handle, ushort* p_local_cid, __IntPtr p_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_l2cap_ch_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleL2capChRelease(__IntPtr adapter, ushort conn_handle, ushort local_cid);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_l2cap_ch_rx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleL2capChRx(__IntPtr adapter, ushort conn_handle, ushort local_cid, __IntPtr p_sdu_buf);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_l2cap_ch_tx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleL2capChTx(__IntPtr adapter, ushort conn_handle, ushort local_cid, __IntPtr p_sdu_buf);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_l2cap_ch_flow_control", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleL2capChFlowControl(__IntPtr adapter, ushort conn_handle, ushort local_cid, ushort credits, ushort* p_credits);
        }

        public static uint SdBleL2capChSetup(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ref ushort p_local_cid, global::NrfBleDriver.BleL2capChSetupParamsT p_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (ushort* __p_local_cid2 = &p_local_cid)
            {
                var __arg2 = __p_local_cid2;
                var __arg3 = p_params is null ? __IntPtr.Zero : p_params.__Instance;
                var __ret = __Internal.SdBleL2capChSetup(__arg0, conn_handle, __arg2, __arg3);
                return __ret;
            }
        }

        public static uint SdBleL2capChRelease(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort local_cid)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleL2capChRelease(__arg0, conn_handle, local_cid);
            return __ret;
        }

        public static uint SdBleL2capChRx(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort local_cid, global::NrfBleDriver.BleDataT p_sdu_buf)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg3 = p_sdu_buf is null ? __IntPtr.Zero : p_sdu_buf.__Instance;
            var __ret = __Internal.SdBleL2capChRx(__arg0, conn_handle, local_cid, __arg3);
            return __ret;
        }

        public static uint SdBleL2capChTx(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort local_cid, global::NrfBleDriver.BleDataT p_sdu_buf)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg3 = p_sdu_buf is null ? __IntPtr.Zero : p_sdu_buf.__Instance;
            var __ret = __Internal.SdBleL2capChTx(__arg0, conn_handle, local_cid, __arg3);
            return __ret;
        }

        public static uint SdBleL2capChFlowControl(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort local_cid, ushort credits, ref ushort p_credits)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (ushort* __p_credits4 = &p_credits)
            {
                var __arg4 = __p_credits4;
                var __ret = __Internal.SdBleL2capChFlowControl(__arg0, conn_handle, local_cid, credits, __arg4);
                return __ret;
            }
        }
    }
}
