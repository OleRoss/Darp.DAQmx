// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace NrfBleDriver
{
    /// <summary>GAP API SVC numbers.</summary>
    public enum BLE_GAP_SVCS
    {
        /// <summary>Set own Bluetooth Address.</summary>
        SD_BLE_GAP_ADDR_SET = 108,
        /// <summary>Get own Bluetooth Address.</summary>
        SD_BLE_GAP_ADDR_GET = 109,
        /// <summary>Set active whitelist.</summary>
        SD_BLE_GAP_WHITELIST_SET = 110,
        /// <summary>Set device identity list.</summary>
        SD_BLE_GAP_DEVICE_IDENTITIES_SET = 111,
        /// <summary>Set Privacy settings</summary>
        SD_BLE_GAP_PRIVACY_SET = 112,
        /// <summary>Get Privacy settings</summary>
        SD_BLE_GAP_PRIVACY_GET = 113,
        /// <summary>Set Advertising Data.</summary>
        SD_BLE_GAP_ADV_DATA_SET = 114,
        /// <summary>Start Advertising.</summary>
        SD_BLE_GAP_ADV_START = 115,
        /// <summary>Stop Advertising.</summary>
        SD_BLE_GAP_ADV_STOP = 116,
        /// <summary>Connection Parameter Update.</summary>
        SD_BLE_GAP_CONN_PARAM_UPDATE = 117,
        /// <summary>Disconnect.</summary>
        SD_BLE_GAP_DISCONNECT = 118,
        /// <summary>Set TX Power.</summary>
        SD_BLE_GAP_TX_POWER_SET = 119,
        /// <summary>Set Appearance.</summary>
        SD_BLE_GAP_APPEARANCE_SET = 120,
        /// <summary>Get Appearance.</summary>
        SD_BLE_GAP_APPEARANCE_GET = 121,
        /// <summary>Set PPCP.</summary>
        SD_BLE_GAP_PPCP_SET = 122,
        /// <summary>Get PPCP.</summary>
        SD_BLE_GAP_PPCP_GET = 123,
        /// <summary>Set Device Name.</summary>
        SD_BLE_GAP_DEVICE_NAME_SET = 124,
        /// <summary>Get Device Name.</summary>
        SD_BLE_GAP_DEVICE_NAME_GET = 125,
        /// <summary>Initiate Pairing/Bonding.</summary>
        SD_BLE_GAP_AUTHENTICATE = 126,
        /// <summary>Reply with Security Parameters.</summary>
        SD_BLE_GAP_SEC_PARAMS_REPLY = 127,
        /// <summary>Reply with an authentication key.</summary>
        SD_BLE_GAP_AUTH_KEY_REPLY = 128,
        /// <summary>Reply with an LE Secure Connections DHKey.</summary>
        SD_BLE_GAP_LESC_DHKEY_REPLY = 129,
        /// <summary>Notify of a keypress during an authentication procedure.</summary>
        SD_BLE_GAP_KEYPRESS_NOTIFY = 130,
        /// <summary>Get the local LE Secure Connections OOB data.</summary>
        SD_BLE_GAP_LESC_OOB_DATA_GET = 131,
        /// <summary>Set the remote LE Secure Connections OOB data.</summary>
        SD_BLE_GAP_LESC_OOB_DATA_SET = 132,
        /// <summary>Initiate encryption procedure.</summary>
        SD_BLE_GAP_ENCRYPT = 133,
        /// <summary>Reply with Security Information.</summary>
        SD_BLE_GAP_SEC_INFO_REPLY = 134,
        /// <summary>Obtain connection security level.</summary>
        SD_BLE_GAP_CONN_SEC_GET = 135,
        /// <summary>Start reporting of changes in RSSI.</summary>
        SD_BLE_GAP_RSSI_START = 136,
        /// <summary>Stop reporting of changes in RSSI.</summary>
        SD_BLE_GAP_RSSI_STOP = 137,
        /// <summary>Start Scanning.</summary>
        SD_BLE_GAP_SCAN_START = 138,
        /// <summary>Stop Scanning.</summary>
        SD_BLE_GAP_SCAN_STOP = 139,
        /// <summary>Connect.</summary>
        SD_BLE_GAP_CONNECT = 140,
        /// <summary>Cancel ongoing connection procedure.</summary>
        SD_BLE_GAP_CONNECT_CANCEL = 141,
        /// <summary>Get the last RSSI sample.</summary>
        SD_BLE_GAP_RSSI_GET = 142,
        /// <summary>Initiate or respond to a PHY Update Procedure.</summary>
        SD_BLE_GAP_PHY_UPDATE = 143,
        /// <summary>Initiate or respond to a Data Length Update Procedure.</summary>
        SD_BLE_GAP_DATA_LENGTH_UPDATE = 144
    }

    /// <summary>
    /// <para>GAP Event IDs.</para>
    /// <para>IDs that uniquely identify an event coming from the stack to the application.</para>
    /// </summary>
    public enum BLE_GAP_EVTS
    {
        /// <summary>Connection established.See</summary>
        BLE_GAP_EVT_CONNECTED = 16,
        /// <summary>Disconnected from peer.See</summary>
        BLE_GAP_EVT_DISCONNECTED = 17,
        /// <summary>Connection Parameters updated.See</summary>
        BLE_GAP_EVT_CONN_PARAM_UPDATE = 18,
        /// <summary>Request to provide security parameters.Reply withSee</summary>
        BLE_GAP_EVT_SEC_PARAMS_REQUEST = 19,
        /// <summary>Request to provide security information.Reply withSee</summary>
        BLE_GAP_EVT_SEC_INFO_REQUEST = 20,
        /// <summary>Request to display a passkey to the user.In LESC Numeric Comparison, reply withSee</summary>
        BLE_GAP_EVT_PASSKEY_DISPLAY = 21,
        /// <summary>Notification of a keypress on the remote device.See</summary>
        BLE_GAP_EVT_KEY_PRESSED = 22,
        /// <summary>Request to provide an authentication key.Reply withSee</summary>
        BLE_GAP_EVT_AUTH_KEY_REQUEST = 23,
        /// <summary>Request to calculate an LE Secure Connections DHKey.Reply withSee</summary>
        BLE_GAP_EVT_LESC_DHKEY_REQUEST = 24,
        /// <summary>Authentication procedure completed with status.See</summary>
        BLE_GAP_EVT_AUTH_STATUS = 25,
        /// <summary>Connection security updated.See</summary>
        BLE_GAP_EVT_CONN_SEC_UPDATE = 26,
        /// <summary>Timeout expired.See</summary>
        BLE_GAP_EVT_TIMEOUT = 27,
        /// <summary>RSSI report.See</summary>
        BLE_GAP_EVT_RSSI_CHANGED = 28,
        /// <summary>Advertising report.See</summary>
        BLE_GAP_EVT_ADV_REPORT = 29,
        /// <summary>Security Request.See</summary>
        BLE_GAP_EVT_SEC_REQUEST = 30,
        /// <summary>Connection Parameter Update Request.Reply withSee</summary>
        BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST = 31,
        /// <summary>Scan request report.See</summary>
        BLE_GAP_EVT_SCAN_REQ_REPORT = 32,
        /// <summary>PHY Update Request.Reply withSee</summary>
        BLE_GAP_EVT_PHY_UPDATE_REQUEST = 33,
        /// <summary>PHY Update Procedure is complete.See</summary>
        BLE_GAP_EVT_PHY_UPDATE = 34,
        /// <summary>Data Length Update Request.Reply withSee</summary>
        BLE_GAP_EVT_DATA_LENGTH_UPDATE_REQUEST = 35,
        /// <summary>LL Data Channel PDU payload length updated.See</summary>
        BLE_GAP_EVT_DATA_LENGTH_UPDATE = 36
    }

    /// <summary>
    /// <para>GAP Option IDs.</para>
    /// <para>IDs that uniquely identify a GAP option.</para>
    /// </summary>
    public enum BLE_GAP_OPTS
    {
        /// <summary>Channel Map.</summary>
        BLE_GAP_OPT_CH_MAP = 32,
        /// <summary>Local connection latency.</summary>
        BLE_GAP_OPT_LOCAL_CONN_LATENCY = 33,
        /// <summary>Set passkey.</summary>
        BLE_GAP_OPT_PASSKEY = 34,
        /// <summary>Scan request report.</summary>
        BLE_GAP_OPT_SCAN_REQ_REPORT = 35,
        /// <summary>Compatibility mode.</summary>
        BLE_GAP_OPT_COMPAT_MODE_1 = 36,
        /// <summary>Set Authenticated payload timeout.</summary>
        BLE_GAP_OPT_AUTH_PAYLOAD_TIMEOUT = 37,
        /// <summary>Disable slave latency.</summary>
        BLE_GAP_OPT_SLAVE_LATENCY_DISABLE = 38
    }

    /// <summary>GAP Configuration IDs.</summary>
    /// <remarks>IDs that uniquely identify a GAP configuration.</remarks>
    public enum BLE_GAP_CFGS
    {
        /// <summary>Role count configuration.</summary>
        BLE_GAP_CFG_ROLE_COUNT = 64,
        /// <summary>Device name configuration.</summary>
        BLE_GAP_CFG_DEVICE_NAME = 65
    }

    /// <summary>Bluetooth Low Energy address.</summary>
    /// <summary>GAP connection parameters.</summary>
    /// <remarks>
    /// <para>When ble_conn_params_t is received in an event, both min_conn_interval and</para>
    /// <para>max_conn_interval will be equal to the connection interval set by the central.</para>
    /// <para>If both conn_sup_timeout and max_conn_interval are specified, then the following constraint applies:</para>
    /// <para>conn_sup_timeout * 4 &gt; (1 + slave_latency) * max_conn_interval</para>
    /// <para>that corresponds to the following Bluetooth Spec requirement:</para>
    /// <para>The Supervision_Timeout in milliseconds shall be larger than</para>
    /// <para>(1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given in milliseconds.</para>
    /// </remarks>
    /// <summary>GAP connection security modes.</summary>
    /// <remarks>
    /// <para>Security Mode 0 Level 0: No access permissions at all (this level is not defined by the Bluetooth Core specification).</para>
    /// <para>Security Mode 1 Level 1: No security is needed (aka open link).</para>
    /// <para>Security Mode 1 Level 2: Encrypted link required, MITM protection not necessary.</para>
    /// <para>Security Mode 1 Level 3: MITM protected encrypted link required.</para>
    /// <para>Security Mode 1 Level 4: LESC MITM protected encrypted link using a 128-bit strength encryption key required.</para>
    /// <para>Security Mode 2 Level 1: Signing or encryption required, MITM protection not necessary.</para>
    /// <para>Security Mode 2 Level 2: MITM protected signing required, unless link is MITM protected encrypted.</para>
    /// </remarks>
    /// <summary>GAP connection security status.</summary>
    /// <summary>Identity Resolving Key.</summary>
    /// <summary>Channel mask for RF channels used in advertising.</summary>
    /// <summary>GAP advertising parameters.</summary>
    /// <summary>GAP scanning parameters.</summary>
    /// <summary>Privacy.</summary>
    /// <remarks>
    /// <para>The privacy feature provides a way for the device to avoid being tracked over a period of time.</para>
    /// <para>The privacy feature, when enabled, hides the local device identity and replaces it with a private address</para>
    /// <para>that is automatically refreshed at a specified interval.</para>
    /// <para>If a device still wants to be recognized by other peers, it needs to share it's Identity Resolving Key (IRK).</para>
    /// <para>With this key, a device can generate a random private address that can only be recognized by peers in possession of that key,</para>
    /// <para>and devices can establish connections without revealing their real identities.</para>
    /// <para>Both network privacy (and device privacy (are supported.</para>
    /// <para>If the device IRK is updated, the new IRK becomes the one to be distributed in all</para>
    /// <para>bonding procedures performed afterreturns.</para>
    /// <para>The IRK distributed during bonding procedure is the device IRK that is active whenis called.</para>
    /// </remarks>
    /// <summary>PHY preferences for TX and RX</summary>
    /// <remarks>tx_phys and rx_phys are bit fields. Multiple bits can be set in them to indicate multiple preferred PHYs for each direction.</remarks>
    /// <summary>Keys that can be exchanged during a bonding procedure.</summary>
    /// <summary>GAP security parameters.</summary>
    /// <summary>GAP Encryption Information.</summary>
    /// <summary>GAP Master Identification.</summary>
    /// <summary>GAP Signing Information.</summary>
    /// <summary>GAP LE Secure Connections P-256 Public Key.</summary>
    /// <summary>GAP LE Secure Connections DHKey.</summary>
    /// <summary>GAP LE Secure Connections OOB data.</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event Structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Security levels supported.</summary>
    /// <remarks>See Bluetooth Specification Version 4.2 Volume 3, Part C, Chapter 10, Section 10.2.1.</remarks>
    /// <summary>Encryption Key.</summary>
    /// <summary>Identity Key.</summary>
    /// <summary>Security Keys.</summary>
    /// <summary>Security key set for both local and peer keys.</summary>
    /// <summary>Data Length Update Procedure parameters.</summary>
    /// <summary>Data Length Update Procedure local limitation.</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>GAP event structure.</summary>
    /// <summary>BLE GAP connection configuration parameters, set with</summary>
    /// <remarks>
    /// <para>::NRF_ERROR_CONN_COUNT     The connection count for the connection configurations is zero.</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  One or more of the following is true:</para>
    /// <para>- The sum of conn_count for all connection configurations combined exceeds UINT8_MAX.</para>
    /// <para>- The event length is smaller than</para>
    /// </remarks>
    /// <summary>Configuration of maximum concurrent connections in the different connected roles, set with</summary>
    /// <remarks>
    /// <para>::NRF_ERROR_CONN_COUNT     The sum of periph_role_count and central_role_count is too</para>
    /// <para>large. The maximum supported sum of concurrent connections is</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  central_sec_count is larger than central_role_count.</para>
    /// </remarks>
    /// <summary>Device name and its properties, set with</summary>
    /// <remarks>
    /// <para>If the device name is not configured, the default device name will bethe maximum device name length will bevloc will be set toand the device name</para>
    /// <para>will have no write access.</para>
    /// <para>Ifis more thanand vloc is set tothe attribute table size must be increased to have room for the longer device name (see</para>
    /// <para>and</para>
    /// <para>If vloc is:</para>
    /// <para>- p_value must point to non-volatile memory (flash) or be NULL.</para>
    /// <para>- If p_value is NULL, the device name will initially be empty.</para>
    /// <para>If vloc is:</para>
    /// <para>- p_value cannot be NULL.</para>
    /// <para>- If the device name is writable, p_value must point to volatile memory (RAM).</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  One or more of the following is true:</para>
    /// <para>- Invalid device name location (vloc).</para>
    /// <para>- Invalid device name security mode.</para>
    /// <para>::NRF_ERROR_INVALID_LENGTH One or more of the following is true:</para>
    /// <para>- The device name length is invalid (must be between 0 and- The device name length is too long for the given Attribute Table.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED  Device name security mode is not supported.</para>
    /// </remarks>
    /// <summary>Configuration structure for GAP configurations.</summary>
    /// <summary>
    /// <para>Channel Map option.</para>
    /// <para>Used withto get the current channel map</para>
    /// <para>orto set a new channel map. When setting the</para>
    /// <para>channel map, it applies to all current and future connections. When getting the</para>
    /// <para>current channel map, it applies to a single connection and the connection handle</para>
    /// <para>must be supplied.</para>
    /// </summary>
    /// <remarks>
    /// <para>Setting the channel map may take some time, depending on connection parameters.</para>
    /// <para>The time taken may be different for each connection and the get operation will</para>
    /// <para>return the previous channel map until the new one has taken effect.</para>
    /// <para>After setting the channel map, by spec it can not be set again until at least 1 s has passed.</para>
    /// <para>See Bluetooth Specification Version 4.1 Volume 2, Part E, Section 7.3.46.</para>
    /// <para>::NRF_SUCCESS Get or set successful.</para>
    /// <para>::NRF_ERROR_BUSY Channel map was set again before enough time had passed.</para>
    /// <para>::NRF_ERROR_INVALID_STATE Invalid state to perform operation.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied for get.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED Returned by sd_ble_opt_set in peripheral-only SoftDevices.</para>
    /// </remarks>
    /// <summary>Local connection latency option.</summary>
    /// <remarks>
    /// <para>Local connection latency is a feature which enables the slave to improve</para>
    /// <para>current consumption by ignoring the slave latency set by the peer. The</para>
    /// <para>local connection latency can only be set to a multiple of the slave latency,</para>
    /// <para>and cannot be longer than half of the supervision timeout.</para>
    /// <para>Used withto set the local connection latency. The</para>
    /// <para>is not supported for this option, but the actual</para>
    /// <para>local connection latency (unless set to NULL) is set as a return parameter</para>
    /// <para>when setting the option.</para>
    /// <para>The latency set will be truncated down to the closest slave latency event</para>
    /// <para>multiple, or the nearest multiple before half of the supervision timeout.</para>
    /// <para>The local connection latency is disabled by default, and needs to be enabled for new</para>
    /// <para>connections and whenever the connection is updated.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED Get is not supported.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.</para>
    /// </remarks>
    /// <summary>Disable slave latency</summary>
    /// <remarks>
    /// <para>Used withto temporarily disable slave latency of a peripheral connection (seeAnd to re-enable it again.</para>
    /// <para>When disabled, the peripheral will ignore the slave_latency set by the central.</para>
    /// <para>Shall only be called on peripheral links.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED Get is not supported.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.</para>
    /// </remarks>
    /// <summary>Passkey Option.</summary>
    /// <remarks>
    /// <para>Structure containing the passkey to be used during pairing. This can be used withto make the SoftDevice use a preprogrammed passkey for authentication</para>
    /// <para>instead of generating a random one.</para>
    /// <para>Repeated pairing attempts using the same preprogrammed passkey makes pairing vulnerable to MITM attacks.</para>
    /// <para>is not supported for this option.</para>
    /// </remarks>
    /// <summary>Scan request report option.</summary>
    /// <remarks>
    /// <para>This can be used withto make the SoftDevice send</para>
    /// <para>events.</para>
    /// <para>Due to the limited space reserved for scan request report events,</para>
    /// <para>not all received scan requests will be reported.</para>
    /// <para>If whitelisting is used, only whitelisted requests are reported.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_INVALID_STATE When advertising is ongoing while the option is set.</para>
    /// </remarks>
    /// <summary>Compatibility mode 1 option.</summary>
    /// <remarks>
    /// <para>This can be used withto enable and disable</para>
    /// <para>compatibility mode 1. Compatibility mode 1 is disabled by default.</para>
    /// <para>Compatibility mode 1 enables interoperability with devices that do not support a value of</para>
    /// <para>0 for the WinOffset parameter in the Link Layer CONNECT_IND packet. This applies to a</para>
    /// <para>limited set of legacy peripheral devices from another vendor. Enabling this compatibility</para>
    /// <para>mode will only have an effect if the local device will act as a central device and</para>
    /// <para>initiate a connection to a peripheral device. In that case it may lead to the connection</para>
    /// <para>creation taking up to one connection interval longer to complete for all connections.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_INVALID_STATE When connection creation is ongoing while mode 1 is set.</para>
    /// </remarks>
    /// <summary>Authenticated payload timeout option.</summary>
    /// <remarks>
    /// <para>This can be used withto change the Authenticated payload timeout to a value other</para>
    /// <para>than the default of</para>
    /// <para>The authenticated payload timeout event ::BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD will be generated</para>
    /// <para>if auth_payload_timeout time has elapsed without receiving a packet with a valid MIC on an encrypted</para>
    /// <para>link.</para>
    /// <para>The LE ping procedure will be initiated before the timer expires to give the peer a chance</para>
    /// <para>to reset the timer. In addition the stack will try to prioritize running of LE ping over other</para>
    /// <para>activities to increase chances of finishing LE ping before timer expires. To avoid side-effects</para>
    /// <para>on other activities, it is recommended to use high timeout values.</para>
    /// <para>Recommended timeout &gt; 2*(connInterval * (6 + connSlaveLatency)).</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied. auth_payload_timeout was outside of allowed range.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.</para>
    /// </remarks>
    /// <summary>Option structure for GAP options.</summary>
    /// <summary>Bluetooth Low Energy address.</summary>
    public unsafe partial class BleGapAddrT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 7)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte addr_id_peer;

            [FieldOffset(0)]
            internal byte addr_type;

            [FieldOffset(1)]
            internal fixed byte addr[6];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_addr_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapAddrT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapAddrT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapAddrT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapAddrT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapAddrT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapAddrT(native.ToPointer(), skipVTables);
        }

        internal static BleGapAddrT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapAddrT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapAddrT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapAddrT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapAddrT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapAddrT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapAddrT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapAddrT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapAddrT(global::NrfBleDriver.BleGapAddrT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapAddrT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapAddrT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapAddrT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Only valid for peer addresses.</para>
        /// <para>Reference to peer in device identities list (as set withwhen peer is using privacy.</para>
        /// </summary>
        public byte AddrIdPeer
        {
            get
            {
                return ((__Internal*)__Instance)->addr_id_peer;
            }

            set
            {
                ((__Internal*)__Instance)->addr_id_peer = value;
            }
        }

        /// <summary>See</summary>
        public byte AddrType
        {
            get
            {
                return ((__Internal*)__Instance)->addr_type;
            }

            set
            {
                ((__Internal*)__Instance)->addr_type = value;
            }
        }

        /// <summary>48-bit address, LSB format.</summary>
        public byte[] Addr
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->addr, 6);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 6; i++)
                        ((__Internal*)__Instance)->addr[i] = value[i];
                }
            }
        }
    }

    /// <summary>GAP connection parameters.</summary>
    /// <remarks>
    /// <para>When ble_conn_params_t is received in an event, both min_conn_interval and</para>
    /// <para>max_conn_interval will be equal to the connection interval set by the central.</para>
    /// <para>If both conn_sup_timeout and max_conn_interval are specified, then the following constraint applies:</para>
    /// <para>conn_sup_timeout * 4 &gt; (1 + slave_latency) * max_conn_interval</para>
    /// <para>that corresponds to the following Bluetooth Spec requirement:</para>
    /// <para>The Supervision_Timeout in milliseconds shall be larger than</para>
    /// <para>(1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given in milliseconds.</para>
    /// </remarks>
    public unsafe partial class BleGapConnParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort min_conn_interval;
            internal ushort max_conn_interval;
            internal ushort slave_latency;
            internal ushort conn_sup_timeout;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_conn_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapConnParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapConnParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapConnParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapConnParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGapConnParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapConnParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapConnParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapConnParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapConnParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapConnParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapConnParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapConnParamsT(global::NrfBleDriver.BleGapConnParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapConnParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapConnParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Minimum Connection Interval in 1.25 ms units, see</summary>
        public ushort MinConnInterval
        {
            get
            {
                return ((__Internal*)__Instance)->min_conn_interval;
            }

            set
            {
                ((__Internal*)__Instance)->min_conn_interval = value;
            }
        }

        /// <summary>Maximum Connection Interval in 1.25 ms units, see</summary>
        public ushort MaxConnInterval
        {
            get
            {
                return ((__Internal*)__Instance)->max_conn_interval;
            }

            set
            {
                ((__Internal*)__Instance)->max_conn_interval = value;
            }
        }

        /// <summary>Slave Latency in number of connection events, see</summary>
        public ushort SlaveLatency
        {
            get
            {
                return ((__Internal*)__Instance)->slave_latency;
            }

            set
            {
                ((__Internal*)__Instance)->slave_latency = value;
            }
        }

        /// <summary>Connection Supervision Timeout in 10 ms units, see</summary>
        public ushort ConnSupTimeout
        {
            get
            {
                return ((__Internal*)__Instance)->conn_sup_timeout;
            }

            set
            {
                ((__Internal*)__Instance)->conn_sup_timeout = value;
            }
        }
    }

    /// <summary>GAP connection security modes.</summary>
    /// <remarks>
    /// <para>Security Mode 0 Level 0: No access permissions at all (this level is not defined by the Bluetooth Core specification).</para>
    /// <para>Security Mode 1 Level 1: No security is needed (aka open link).</para>
    /// <para>Security Mode 1 Level 2: Encrypted link required, MITM protection not necessary.</para>
    /// <para>Security Mode 1 Level 3: MITM protected encrypted link required.</para>
    /// <para>Security Mode 1 Level 4: LESC MITM protected encrypted link using a 128-bit strength encryption key required.</para>
    /// <para>Security Mode 2 Level 1: Signing or encryption required, MITM protection not necessary.</para>
    /// <para>Security Mode 2 Level 2: MITM protected signing required, unless link is MITM protected encrypted.</para>
    /// </remarks>
    public unsafe partial class BleGapConnSecModeT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte sm;

            [FieldOffset(0)]
            internal byte lv;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_conn_sec_mode_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnSecModeT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnSecModeT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapConnSecModeT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapConnSecModeT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapConnSecModeT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapConnSecModeT(native.ToPointer(), skipVTables);
        }

        internal static BleGapConnSecModeT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapConnSecModeT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapConnSecModeT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapConnSecModeT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapConnSecModeT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapConnSecModeT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapConnSecModeT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnSecModeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapConnSecModeT(global::NrfBleDriver.BleGapConnSecModeT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnSecModeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapConnSecModeT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapConnSecModeT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Security Mode (1 or 2), 0 for no permissions at all.</summary>
        public byte Sm
        {
            get
            {
                return ((__Internal*)__Instance)->sm;
            }

            set
            {
                ((__Internal*)__Instance)->sm = value;
            }
        }

        /// <summary>Level (1, 2, 3 or 4), 0 for no permissions at all.</summary>
        public byte Lv
        {
            get
            {
                return ((__Internal*)__Instance)->lv;
            }

            set
            {
                ((__Internal*)__Instance)->lv = value;
            }
        }
    }

    /// <summary>GAP connection security status.</summary>
    public unsafe partial class BleGapConnSecT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapConnSecModeT.__Internal sec_mode;
            internal byte encr_key_size;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_conn_sec_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnSecT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnSecT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapConnSecT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapConnSecT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapConnSecT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapConnSecT(native.ToPointer(), skipVTables);
        }

        internal static BleGapConnSecT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapConnSecT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapConnSecT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapConnSecT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapConnSecT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapConnSecT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapConnSecT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnSecT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapConnSecT(global::NrfBleDriver.BleGapConnSecT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnSecT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapConnSecT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapConnSecT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Currently active security mode for this connection.</summary>
        public global::NrfBleDriver.BleGapConnSecModeT SecMode
        {
            get
            {
                return global::NrfBleDriver.BleGapConnSecModeT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sec_mode));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sec_mode = *(global::NrfBleDriver.BleGapConnSecModeT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Length of currently active encryption key, 7 to 16 octets (only applicable for bonding procedures).</summary>
        public byte EncrKeySize
        {
            get
            {
                return ((__Internal*)__Instance)->encr_key_size;
            }

            set
            {
                ((__Internal*)__Instance)->encr_key_size = value;
            }
        }
    }

    /// <summary>Identity Resolving Key.</summary>
    public unsafe partial class BleGapIrkT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal fixed byte irk[16];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_irk_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapIrkT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapIrkT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapIrkT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapIrkT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapIrkT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapIrkT(native.ToPointer(), skipVTables);
        }

        internal static BleGapIrkT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapIrkT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapIrkT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapIrkT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapIrkT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapIrkT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapIrkT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapIrkT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapIrkT(global::NrfBleDriver.BleGapIrkT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapIrkT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapIrkT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapIrkT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Array containing IRK.</summary>
        public byte[] Irk
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->irk, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->irk[i] = value[i];
                }
            }
        }
    }

    /// <summary>Channel mask for RF channels used in advertising.</summary>
    public unsafe partial class BleGapAdvChMaskT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte ch_37_off;

            [FieldOffset(0)]
            internal byte ch_38_off;

            [FieldOffset(0)]
            internal byte ch_39_off;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_adv_ch_mask_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapAdvChMaskT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapAdvChMaskT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapAdvChMaskT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapAdvChMaskT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapAdvChMaskT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapAdvChMaskT(native.ToPointer(), skipVTables);
        }

        internal static BleGapAdvChMaskT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapAdvChMaskT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapAdvChMaskT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapAdvChMaskT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapAdvChMaskT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapAdvChMaskT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapAdvChMaskT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapAdvChMaskT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapAdvChMaskT(global::NrfBleDriver.BleGapAdvChMaskT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapAdvChMaskT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapAdvChMaskT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapAdvChMaskT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Setting this bit to 1 will turn off advertising on channel 37</summary>
        public byte Ch37Off
        {
            get
            {
                return ((__Internal*)__Instance)->ch_37_off;
            }

            set
            {
                ((__Internal*)__Instance)->ch_37_off = value;
            }
        }

        /// <summary>Setting this bit to 1 will turn off advertising on channel 38</summary>
        public byte Ch38Off
        {
            get
            {
                return ((__Internal*)__Instance)->ch_38_off;
            }

            set
            {
                ((__Internal*)__Instance)->ch_38_off = value;
            }
        }

        /// <summary>Setting this bit to 1 will turn off advertising on channel 39</summary>
        public byte Ch39Off
        {
            get
            {
                return ((__Internal*)__Instance)->ch_39_off;
            }

            set
            {
                ((__Internal*)__Instance)->ch_39_off = value;
            }
        }
    }

    /// <summary>GAP advertising parameters.</summary>
    public unsafe partial class BleGapAdvParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal byte type;
            internal __IntPtr p_peer_addr;
            internal byte fp;
            internal ushort interval;
            internal ushort timeout;
            internal global::NrfBleDriver.BleGapAdvChMaskT.__Internal channel_mask;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_adv_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapAdvParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapAdvParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapAdvParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapAdvParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapAdvParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapAdvParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGapAdvParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapAdvParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapAdvParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapAdvParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapAdvParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapAdvParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapAdvParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapAdvParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapAdvParamsT(global::NrfBleDriver.BleGapAdvParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapAdvParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapAdvParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapAdvParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>See</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>
        /// <para>Address of a known peer.</para>
        /// <para>- When privacy is enabled and the local device useaddresses, the device identity list is searched for a matching</para>
        /// <para>entry. If the local IRK for that device identity is set, the local IRK for that device will be used to generate the advertiser address field in the advertise packet.</para>
        /// <para>- If type isthis must be set to the targeted initiator. If the initiator is in the device identity list,</para>
        /// <para>the peer IRK for that device will be used to generate the initiator address field in the ADV_DIRECT_IND packet.</para>
        /// </summary>
        public global::NrfBleDriver.BleGapAddrT PPeerAddr
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGapAddrT.__GetOrCreateInstance(((__Internal*)__Instance)->p_peer_addr, false);
                return __result0;
            }
        }

        /// <summary>Filter Policy, see</summary>
        public byte Fp
        {
            get
            {
                return ((__Internal*)__Instance)->fp;
            }

            set
            {
                ((__Internal*)__Instance)->fp = value;
            }
        }

        /// <summary>
        /// <para>Advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20 ms to 10.24 s), see- If type equalsthis parameter must be set to 0 for high duty cycle directed advertising.</para>
        /// <para>- If type equalsset&lt;= interval&lt;=for low duty cycle advertising.</para>
        /// </summary>
        public ushort Interval
        {
            get
            {
                return ((__Internal*)__Instance)->interval;
            }

            set
            {
                ((__Internal*)__Instance)->interval = value;
            }
        }

        /// <summary>Advertising timeout between 0x0001 and 0x3FFF in seconds, 0x0000 disables timeout. See alsoIf type equalsthis parameter must be set to 0 for High duty cycle directed advertising.</summary>
        public ushort Timeout
        {
            get
            {
                return ((__Internal*)__Instance)->timeout;
            }

            set
            {
                ((__Internal*)__Instance)->timeout = value;
            }
        }

        /// <summary>Advertising channel mask. See</summary>
        public global::NrfBleDriver.BleGapAdvChMaskT ChannelMask
        {
            get
            {
                return global::NrfBleDriver.BleGapAdvChMaskT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->channel_mask));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->channel_mask = *(global::NrfBleDriver.BleGapAdvChMaskT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>GAP scanning parameters.</summary>
    public unsafe partial class BleGapScanParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte active;

            [FieldOffset(0)]
            internal byte use_whitelist;

            [FieldOffset(0)]
            internal byte adv_dir_report;

            [FieldOffset(2)]
            internal ushort interval;

            [FieldOffset(4)]
            internal ushort window;

            [FieldOffset(6)]
            internal ushort timeout;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_scan_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapScanParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapScanParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapScanParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapScanParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapScanParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapScanParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGapScanParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapScanParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapScanParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapScanParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapScanParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapScanParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapScanParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapScanParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapScanParamsT(global::NrfBleDriver.BleGapScanParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapScanParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapScanParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapScanParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>If 1, perform active scanning (scan requests).</summary>
        public byte Active
        {
            get
            {
                return ((__Internal*)__Instance)->active;
            }

            set
            {
                ((__Internal*)__Instance)->active = value;
            }
        }

        /// <summary>If 1, filter advertisers using current active whitelist.</summary>
        public byte UseWhitelist
        {
            get
            {
                return ((__Internal*)__Instance)->use_whitelist;
            }

            set
            {
                ((__Internal*)__Instance)->use_whitelist = value;
            }
        }

        /// <summary>
        /// <para>If 1, also report directed advertisements where the initiator field is set to a private resolvable address,</para>
        /// <para>even if the address did not resolve to an entry in the device identity list. A report will be generated</para>
        /// <para>even if the peer is not in the whitelist.</para>
        /// </summary>
        public byte AdvDirReport
        {
            get
            {
                return ((__Internal*)__Instance)->adv_dir_report;
            }

            set
            {
                ((__Internal*)__Instance)->adv_dir_report = value;
            }
        }

        /// <summary>Scan interval between 0x0004 and 0x4000 in 0.625 ms units (2.5 ms to 10.24 s).</summary>
        public ushort Interval
        {
            get
            {
                return ((__Internal*)__Instance)->interval;
            }

            set
            {
                ((__Internal*)__Instance)->interval = value;
            }
        }

        /// <summary>Scan window between 0x0004 and 0x4000 in 0.625 ms units (2.5 ms to 10.24 s).</summary>
        public ushort Window
        {
            get
            {
                return ((__Internal*)__Instance)->window;
            }

            set
            {
                ((__Internal*)__Instance)->window = value;
            }
        }

        /// <summary>Scan timeout between 0x0001 and 0xFFFF in seconds, 0x0000 disables timeout.</summary>
        public ushort Timeout
        {
            get
            {
                return ((__Internal*)__Instance)->timeout;
            }

            set
            {
                ((__Internal*)__Instance)->timeout = value;
            }
        }
    }

    /// <summary>Privacy.</summary>
    /// <remarks>
    /// <para>The privacy feature provides a way for the device to avoid being tracked over a period of time.</para>
    /// <para>The privacy feature, when enabled, hides the local device identity and replaces it with a private address</para>
    /// <para>that is automatically refreshed at a specified interval.</para>
    /// <para>If a device still wants to be recognized by other peers, it needs to share it's Identity Resolving Key (IRK).</para>
    /// <para>With this key, a device can generate a random private address that can only be recognized by peers in possession of that key,</para>
    /// <para>and devices can establish connections without revealing their real identities.</para>
    /// <para>Both network privacy (and device privacy (are supported.</para>
    /// <para>If the device IRK is updated, the new IRK becomes the one to be distributed in all</para>
    /// <para>bonding procedures performed afterreturns.</para>
    /// <para>The IRK distributed during bonding procedure is the device IRK that is active whenis called.</para>
    /// </remarks>
    public unsafe partial class BleGapPrivacyParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal byte privacy_mode;
            internal byte private_addr_type;
            internal ushort private_addr_cycle_s;
            internal __IntPtr p_device_irk;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_privacy_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapPrivacyParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapPrivacyParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapPrivacyParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapPrivacyParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapPrivacyParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapPrivacyParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGapPrivacyParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapPrivacyParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapPrivacyParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapPrivacyParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapPrivacyParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapPrivacyParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapPrivacyParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapPrivacyParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapPrivacyParamsT(global::NrfBleDriver.BleGapPrivacyParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapPrivacyParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapPrivacyParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapPrivacyParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Privacy mode, seeDefault is</summary>
        public byte PrivacyMode
        {
            get
            {
                return ((__Internal*)__Instance)->privacy_mode;
            }

            set
            {
                ((__Internal*)__Instance)->privacy_mode = value;
            }
        }

        /// <summary>The private address type must be eitheror</summary>
        public byte PrivateAddrType
        {
            get
            {
                return ((__Internal*)__Instance)->private_addr_type;
            }

            set
            {
                ((__Internal*)__Instance)->private_addr_type = value;
            }
        }

        /// <summary>Private address cycle interval in seconds. Providing an address cycle value of 0 will use the default value defined by</summary>
        public ushort PrivateAddrCycleS
        {
            get
            {
                return ((__Internal*)__Instance)->private_addr_cycle_s;
            }

            set
            {
                ((__Internal*)__Instance)->private_addr_cycle_s = value;
            }
        }

        /// <summary>
        /// <para>When used as input, pointer to IRK structure that will be used as the default IRK. If NULL, the device default IRK will be used.</para>
        /// <para>When used as output, pointer to IRK structure where the current default IRK will be written to. If NULL, this argument is ignored.</para>
        /// <para>By default, the default IRK is used to generate random private resolvable addresses for the local device unless instructed otherwise.</para>
        /// </summary>
        public global::NrfBleDriver.BleGapIrkT PDeviceIrk
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGapIrkT.__GetOrCreateInstance(((__Internal*)__Instance)->p_device_irk, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->p_device_irk = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>PHY preferences for TX and RX</summary>
    /// <remarks>tx_phys and rx_phys are bit fields. Multiple bits can be set in them to indicate multiple preferred PHYs for each direction.</remarks>
    public unsafe partial class BleGapPhysT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal byte tx_phys;
            internal byte rx_phys;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_phys_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapPhysT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapPhysT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapPhysT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapPhysT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapPhysT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapPhysT(native.ToPointer(), skipVTables);
        }

        internal static BleGapPhysT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapPhysT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapPhysT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapPhysT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapPhysT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapPhysT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapPhysT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapPhysT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapPhysT(global::NrfBleDriver.BleGapPhysT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapPhysT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapPhysT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapPhysT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Preferred transmit PHYs, see</summary>
        public byte TxPhys
        {
            get
            {
                return ((__Internal*)__Instance)->tx_phys;
            }

            set
            {
                ((__Internal*)__Instance)->tx_phys = value;
            }
        }

        /// <summary>Preferred receive PHYs, see</summary>
        public byte RxPhys
        {
            get
            {
                return ((__Internal*)__Instance)->rx_phys;
            }

            set
            {
                ((__Internal*)__Instance)->rx_phys = value;
            }
        }
    }

    /// <summary>Keys that can be exchanged during a bonding procedure.</summary>
    public unsafe partial class BleGapSecKdistT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte enc;

            [FieldOffset(0)]
            internal byte id;

            [FieldOffset(0)]
            internal byte sign;

            [FieldOffset(0)]
            internal byte link;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_sec_kdist_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecKdistT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecKdistT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapSecKdistT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapSecKdistT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapSecKdistT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapSecKdistT(native.ToPointer(), skipVTables);
        }

        internal static BleGapSecKdistT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapSecKdistT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapSecKdistT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapSecKdistT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapSecKdistT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapSecKdistT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapSecKdistT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecKdistT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapSecKdistT(global::NrfBleDriver.BleGapSecKdistT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecKdistT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapSecKdistT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapSecKdistT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Long Term Key and Master Identification.</summary>
        public byte Enc
        {
            get
            {
                return ((__Internal*)__Instance)->enc;
            }

            set
            {
                ((__Internal*)__Instance)->enc = value;
            }
        }

        /// <summary>Identity Resolving Key and Identity Address Information.</summary>
        public byte Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        /// <summary>Connection Signature Resolving Key.</summary>
        public byte Sign
        {
            get
            {
                return ((__Internal*)__Instance)->sign;
            }

            set
            {
                ((__Internal*)__Instance)->sign = value;
            }
        }

        /// <summary>Derive the Link Key from the LTK.</summary>
        public byte Link
        {
            get
            {
                return ((__Internal*)__Instance)->link;
            }

            set
            {
                ((__Internal*)__Instance)->link = value;
            }
        }
    }

    /// <summary>GAP security parameters.</summary>
    public unsafe partial class BleGapSecParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 5)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte bond;

            [FieldOffset(0)]
            internal byte mitm;

            [FieldOffset(0)]
            internal byte lesc;

            [FieldOffset(0)]
            internal byte keypress;

            [FieldOffset(0)]
            internal byte io_caps;

            [FieldOffset(0)]
            internal byte oob;

            [FieldOffset(1)]
            internal byte min_key_size;

            [FieldOffset(2)]
            internal byte max_key_size;

            [FieldOffset(3)]
            internal global::NrfBleDriver.BleGapSecKdistT.__Internal kdist_own;

            [FieldOffset(4)]
            internal global::NrfBleDriver.BleGapSecKdistT.__Internal kdist_peer;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_sec_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapSecParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapSecParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapSecParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapSecParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGapSecParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapSecParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapSecParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapSecParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapSecParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapSecParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapSecParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapSecParamsT(global::NrfBleDriver.BleGapSecParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapSecParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapSecParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Perform bonding.</summary>
        public byte Bond
        {
            get
            {
                return ((__Internal*)__Instance)->bond;
            }

            set
            {
                ((__Internal*)__Instance)->bond = value;
            }
        }

        /// <summary>Enable Man In The Middle protection.</summary>
        public byte Mitm
        {
            get
            {
                return ((__Internal*)__Instance)->mitm;
            }

            set
            {
                ((__Internal*)__Instance)->mitm = value;
            }
        }

        /// <summary>Enable LE Secure Connection pairing.</summary>
        public byte Lesc
        {
            get
            {
                return ((__Internal*)__Instance)->lesc;
            }

            set
            {
                ((__Internal*)__Instance)->lesc = value;
            }
        }

        /// <summary>Enable generation of keypress notifications.</summary>
        public byte Keypress
        {
            get
            {
                return ((__Internal*)__Instance)->keypress;
            }

            set
            {
                ((__Internal*)__Instance)->keypress = value;
            }
        }

        /// <summary>IO capabilities, see</summary>
        public byte IoCaps
        {
            get
            {
                return ((__Internal*)__Instance)->io_caps;
            }

            set
            {
                ((__Internal*)__Instance)->io_caps = value;
            }
        }

        /// <summary>
        /// <para>The OOB data flag.</para>
        /// <para>- In LE legacy pairing, this flag is set if a device has out of band authentication data.</para>
        /// <para>The OOB method is used if both of the devices have out of band authentication data.</para>
        /// <para>- In LE Secure Connections pairing, this flag is set if a device has the peer device's out of band authentication data.</para>
        /// <para>The OOB method is used if at least one device has the peer device's OOB data available.</para>
        /// </summary>
        public byte Oob
        {
            get
            {
                return ((__Internal*)__Instance)->oob;
            }

            set
            {
                ((__Internal*)__Instance)->oob = value;
            }
        }

        /// <summary>Minimum encryption key size in octets between 7 and 16. If 0 then not applicable in this instance.</summary>
        public byte MinKeySize
        {
            get
            {
                return ((__Internal*)__Instance)->min_key_size;
            }

            set
            {
                ((__Internal*)__Instance)->min_key_size = value;
            }
        }

        /// <summary>Maximum encryption key size in octets between min_key_size and 16.</summary>
        public byte MaxKeySize
        {
            get
            {
                return ((__Internal*)__Instance)->max_key_size;
            }

            set
            {
                ((__Internal*)__Instance)->max_key_size = value;
            }
        }

        /// <summary>Key distribution bitmap: keys that the local device will distribute.</summary>
        public global::NrfBleDriver.BleGapSecKdistT KdistOwn
        {
            get
            {
                return global::NrfBleDriver.BleGapSecKdistT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->kdist_own));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->kdist_own = *(global::NrfBleDriver.BleGapSecKdistT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Key distribution bitmap: keys that the remote device will distribute.</summary>
        public global::NrfBleDriver.BleGapSecKdistT KdistPeer
        {
            get
            {
                return global::NrfBleDriver.BleGapSecKdistT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->kdist_peer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->kdist_peer = *(global::NrfBleDriver.BleGapSecKdistT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>GAP Encryption Information.</summary>
    public unsafe partial class BleGapEncInfoT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 17)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed byte ltk[16];

            [FieldOffset(16)]
            internal byte lesc;

            [FieldOffset(16)]
            internal byte auth;

            [FieldOffset(16)]
            internal byte ltk_len;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_enc_info_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEncInfoT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEncInfoT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEncInfoT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEncInfoT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEncInfoT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEncInfoT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEncInfoT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEncInfoT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEncInfoT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEncInfoT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEncInfoT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEncInfoT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEncInfoT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEncInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEncInfoT(global::NrfBleDriver.BleGapEncInfoT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEncInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEncInfoT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEncInfoT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Long Term Key.</summary>
        public byte[] Ltk
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->ltk, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->ltk[i] = value[i];
                }
            }
        }

        /// <summary>Key generated using LE Secure Connections.</summary>
        public byte Lesc
        {
            get
            {
                return ((__Internal*)__Instance)->lesc;
            }

            set
            {
                ((__Internal*)__Instance)->lesc = value;
            }
        }

        /// <summary>Authenticated Key.</summary>
        public byte Auth
        {
            get
            {
                return ((__Internal*)__Instance)->auth;
            }

            set
            {
                ((__Internal*)__Instance)->auth = value;
            }
        }

        /// <summary>LTK length in octets.</summary>
        public byte LtkLen
        {
            get
            {
                return ((__Internal*)__Instance)->ltk_len;
            }

            set
            {
                ((__Internal*)__Instance)->ltk_len = value;
            }
        }
    }

    /// <summary>GAP Master Identification.</summary>
    public unsafe partial class BleGapMasterIdT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 10)]
        public partial struct __Internal
        {
            internal ushort ediv;
            internal fixed byte rand[8];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_master_id_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapMasterIdT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapMasterIdT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapMasterIdT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapMasterIdT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapMasterIdT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapMasterIdT(native.ToPointer(), skipVTables);
        }

        internal static BleGapMasterIdT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapMasterIdT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapMasterIdT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapMasterIdT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapMasterIdT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapMasterIdT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapMasterIdT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapMasterIdT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapMasterIdT(global::NrfBleDriver.BleGapMasterIdT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapMasterIdT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapMasterIdT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapMasterIdT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Encrypted Diversifier.</summary>
        public ushort Ediv
        {
            get
            {
                return ((__Internal*)__Instance)->ediv;
            }

            set
            {
                ((__Internal*)__Instance)->ediv = value;
            }
        }

        /// <summary>Random Number.</summary>
        public byte[] Rand
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->rand, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->rand[i] = value[i];
                }
            }
        }
    }

    /// <summary>GAP Signing Information.</summary>
    public unsafe partial class BleGapSignInfoT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal fixed byte csrk[16];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_sign_info_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSignInfoT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSignInfoT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapSignInfoT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapSignInfoT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapSignInfoT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapSignInfoT(native.ToPointer(), skipVTables);
        }

        internal static BleGapSignInfoT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapSignInfoT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapSignInfoT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapSignInfoT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapSignInfoT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapSignInfoT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapSignInfoT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSignInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapSignInfoT(global::NrfBleDriver.BleGapSignInfoT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSignInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapSignInfoT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapSignInfoT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Signature Resolving Key.</summary>
        public byte[] Csrk
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->csrk, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->csrk[i] = value[i];
                }
            }
        }
    }

    /// <summary>GAP LE Secure Connections P-256 Public Key.</summary>
    public unsafe partial class BleGapLescP256PkT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal fixed byte pk[64];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_lesc_p256_pk_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapLescP256PkT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapLescP256PkT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapLescP256PkT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapLescP256PkT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapLescP256PkT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapLescP256PkT(native.ToPointer(), skipVTables);
        }

        internal static BleGapLescP256PkT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapLescP256PkT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapLescP256PkT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapLescP256PkT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapLescP256PkT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapLescP256PkT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapLescP256PkT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapLescP256PkT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapLescP256PkT(global::NrfBleDriver.BleGapLescP256PkT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapLescP256PkT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapLescP256PkT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapLescP256PkT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>LE Secure Connections Elliptic Curve Diffie-Hellman P-256 Public Key. Stored in the standard SMP protocol format: {X,Y} both in little-endian.</summary>
        public byte[] Pk
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->pk, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->pk[i] = value[i];
                }
            }
        }
    }

    /// <summary>GAP LE Secure Connections DHKey.</summary>
    public unsafe partial class BleGapLescDhkeyT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal fixed byte key[32];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_lesc_dhkey_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapLescDhkeyT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapLescDhkeyT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapLescDhkeyT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapLescDhkeyT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapLescDhkeyT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapLescDhkeyT(native.ToPointer(), skipVTables);
        }

        internal static BleGapLescDhkeyT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapLescDhkeyT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapLescDhkeyT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapLescDhkeyT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapLescDhkeyT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapLescDhkeyT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapLescDhkeyT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapLescDhkeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapLescDhkeyT(global::NrfBleDriver.BleGapLescDhkeyT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapLescDhkeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapLescDhkeyT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapLescDhkeyT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>LE Secure Connections Elliptic Curve Diffie-Hellman Key. Stored in little-endian.</summary>
        public byte[] Key
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->key, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->key[i] = value[i];
                }
            }
        }
    }

    /// <summary>GAP LE Secure Connections OOB data.</summary>
    public unsafe partial class BleGapLescOobDataT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 39)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapAddrT.__Internal addr;
            internal fixed byte r[16];
            internal fixed byte c[16];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_lesc_oob_data_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapLescOobDataT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapLescOobDataT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapLescOobDataT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapLescOobDataT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapLescOobDataT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapLescOobDataT(native.ToPointer(), skipVTables);
        }

        internal static BleGapLescOobDataT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapLescOobDataT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapLescOobDataT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapLescOobDataT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapLescOobDataT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapLescOobDataT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapLescOobDataT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapLescOobDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapLescOobDataT(global::NrfBleDriver.BleGapLescOobDataT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapLescOobDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapLescOobDataT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapLescOobDataT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Bluetooth address of the device.</summary>
        public global::NrfBleDriver.BleGapAddrT Addr
        {
            get
            {
                return global::NrfBleDriver.BleGapAddrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->addr));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->addr = *(global::NrfBleDriver.BleGapAddrT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Random Number.</summary>
        public byte[] R
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->r, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->r[i] = value[i];
                }
            }
        }

        /// <summary>Confirm Value.</summary>
        public byte[] C
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->c, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->c[i] = value[i];
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtConnectedT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapAddrT.__Internal peer_addr;
            internal byte role;
            internal global::NrfBleDriver.BleGapConnParamsT.__Internal conn_params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_connected_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnectedT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnectedT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtConnectedT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtConnectedT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtConnectedT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtConnectedT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtConnectedT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtConnectedT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtConnectedT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtConnectedT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtConnectedT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtConnectedT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtConnectedT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnectedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtConnectedT(global::NrfBleDriver.BleGapEvtConnectedT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnectedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtConnectedT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtConnectedT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Bluetooth address of the peer device. If the peer_addr resolved:is set to 1</para>
        /// <para>and the address is the device's identity address.</para>
        /// </summary>
        public global::NrfBleDriver.BleGapAddrT PeerAddr
        {
            get
            {
                return global::NrfBleDriver.BleGapAddrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->peer_addr));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->peer_addr = *(global::NrfBleDriver.BleGapAddrT.__Internal*) value.__Instance;
            }
        }

        /// <summary>BLE role for this connection, see</summary>
        public byte Role
        {
            get
            {
                return ((__Internal*)__Instance)->role;
            }

            set
            {
                ((__Internal*)__Instance)->role = value;
            }
        }

        /// <summary>GAP Connection Parameters.</summary>
        public global::NrfBleDriver.BleGapConnParamsT ConnParams
        {
            get
            {
                return global::NrfBleDriver.BleGapConnParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->conn_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->conn_params = *(global::NrfBleDriver.BleGapConnParamsT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtDisconnectedT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte reason;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_disconnected_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtDisconnectedT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtDisconnectedT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtDisconnectedT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtDisconnectedT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtDisconnectedT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtDisconnectedT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtDisconnectedT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtDisconnectedT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtDisconnectedT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtDisconnectedT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtDisconnectedT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtDisconnectedT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtDisconnectedT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtDisconnectedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtDisconnectedT(global::NrfBleDriver.BleGapEvtDisconnectedT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtDisconnectedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtDisconnectedT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtDisconnectedT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>HCI error code, see</summary>
        public byte Reason
        {
            get
            {
                return ((__Internal*)__Instance)->reason;
            }

            set
            {
                ((__Internal*)__Instance)->reason = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtConnParamUpdateT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapConnParamsT.__Internal conn_params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_conn_param_update_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnParamUpdateT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnParamUpdateT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtConnParamUpdateT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtConnParamUpdateT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtConnParamUpdateT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtConnParamUpdateT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtConnParamUpdateT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtConnParamUpdateT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtConnParamUpdateT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtConnParamUpdateT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtConnParamUpdateT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtConnParamUpdateT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtConnParamUpdateT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnParamUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtConnParamUpdateT(global::NrfBleDriver.BleGapEvtConnParamUpdateT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnParamUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtConnParamUpdateT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtConnParamUpdateT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>GAP Connection Parameters.</summary>
        public global::NrfBleDriver.BleGapConnParamsT ConnParams
        {
            get
            {
                return global::NrfBleDriver.BleGapConnParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->conn_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->conn_params = *(global::NrfBleDriver.BleGapConnParamsT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtPhyUpdateRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapPhysT.__Internal peer_preferred_phys;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_phy_update_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtPhyUpdateRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtPhyUpdateRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtPhyUpdateRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtPhyUpdateRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtPhyUpdateRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtPhyUpdateRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtPhyUpdateRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtPhyUpdateRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtPhyUpdateRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtPhyUpdateRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtPhyUpdateRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtPhyUpdateRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtPhyUpdateRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtPhyUpdateRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtPhyUpdateRequestT(global::NrfBleDriver.BleGapEvtPhyUpdateRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtPhyUpdateRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtPhyUpdateRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtPhyUpdateRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The PHYs the peer prefers to use.</summary>
        public global::NrfBleDriver.BleGapPhysT PeerPreferredPhys
        {
            get
            {
                return global::NrfBleDriver.BleGapPhysT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->peer_preferred_phys));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->peer_preferred_phys = *(global::NrfBleDriver.BleGapPhysT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event Structure for</summary>
    public unsafe partial class BleGapEvtPhyUpdateT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 3)]
        public partial struct __Internal
        {
            internal byte status;
            internal byte tx_phy;
            internal byte rx_phy;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_phy_update_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtPhyUpdateT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtPhyUpdateT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtPhyUpdateT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtPhyUpdateT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtPhyUpdateT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtPhyUpdateT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtPhyUpdateT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtPhyUpdateT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtPhyUpdateT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtPhyUpdateT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtPhyUpdateT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtPhyUpdateT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtPhyUpdateT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtPhyUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtPhyUpdateT(global::NrfBleDriver.BleGapEvtPhyUpdateT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtPhyUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtPhyUpdateT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtPhyUpdateT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Status of the procedure, see</summary>
        public byte Status
        {
            get
            {
                return ((__Internal*)__Instance)->status;
            }

            set
            {
                ((__Internal*)__Instance)->status = value;
            }
        }

        /// <summary>TX PHY for this connection, see</summary>
        public byte TxPhy
        {
            get
            {
                return ((__Internal*)__Instance)->tx_phy;
            }

            set
            {
                ((__Internal*)__Instance)->tx_phy = value;
            }
        }

        /// <summary>RX PHY for this connection, see</summary>
        public byte RxPhy
        {
            get
            {
                return ((__Internal*)__Instance)->rx_phy;
            }

            set
            {
                ((__Internal*)__Instance)->rx_phy = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtSecParamsRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 5)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapSecParamsT.__Internal peer_params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_sec_params_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtSecParamsRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtSecParamsRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtSecParamsRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtSecParamsRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtSecParamsRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtSecParamsRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtSecParamsRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtSecParamsRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtSecParamsRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtSecParamsRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtSecParamsRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtSecParamsRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtSecParamsRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtSecParamsRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtSecParamsRequestT(global::NrfBleDriver.BleGapEvtSecParamsRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtSecParamsRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtSecParamsRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtSecParamsRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Initiator Security Parameters.</summary>
        public global::NrfBleDriver.BleGapSecParamsT PeerParams
        {
            get
            {
                return global::NrfBleDriver.BleGapSecParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->peer_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->peer_params = *(global::NrfBleDriver.BleGapSecParamsT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtSecInfoRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapAddrT.__Internal peer_addr;

            [FieldOffset(8)]
            internal global::NrfBleDriver.BleGapMasterIdT.__Internal master_id;

            [FieldOffset(18)]
            internal byte enc_info;

            [FieldOffset(18)]
            internal byte id_info;

            [FieldOffset(18)]
            internal byte sign_info;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_sec_info_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtSecInfoRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtSecInfoRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtSecInfoRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtSecInfoRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtSecInfoRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtSecInfoRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtSecInfoRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtSecInfoRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtSecInfoRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtSecInfoRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtSecInfoRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtSecInfoRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtSecInfoRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtSecInfoRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtSecInfoRequestT(global::NrfBleDriver.BleGapEvtSecInfoRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtSecInfoRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtSecInfoRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtSecInfoRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Bluetooth address of the peer device.</summary>
        public global::NrfBleDriver.BleGapAddrT PeerAddr
        {
            get
            {
                return global::NrfBleDriver.BleGapAddrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->peer_addr));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->peer_addr = *(global::NrfBleDriver.BleGapAddrT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Master Identification for LTK lookup.</summary>
        public global::NrfBleDriver.BleGapMasterIdT MasterId
        {
            get
            {
                return global::NrfBleDriver.BleGapMasterIdT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->master_id));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->master_id = *(global::NrfBleDriver.BleGapMasterIdT.__Internal*) value.__Instance;
            }
        }

        /// <summary>If 1, Encryption Information required.</summary>
        public byte EncInfo
        {
            get
            {
                return ((__Internal*)__Instance)->enc_info;
            }

            set
            {
                ((__Internal*)__Instance)->enc_info = value;
            }
        }

        /// <summary>If 1, Identity Information required.</summary>
        public byte IdInfo
        {
            get
            {
                return ((__Internal*)__Instance)->id_info;
            }

            set
            {
                ((__Internal*)__Instance)->id_info = value;
            }
        }

        /// <summary>If 1, Signing Information required.</summary>
        public byte SignInfo
        {
            get
            {
                return ((__Internal*)__Instance)->sign_info;
            }

            set
            {
                ((__Internal*)__Instance)->sign_info = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtPasskeyDisplayT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 7)]
        public partial struct __Internal
        {
            internal fixed byte passkey[6];
            internal byte match_request;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_passkey_display_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtPasskeyDisplayT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtPasskeyDisplayT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtPasskeyDisplayT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtPasskeyDisplayT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtPasskeyDisplayT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtPasskeyDisplayT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtPasskeyDisplayT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtPasskeyDisplayT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtPasskeyDisplayT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtPasskeyDisplayT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtPasskeyDisplayT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtPasskeyDisplayT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtPasskeyDisplayT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtPasskeyDisplayT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtPasskeyDisplayT(global::NrfBleDriver.BleGapEvtPasskeyDisplayT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtPasskeyDisplayT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtPasskeyDisplayT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtPasskeyDisplayT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>6-digit passkey in ASCII ('0'-'9' digits only).</summary>
        public byte[] Passkey
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->passkey, 6);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 6; i++)
                        ((__Internal*)__Instance)->passkey[i] = value[i];
                }
            }
        }

        /// <summary>
        /// <para>If 1 requires the application to report the match usingwith eitherif there is no match or</para>
        /// <para>if there is a match.</para>
        /// </summary>
        public byte MatchRequest
        {
            get
            {
                return ((__Internal*)__Instance)->match_request;
            }

            set
            {
                ((__Internal*)__Instance)->match_request = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtKeyPressedT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte kp_not;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_key_pressed_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtKeyPressedT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtKeyPressedT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtKeyPressedT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtKeyPressedT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtKeyPressedT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtKeyPressedT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtKeyPressedT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtKeyPressedT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtKeyPressedT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtKeyPressedT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtKeyPressedT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtKeyPressedT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtKeyPressedT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtKeyPressedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtKeyPressedT(global::NrfBleDriver.BleGapEvtKeyPressedT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtKeyPressedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtKeyPressedT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtKeyPressedT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Keypress notification type, see</summary>
        public byte KpNot
        {
            get
            {
                return ((__Internal*)__Instance)->kp_not;
            }

            set
            {
                ((__Internal*)__Instance)->kp_not = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtAuthKeyRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte key_type;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_auth_key_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtAuthKeyRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtAuthKeyRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtAuthKeyRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtAuthKeyRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtAuthKeyRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtAuthKeyRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtAuthKeyRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtAuthKeyRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtAuthKeyRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtAuthKeyRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtAuthKeyRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtAuthKeyRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtAuthKeyRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtAuthKeyRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtAuthKeyRequestT(global::NrfBleDriver.BleGapEvtAuthKeyRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtAuthKeyRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtAuthKeyRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtAuthKeyRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>See</summary>
        public byte KeyType
        {
            get
            {
                return ((__Internal*)__Instance)->key_type;
            }

            set
            {
                ((__Internal*)__Instance)->key_type = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtLescDhkeyRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr p_pk_peer;
            internal byte oobd_req;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_lesc_dhkey_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtLescDhkeyRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtLescDhkeyRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtLescDhkeyRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtLescDhkeyRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtLescDhkeyRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtLescDhkeyRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtLescDhkeyRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtLescDhkeyRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtLescDhkeyRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtLescDhkeyRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtLescDhkeyRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtLescDhkeyRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtLescDhkeyRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtLescDhkeyRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtLescDhkeyRequestT(global::NrfBleDriver.BleGapEvtLescDhkeyRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtLescDhkeyRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtLescDhkeyRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtLescDhkeyRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>LE Secure Connections remote P-256 Public Key. This will point to the application-supplied memory</para>
        /// <para>inside the keyset during the call to</para>
        /// </summary>
        public global::NrfBleDriver.BleGapLescP256PkT PPkPeer
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGapLescP256PkT.__GetOrCreateInstance(((__Internal*)__Instance)->p_pk_peer, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->p_pk_peer = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>LESC OOB data required. A call tois required to complete the procedure.</summary>
        public byte OobdReq
        {
            get
            {
                return ((__Internal*)__Instance)->oobd_req;
            }

            set
            {
                ((__Internal*)__Instance)->oobd_req = value;
            }
        }
    }

    /// <summary>Security levels supported.</summary>
    /// <remarks>See Bluetooth Specification Version 4.2 Volume 3, Part C, Chapter 10, Section 10.2.1.</remarks>
    public unsafe partial class BleGapSecLevelsT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte lv1;

            [FieldOffset(0)]
            internal byte lv2;

            [FieldOffset(0)]
            internal byte lv3;

            [FieldOffset(0)]
            internal byte lv4;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_sec_levels_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecLevelsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecLevelsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapSecLevelsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapSecLevelsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapSecLevelsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapSecLevelsT(native.ToPointer(), skipVTables);
        }

        internal static BleGapSecLevelsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapSecLevelsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapSecLevelsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapSecLevelsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapSecLevelsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapSecLevelsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapSecLevelsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecLevelsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapSecLevelsT(global::NrfBleDriver.BleGapSecLevelsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecLevelsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapSecLevelsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapSecLevelsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>If 1: Level 1 is supported.</summary>
        public byte Lv1
        {
            get
            {
                return ((__Internal*)__Instance)->lv1;
            }

            set
            {
                ((__Internal*)__Instance)->lv1 = value;
            }
        }

        /// <summary>If 1: Level 2 is supported.</summary>
        public byte Lv2
        {
            get
            {
                return ((__Internal*)__Instance)->lv2;
            }

            set
            {
                ((__Internal*)__Instance)->lv2 = value;
            }
        }

        /// <summary>If 1: Level 3 is supported.</summary>
        public byte Lv3
        {
            get
            {
                return ((__Internal*)__Instance)->lv3;
            }

            set
            {
                ((__Internal*)__Instance)->lv3 = value;
            }
        }

        /// <summary>If 1: Level 4 is supported.</summary>
        public byte Lv4
        {
            get
            {
                return ((__Internal*)__Instance)->lv4;
            }

            set
            {
                ((__Internal*)__Instance)->lv4 = value;
            }
        }
    }

    /// <summary>Encryption Key.</summary>
    public unsafe partial class BleGapEncKeyT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapEncInfoT.__Internal enc_info;
            internal global::NrfBleDriver.BleGapMasterIdT.__Internal master_id;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_enc_key_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEncKeyT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEncKeyT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEncKeyT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEncKeyT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEncKeyT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEncKeyT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEncKeyT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEncKeyT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEncKeyT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEncKeyT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEncKeyT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEncKeyT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEncKeyT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEncKeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEncKeyT(global::NrfBleDriver.BleGapEncKeyT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEncKeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEncKeyT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEncKeyT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Encryption Information.</summary>
        public global::NrfBleDriver.BleGapEncInfoT EncInfo
        {
            get
            {
                return global::NrfBleDriver.BleGapEncInfoT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->enc_info));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->enc_info = *(global::NrfBleDriver.BleGapEncInfoT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Master Identification.</summary>
        public global::NrfBleDriver.BleGapMasterIdT MasterId
        {
            get
            {
                return global::NrfBleDriver.BleGapMasterIdT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->master_id));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->master_id = *(global::NrfBleDriver.BleGapMasterIdT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Identity Key.</summary>
    public unsafe partial class BleGapIdKeyT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 23)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapIrkT.__Internal id_info;
            internal global::NrfBleDriver.BleGapAddrT.__Internal id_addr_info;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_id_key_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapIdKeyT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapIdKeyT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapIdKeyT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapIdKeyT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapIdKeyT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapIdKeyT(native.ToPointer(), skipVTables);
        }

        internal static BleGapIdKeyT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapIdKeyT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapIdKeyT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapIdKeyT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapIdKeyT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapIdKeyT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapIdKeyT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapIdKeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapIdKeyT(global::NrfBleDriver.BleGapIdKeyT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapIdKeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapIdKeyT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapIdKeyT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Identity Resolving Key.</summary>
        public global::NrfBleDriver.BleGapIrkT IdInfo
        {
            get
            {
                return global::NrfBleDriver.BleGapIrkT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->id_info));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->id_info = *(global::NrfBleDriver.BleGapIrkT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Identity Address.</summary>
        public global::NrfBleDriver.BleGapAddrT IdAddrInfo
        {
            get
            {
                return global::NrfBleDriver.BleGapAddrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->id_addr_info));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->id_addr_info = *(global::NrfBleDriver.BleGapAddrT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Security Keys.</summary>
    public unsafe partial class BleGapSecKeysT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr p_enc_key;
            internal __IntPtr p_id_key;
            internal __IntPtr p_sign_key;
            internal __IntPtr p_pk;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_sec_keys_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecKeysT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecKeysT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapSecKeysT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapSecKeysT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapSecKeysT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapSecKeysT(native.ToPointer(), skipVTables);
        }

        internal static BleGapSecKeysT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapSecKeysT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapSecKeysT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapSecKeysT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapSecKeysT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapSecKeysT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapSecKeysT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecKeysT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapSecKeysT(global::NrfBleDriver.BleGapSecKeysT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecKeysT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapSecKeysT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapSecKeysT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Encryption Key, or NULL.</summary>
        public global::NrfBleDriver.BleGapEncKeyT PEncKey
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGapEncKeyT.__GetOrCreateInstance(((__Internal*)__Instance)->p_enc_key, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->p_enc_key = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Identity Key, or NULL.</summary>
        public global::NrfBleDriver.BleGapIdKeyT PIdKey
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGapIdKeyT.__GetOrCreateInstance(((__Internal*)__Instance)->p_id_key, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->p_id_key = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Signing Key, or NULL.</summary>
        public global::NrfBleDriver.BleGapSignInfoT PSignKey
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGapSignInfoT.__GetOrCreateInstance(((__Internal*)__Instance)->p_sign_key, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->p_sign_key = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>
        /// <para>LE Secure Connections P-256 Public Key. When in debug mode the application must use the value defined</para>
        /// <para>in the Core Bluetooth Specification v4.2 Vol.3, Part H, Section 2.3.5.6.1</para>
        /// </summary>
        public global::NrfBleDriver.BleGapLescP256PkT PPk
        {
            get
            {
                var __result0 = global::NrfBleDriver.BleGapLescP256PkT.__GetOrCreateInstance(((__Internal*)__Instance)->p_pk, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->p_pk = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Security key set for both local and peer keys.</summary>
    public unsafe partial class BleGapSecKeysetT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapSecKeysT.__Internal keys_own;
            internal global::NrfBleDriver.BleGapSecKeysT.__Internal keys_peer;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_sec_keyset_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecKeysetT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapSecKeysetT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapSecKeysetT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapSecKeysetT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapSecKeysetT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapSecKeysetT(native.ToPointer(), skipVTables);
        }

        internal static BleGapSecKeysetT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapSecKeysetT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapSecKeysetT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapSecKeysetT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapSecKeysetT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapSecKeysetT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapSecKeysetT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecKeysetT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapSecKeysetT(global::NrfBleDriver.BleGapSecKeysetT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapSecKeysetT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapSecKeysetT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapSecKeysetT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Keys distributed by the local device. For LE Secure Connections the encryption key will be generated locally and will always be stored if bonding.</summary>
        public global::NrfBleDriver.BleGapSecKeysT KeysOwn
        {
            get
            {
                return global::NrfBleDriver.BleGapSecKeysT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->keys_own));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->keys_own = *(global::NrfBleDriver.BleGapSecKeysT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Keys distributed by the remote device. For LE Secure Connections, p_enc_key must always be NULL.</summary>
        public global::NrfBleDriver.BleGapSecKeysT KeysPeer
        {
            get
            {
                return global::NrfBleDriver.BleGapSecKeysT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->keys_peer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->keys_peer = *(global::NrfBleDriver.BleGapSecKeysT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Data Length Update Procedure parameters.</summary>
    public unsafe partial class BleGapDataLengthParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort max_tx_octets;
            internal ushort max_rx_octets;
            internal ushort max_tx_time_us;
            internal ushort max_rx_time_us;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_data_length_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapDataLengthParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapDataLengthParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapDataLengthParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapDataLengthParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapDataLengthParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapDataLengthParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGapDataLengthParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapDataLengthParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapDataLengthParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapDataLengthParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapDataLengthParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapDataLengthParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapDataLengthParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapDataLengthParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapDataLengthParamsT(global::NrfBleDriver.BleGapDataLengthParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapDataLengthParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapDataLengthParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapDataLengthParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Maximum number of payload octets that a Controller supports for transmission of a single Link Layer Data Channel PDU.</summary>
        public ushort MaxTxOctets
        {
            get
            {
                return ((__Internal*)__Instance)->max_tx_octets;
            }

            set
            {
                ((__Internal*)__Instance)->max_tx_octets = value;
            }
        }

        /// <summary>Maximum number of payload octets that a Controller supports for reception of a single Link Layer Data Channel PDU.</summary>
        public ushort MaxRxOctets
        {
            get
            {
                return ((__Internal*)__Instance)->max_rx_octets;
            }

            set
            {
                ((__Internal*)__Instance)->max_rx_octets = value;
            }
        }

        /// <summary>Maximum time, in microseconds, that a Controller supports for transmission of a single Link Layer Data Channel PDU.</summary>
        public ushort MaxTxTimeUs
        {
            get
            {
                return ((__Internal*)__Instance)->max_tx_time_us;
            }

            set
            {
                ((__Internal*)__Instance)->max_tx_time_us = value;
            }
        }

        /// <summary>Maximum time, in microseconds, that a Controller supports for reception of a single Link Layer Data Channel PDU.</summary>
        public ushort MaxRxTimeUs
        {
            get
            {
                return ((__Internal*)__Instance)->max_rx_time_us;
            }

            set
            {
                ((__Internal*)__Instance)->max_rx_time_us = value;
            }
        }
    }

    /// <summary>Data Length Update Procedure local limitation.</summary>
    public unsafe partial class BleGapDataLengthLimitationT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 6)]
        public partial struct __Internal
        {
            internal ushort tx_payload_limited_octets;
            internal ushort rx_payload_limited_octets;
            internal ushort tx_rx_time_limited_us;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_data_length_limitation_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapDataLengthLimitationT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapDataLengthLimitationT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapDataLengthLimitationT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapDataLengthLimitationT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapDataLengthLimitationT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapDataLengthLimitationT(native.ToPointer(), skipVTables);
        }

        internal static BleGapDataLengthLimitationT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapDataLengthLimitationT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapDataLengthLimitationT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapDataLengthLimitationT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapDataLengthLimitationT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapDataLengthLimitationT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapDataLengthLimitationT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapDataLengthLimitationT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapDataLengthLimitationT(global::NrfBleDriver.BleGapDataLengthLimitationT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapDataLengthLimitationT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapDataLengthLimitationT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapDataLengthLimitationT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>If &gt; 0, the requested TX packet length is too long by this many octets.</summary>
        public ushort TxPayloadLimitedOctets
        {
            get
            {
                return ((__Internal*)__Instance)->tx_payload_limited_octets;
            }

            set
            {
                ((__Internal*)__Instance)->tx_payload_limited_octets = value;
            }
        }

        /// <summary>If &gt; 0, the requested RX packet length is too long by this many octets.</summary>
        public ushort RxPayloadLimitedOctets
        {
            get
            {
                return ((__Internal*)__Instance)->rx_payload_limited_octets;
            }

            set
            {
                ((__Internal*)__Instance)->rx_payload_limited_octets = value;
            }
        }

        /// <summary>If &gt; 0, the requested combination of TX and RX packet lengths is too long by this many microseconds.</summary>
        public ushort TxRxTimeLimitedUs
        {
            get
            {
                return ((__Internal*)__Instance)->tx_rx_time_limited_us;
            }

            set
            {
                ((__Internal*)__Instance)->tx_rx_time_limited_us = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtAuthStatusT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 6)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte auth_status;

            [FieldOffset(1)]
            internal byte error_src;

            [FieldOffset(1)]
            internal byte bonded;

            [FieldOffset(1)]
            internal byte lesc;

            [FieldOffset(2)]
            internal global::NrfBleDriver.BleGapSecLevelsT.__Internal sm1_levels;

            [FieldOffset(3)]
            internal global::NrfBleDriver.BleGapSecLevelsT.__Internal sm2_levels;

            [FieldOffset(4)]
            internal global::NrfBleDriver.BleGapSecKdistT.__Internal kdist_own;

            [FieldOffset(5)]
            internal global::NrfBleDriver.BleGapSecKdistT.__Internal kdist_peer;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_auth_status_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtAuthStatusT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtAuthStatusT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtAuthStatusT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtAuthStatusT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtAuthStatusT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtAuthStatusT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtAuthStatusT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtAuthStatusT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtAuthStatusT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtAuthStatusT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtAuthStatusT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtAuthStatusT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtAuthStatusT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtAuthStatusT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtAuthStatusT(global::NrfBleDriver.BleGapEvtAuthStatusT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtAuthStatusT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtAuthStatusT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtAuthStatusT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Authentication status, see</summary>
        public byte AuthStatus
        {
            get
            {
                return ((__Internal*)__Instance)->auth_status;
            }

            set
            {
                ((__Internal*)__Instance)->auth_status = value;
            }
        }

        /// <summary>On error, source that caused the failure, see</summary>
        public byte ErrorSrc
        {
            get
            {
                return ((__Internal*)__Instance)->error_src;
            }

            set
            {
                ((__Internal*)__Instance)->error_src = value;
            }
        }

        /// <summary>Procedure resulted in a bond.</summary>
        public byte Bonded
        {
            get
            {
                return ((__Internal*)__Instance)->bonded;
            }

            set
            {
                ((__Internal*)__Instance)->bonded = value;
            }
        }

        /// <summary>Procedure resulted in a LE Secure Connection.</summary>
        public byte Lesc
        {
            get
            {
                return ((__Internal*)__Instance)->lesc;
            }

            set
            {
                ((__Internal*)__Instance)->lesc = value;
            }
        }

        /// <summary>Levels supported in Security Mode 1.</summary>
        public global::NrfBleDriver.BleGapSecLevelsT Sm1Levels
        {
            get
            {
                return global::NrfBleDriver.BleGapSecLevelsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sm1_levels));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sm1_levels = *(global::NrfBleDriver.BleGapSecLevelsT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Levels supported in Security Mode 2.</summary>
        public global::NrfBleDriver.BleGapSecLevelsT Sm2Levels
        {
            get
            {
                return global::NrfBleDriver.BleGapSecLevelsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sm2_levels));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sm2_levels = *(global::NrfBleDriver.BleGapSecLevelsT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Bitmap stating which keys were exchanged (distributed) by the local device. If bonding with LE Secure Connections, the enc bit will be always set.</summary>
        public global::NrfBleDriver.BleGapSecKdistT KdistOwn
        {
            get
            {
                return global::NrfBleDriver.BleGapSecKdistT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->kdist_own));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->kdist_own = *(global::NrfBleDriver.BleGapSecKdistT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Bitmap stating which keys were exchanged (distributed) by the remote device. If bonding with LE Secure Connections, the enc bit will never be set.</summary>
        public global::NrfBleDriver.BleGapSecKdistT KdistPeer
        {
            get
            {
                return global::NrfBleDriver.BleGapSecKdistT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->kdist_peer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->kdist_peer = *(global::NrfBleDriver.BleGapSecKdistT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtConnSecUpdateT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapConnSecT.__Internal conn_sec;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_conn_sec_update_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnSecUpdateT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnSecUpdateT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtConnSecUpdateT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtConnSecUpdateT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtConnSecUpdateT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtConnSecUpdateT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtConnSecUpdateT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtConnSecUpdateT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtConnSecUpdateT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtConnSecUpdateT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtConnSecUpdateT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtConnSecUpdateT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtConnSecUpdateT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnSecUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtConnSecUpdateT(global::NrfBleDriver.BleGapEvtConnSecUpdateT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnSecUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtConnSecUpdateT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtConnSecUpdateT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection security level.</summary>
        public global::NrfBleDriver.BleGapConnSecT ConnSec
        {
            get
            {
                return global::NrfBleDriver.BleGapConnSecT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->conn_sec));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->conn_sec = *(global::NrfBleDriver.BleGapConnSecT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtTimeoutT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte src;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_timeout_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtTimeoutT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtTimeoutT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtTimeoutT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtTimeoutT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtTimeoutT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtTimeoutT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtTimeoutT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtTimeoutT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtTimeoutT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtTimeoutT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtTimeoutT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtTimeoutT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtTimeoutT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtTimeoutT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtTimeoutT(global::NrfBleDriver.BleGapEvtTimeoutT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtTimeoutT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtTimeoutT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtTimeoutT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Source of timeout event, see</summary>
        public byte Src
        {
            get
            {
                return ((__Internal*)__Instance)->src;
            }

            set
            {
                ((__Internal*)__Instance)->src = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtRssiChangedT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal sbyte rssi;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_rssi_changed_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtRssiChangedT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtRssiChangedT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtRssiChangedT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtRssiChangedT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtRssiChangedT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtRssiChangedT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtRssiChangedT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtRssiChangedT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtRssiChangedT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtRssiChangedT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtRssiChangedT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtRssiChangedT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtRssiChangedT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtRssiChangedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtRssiChangedT(global::NrfBleDriver.BleGapEvtRssiChangedT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtRssiChangedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtRssiChangedT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtRssiChangedT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Received Signal Strength Indication in dBm.</summary>
        public sbyte Rssi
        {
            get
            {
                return ((__Internal*)__Instance)->rssi;
            }

            set
            {
                ((__Internal*)__Instance)->rssi = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtAdvReportT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 47)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapAddrT.__Internal peer_addr;

            [FieldOffset(7)]
            internal global::NrfBleDriver.BleGapAddrT.__Internal direct_addr;

            [FieldOffset(14)]
            internal sbyte rssi;

            [FieldOffset(15)]
            internal byte scan_rsp;

            [FieldOffset(15)]
            internal byte type;

            [FieldOffset(15)]
            internal byte dlen;

            [FieldOffset(16)]
            internal fixed byte data[31];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_adv_report_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtAdvReportT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtAdvReportT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtAdvReportT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtAdvReportT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtAdvReportT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtAdvReportT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtAdvReportT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtAdvReportT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtAdvReportT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtAdvReportT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtAdvReportT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtAdvReportT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtAdvReportT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtAdvReportT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtAdvReportT(global::NrfBleDriver.BleGapEvtAdvReportT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtAdvReportT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtAdvReportT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtAdvReportT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Bluetooth address of the peer device. If the peer_addr resolved:is set to 1</para>
        /// <para>and the address is the device's identity address.</para>
        /// </summary>
        public global::NrfBleDriver.BleGapAddrT PeerAddr
        {
            get
            {
                return global::NrfBleDriver.BleGapAddrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->peer_addr));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->peer_addr = *(global::NrfBleDriver.BleGapAddrT.__Internal*) value.__Instance;
            }
        }

        /// <summary>
        /// <para>Set when the scanner is unable to resolve the private resolvable address of the initiator</para>
        /// <para>field of a directed advertisement packet and the scanner has been enabled to report this in</para>
        /// </summary>
        public global::NrfBleDriver.BleGapAddrT DirectAddr
        {
            get
            {
                return global::NrfBleDriver.BleGapAddrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->direct_addr));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->direct_addr = *(global::NrfBleDriver.BleGapAddrT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Received Signal Strength Indication in dBm.</summary>
        public sbyte Rssi
        {
            get
            {
                return ((__Internal*)__Instance)->rssi;
            }

            set
            {
                ((__Internal*)__Instance)->rssi = value;
            }
        }

        /// <summary>If 1, the report corresponds to a scan response and the type field may be ignored.</summary>
        public byte ScanRsp
        {
            get
            {
                return ((__Internal*)__Instance)->scan_rsp;
            }

            set
            {
                ((__Internal*)__Instance)->scan_rsp = value;
            }
        }

        /// <summary>SeeOnly valid if the scan_rsp field is 0.</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Advertising or scan response data length.</summary>
        public byte Dlen
        {
            get
            {
                return ((__Internal*)__Instance)->dlen;
            }

            set
            {
                ((__Internal*)__Instance)->dlen = value;
            }
        }

        /// <summary>Advertising or scan response data.</summary>
        public byte[] Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->data, 31);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 31; i++)
                        ((__Internal*)__Instance)->data[i] = value[i];
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtSecRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte bond;

            [FieldOffset(0)]
            internal byte mitm;

            [FieldOffset(0)]
            internal byte lesc;

            [FieldOffset(0)]
            internal byte keypress;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_sec_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtSecRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtSecRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtSecRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtSecRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtSecRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtSecRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtSecRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtSecRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtSecRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtSecRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtSecRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtSecRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtSecRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtSecRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtSecRequestT(global::NrfBleDriver.BleGapEvtSecRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtSecRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtSecRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtSecRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Perform bonding.</summary>
        public byte Bond
        {
            get
            {
                return ((__Internal*)__Instance)->bond;
            }

            set
            {
                ((__Internal*)__Instance)->bond = value;
            }
        }

        /// <summary>Man In The Middle protection requested.</summary>
        public byte Mitm
        {
            get
            {
                return ((__Internal*)__Instance)->mitm;
            }

            set
            {
                ((__Internal*)__Instance)->mitm = value;
            }
        }

        /// <summary>LE Secure Connections requested.</summary>
        public byte Lesc
        {
            get
            {
                return ((__Internal*)__Instance)->lesc;
            }

            set
            {
                ((__Internal*)__Instance)->lesc = value;
            }
        }

        /// <summary>Generation of keypress notifications requested.</summary>
        public byte Keypress
        {
            get
            {
                return ((__Internal*)__Instance)->keypress;
            }

            set
            {
                ((__Internal*)__Instance)->keypress = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtConnParamUpdateRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapConnParamsT.__Internal conn_params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_conn_param_update_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtConnParamUpdateRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtConnParamUpdateRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtConnParamUpdateRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtConnParamUpdateRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtConnParamUpdateRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtConnParamUpdateRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtConnParamUpdateRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtConnParamUpdateRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtConnParamUpdateRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtConnParamUpdateRequestT(global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>GAP Connection Parameters.</summary>
        public global::NrfBleDriver.BleGapConnParamsT ConnParams
        {
            get
            {
                return global::NrfBleDriver.BleGapConnParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->conn_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->conn_params = *(global::NrfBleDriver.BleGapConnParamsT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtScanReqReportT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal sbyte rssi;
            internal global::NrfBleDriver.BleGapAddrT.__Internal peer_addr;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_scan_req_report_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtScanReqReportT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtScanReqReportT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtScanReqReportT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtScanReqReportT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtScanReqReportT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtScanReqReportT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtScanReqReportT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtScanReqReportT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtScanReqReportT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtScanReqReportT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtScanReqReportT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtScanReqReportT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtScanReqReportT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtScanReqReportT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtScanReqReportT(global::NrfBleDriver.BleGapEvtScanReqReportT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtScanReqReportT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtScanReqReportT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtScanReqReportT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Received Signal Strength Indication in dBm.</summary>
        public sbyte Rssi
        {
            get
            {
                return ((__Internal*)__Instance)->rssi;
            }

            set
            {
                ((__Internal*)__Instance)->rssi = value;
            }
        }

        /// <summary>
        /// <para>Bluetooth address of the peer device. If the peer_addr resolved:is set to 1</para>
        /// <para>and the address is the device's identity address.</para>
        /// </summary>
        public global::NrfBleDriver.BleGapAddrT PeerAddr
        {
            get
            {
                return global::NrfBleDriver.BleGapAddrT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->peer_addr));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->peer_addr = *(global::NrfBleDriver.BleGapAddrT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtDataLengthUpdateRequestT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapDataLengthParamsT.__Internal peer_params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_data_length_update_request_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtDataLengthUpdateRequestT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtDataLengthUpdateRequestT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtDataLengthUpdateRequestT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtDataLengthUpdateRequestT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtDataLengthUpdateRequestT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtDataLengthUpdateRequestT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtDataLengthUpdateRequestT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtDataLengthUpdateRequestT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtDataLengthUpdateRequestT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtDataLengthUpdateRequestT(global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Peer data length parameters.</summary>
        public global::NrfBleDriver.BleGapDataLengthParamsT PeerParams
        {
            get
            {
                return global::NrfBleDriver.BleGapDataLengthParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->peer_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->peer_params = *(global::NrfBleDriver.BleGapDataLengthParamsT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGapEvtDataLengthUpdateT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapDataLengthParamsT.__Internal effective_params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_data_length_update_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtDataLengthUpdateT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtDataLengthUpdateT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtDataLengthUpdateT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtDataLengthUpdateT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtDataLengthUpdateT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtDataLengthUpdateT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtDataLengthUpdateT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtDataLengthUpdateT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtDataLengthUpdateT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtDataLengthUpdateT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtDataLengthUpdateT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtDataLengthUpdateT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtDataLengthUpdateT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtDataLengthUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtDataLengthUpdateT(global::NrfBleDriver.BleGapEvtDataLengthUpdateT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtDataLengthUpdateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtDataLengthUpdateT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtDataLengthUpdateT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The effective data length parameters.</summary>
        public global::NrfBleDriver.BleGapDataLengthParamsT EffectiveParams
        {
            get
            {
                return global::NrfBleDriver.BleGapDataLengthParamsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->effective_params));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->effective_params = *(global::NrfBleDriver.BleGapDataLengthParamsT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>GAP event structure.</summary>
    public unsafe partial class BleGapEvtT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal global::NrfBleDriver.BleGapEvtT.Params.__Internal @params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_evt_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Params
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtConnectedT.__Internal connected;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtDisconnectedT.__Internal disconnected;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtConnParamUpdateT.__Internal conn_param_update;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtSecParamsRequestT.__Internal sec_params_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtSecInfoRequestT.__Internal sec_info_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtPasskeyDisplayT.__Internal passkey_display;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtKeyPressedT.__Internal key_pressed;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtAuthKeyRequestT.__Internal auth_key_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtLescDhkeyRequestT.__Internal lesc_dhkey_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtAuthStatusT.__Internal auth_status;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtConnSecUpdateT.__Internal conn_sec_update;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtTimeoutT.__Internal timeout;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtRssiChangedT.__Internal rssi_changed;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtAdvReportT.__Internal adv_report;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtSecRequestT.__Internal sec_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT.__Internal conn_param_update_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtScanReqReportT.__Internal scan_req_report;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtPhyUpdateRequestT.__Internal phy_update_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtPhyUpdateT.__Internal phy_update;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT.__Internal data_length_update_request;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGapEvtDataLengthUpdateT.__Internal data_length_update;

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-params>@ble_gap_evt_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Params.__Internal __instance;
            internal Params.__Internal __Instance => __instance;

            internal static Params __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Params(native.ToPointer(), skipVTables);
            }

            internal static Params __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Params(native, skipVTables);
            }

            private Params(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Params(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleGapEvtT.Params.__Internal*) native;
            }

            public Params(global::NrfBleDriver.BleGapEvtT.Params __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>Connected Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtConnectedT Connected
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtConnectedT.__CreateInstance(__instance.connected);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.connected = *(global::NrfBleDriver.BleGapEvtConnectedT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Disconnected Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtDisconnectedT Disconnected
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtDisconnectedT.__CreateInstance(__instance.disconnected);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.disconnected = *(global::NrfBleDriver.BleGapEvtDisconnectedT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Connection Parameter Update Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtConnParamUpdateT ConnParamUpdate
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtConnParamUpdateT.__CreateInstance(__instance.conn_param_update);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.conn_param_update = *(global::NrfBleDriver.BleGapEvtConnParamUpdateT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Security Parameters Request Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtSecParamsRequestT SecParamsRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtSecParamsRequestT.__CreateInstance(__instance.sec_params_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.sec_params_request = *(global::NrfBleDriver.BleGapEvtSecParamsRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Security Information Request Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtSecInfoRequestT SecInfoRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtSecInfoRequestT.__CreateInstance(__instance.sec_info_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.sec_info_request = *(global::NrfBleDriver.BleGapEvtSecInfoRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Passkey Display Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtPasskeyDisplayT PasskeyDisplay
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtPasskeyDisplayT.__CreateInstance(__instance.passkey_display);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.passkey_display = *(global::NrfBleDriver.BleGapEvtPasskeyDisplayT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Key Pressed Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtKeyPressedT KeyPressed
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtKeyPressedT.__CreateInstance(__instance.key_pressed);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.key_pressed = *(global::NrfBleDriver.BleGapEvtKeyPressedT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Authentication Key Request Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtAuthKeyRequestT AuthKeyRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtAuthKeyRequestT.__CreateInstance(__instance.auth_key_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.auth_key_request = *(global::NrfBleDriver.BleGapEvtAuthKeyRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>LE Secure Connections DHKey calculation request.</summary>
            public global::NrfBleDriver.BleGapEvtLescDhkeyRequestT LescDhkeyRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtLescDhkeyRequestT.__CreateInstance(__instance.lesc_dhkey_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.lesc_dhkey_request = *(global::NrfBleDriver.BleGapEvtLescDhkeyRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Authentication Status Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtAuthStatusT AuthStatus
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtAuthStatusT.__CreateInstance(__instance.auth_status);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.auth_status = *(global::NrfBleDriver.BleGapEvtAuthStatusT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Connection Security Update Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtConnSecUpdateT ConnSecUpdate
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtConnSecUpdateT.__CreateInstance(__instance.conn_sec_update);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.conn_sec_update = *(global::NrfBleDriver.BleGapEvtConnSecUpdateT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Timeout Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtTimeoutT Timeout
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtTimeoutT.__CreateInstance(__instance.timeout);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.timeout = *(global::NrfBleDriver.BleGapEvtTimeoutT.__Internal*) value.__Instance;
                }
            }

            /// <summary>RSSI Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtRssiChangedT RssiChanged
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtRssiChangedT.__CreateInstance(__instance.rssi_changed);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.rssi_changed = *(global::NrfBleDriver.BleGapEvtRssiChangedT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Advertising Report Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtAdvReportT AdvReport
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtAdvReportT.__CreateInstance(__instance.adv_report);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.adv_report = *(global::NrfBleDriver.BleGapEvtAdvReportT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Security Request Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtSecRequestT SecRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtSecRequestT.__CreateInstance(__instance.sec_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.sec_request = *(global::NrfBleDriver.BleGapEvtSecRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Connection Parameter Update Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT ConnParamUpdateRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT.__CreateInstance(__instance.conn_param_update_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.conn_param_update_request = *(global::NrfBleDriver.BleGapEvtConnParamUpdateRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Scan Request Report Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtScanReqReportT ScanReqReport
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtScanReqReportT.__CreateInstance(__instance.scan_req_report);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.scan_req_report = *(global::NrfBleDriver.BleGapEvtScanReqReportT.__Internal*) value.__Instance;
                }
            }

            /// <summary>PHY Update Request Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtPhyUpdateRequestT PhyUpdateRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtPhyUpdateRequestT.__CreateInstance(__instance.phy_update_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.phy_update_request = *(global::NrfBleDriver.BleGapEvtPhyUpdateRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>PHY Update Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtPhyUpdateT PhyUpdate
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtPhyUpdateT.__CreateInstance(__instance.phy_update);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.phy_update = *(global::NrfBleDriver.BleGapEvtPhyUpdateT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Data Length Update Request Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT DataLengthUpdateRequest
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT.__CreateInstance(__instance.data_length_update_request);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.data_length_update_request = *(global::NrfBleDriver.BleGapEvtDataLengthUpdateRequestT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Data Length Update Event Parameters.</summary>
            public global::NrfBleDriver.BleGapEvtDataLengthUpdateT DataLengthUpdate
            {
                get
                {
                    return global::NrfBleDriver.BleGapEvtDataLengthUpdateT.__CreateInstance(__instance.data_length_update);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.data_length_update = *(global::NrfBleDriver.BleGapEvtDataLengthUpdateT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapEvtT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapEvtT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapEvtT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapEvtT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapEvtT(native.ToPointer(), skipVTables);
        }

        internal static BleGapEvtT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapEvtT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapEvtT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapEvtT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapEvtT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapEvtT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapEvtT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapEvtT(global::NrfBleDriver.BleGapEvtT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapEvtT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapEvtT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle on which event occurred.</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>Event Parameters.</summary>
        public global::NrfBleDriver.BleGapEvtT.Params @params
        {
            get
            {
                return global::NrfBleDriver.BleGapEvtT.Params.__CreateInstance(((__Internal*)__Instance)->@params);
            }

            set
            {
                ((__Internal*)__Instance)->@params = value.__Instance;
            }
        }
    }

    /// <summary>BLE GAP connection configuration parameters, set with</summary>
    /// <remarks>
    /// <para>::NRF_ERROR_CONN_COUNT     The connection count for the connection configurations is zero.</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  One or more of the following is true:</para>
    /// <para>- The sum of conn_count for all connection configurations combined exceeds UINT8_MAX.</para>
    /// <para>- The event length is smaller than</para>
    /// </remarks>
    public unsafe partial class BleGapConnCfgT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal byte conn_count;
            internal ushort event_length;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_conn_cfg_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnCfgT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapConnCfgT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapConnCfgT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapConnCfgT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapConnCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapConnCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleGapConnCfgT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapConnCfgT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapConnCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapConnCfgT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapConnCfgT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapConnCfgT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapConnCfgT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapConnCfgT(global::NrfBleDriver.BleGapConnCfgT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapConnCfgT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapConnCfgT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The number of concurrent connections the application can create with this configuration.</para>
        /// <para>The default and minimum value is</para>
        /// </summary>
        public byte ConnCount
        {
            get
            {
                return ((__Internal*)__Instance)->conn_count;
            }

            set
            {
                ((__Internal*)__Instance)->conn_count = value;
            }
        }

        /// <summary>
        /// <para>The time set aside for this connection on every connection interval in 1.25 ms units.</para>
        /// <para>The default value isthe minimum value isThe event length and the connection interval are the primary parameters</para>
        /// <para>for setting the throughput of a connection.</para>
        /// <para>See the SoftDevice Specification for details on throughput.</para>
        /// </summary>
        public ushort EventLength
        {
            get
            {
                return ((__Internal*)__Instance)->event_length;
            }

            set
            {
                ((__Internal*)__Instance)->event_length = value;
            }
        }
    }

    /// <summary>Configuration of maximum concurrent connections in the different connected roles, set with</summary>
    /// <remarks>
    /// <para>::NRF_ERROR_CONN_COUNT     The sum of periph_role_count and central_role_count is too</para>
    /// <para>large. The maximum supported sum of concurrent connections is</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  central_sec_count is larger than central_role_count.</para>
    /// </remarks>
    public unsafe partial class BleGapCfgRoleCountT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 3)]
        public partial struct __Internal
        {
            internal byte periph_role_count;
            internal byte central_role_count;
            internal byte central_sec_count;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_cfg_role_count_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapCfgRoleCountT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapCfgRoleCountT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapCfgRoleCountT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapCfgRoleCountT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapCfgRoleCountT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapCfgRoleCountT(native.ToPointer(), skipVTables);
        }

        internal static BleGapCfgRoleCountT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapCfgRoleCountT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapCfgRoleCountT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapCfgRoleCountT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapCfgRoleCountT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapCfgRoleCountT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapCfgRoleCountT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapCfgRoleCountT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapCfgRoleCountT(global::NrfBleDriver.BleGapCfgRoleCountT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapCfgRoleCountT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapCfgRoleCountT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapCfgRoleCountT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Maximum number of connections concurrently acting as a peripheral. Default value is</summary>
        public byte PeriphRoleCount
        {
            get
            {
                return ((__Internal*)__Instance)->periph_role_count;
            }

            set
            {
                ((__Internal*)__Instance)->periph_role_count = value;
            }
        }

        /// <summary>Maximum number of connections concurrently acting as a central. Default value is</summary>
        public byte CentralRoleCount
        {
            get
            {
                return ((__Internal*)__Instance)->central_role_count;
            }

            set
            {
                ((__Internal*)__Instance)->central_role_count = value;
            }
        }

        /// <summary>Number of SMP instances shared between all connections acting as a central. Default value is</summary>
        public byte CentralSecCount
        {
            get
            {
                return ((__Internal*)__Instance)->central_sec_count;
            }

            set
            {
                ((__Internal*)__Instance)->central_sec_count = value;
            }
        }
    }

    /// <summary>Device name and its properties, set with</summary>
    /// <remarks>
    /// <para>If the device name is not configured, the default device name will bethe maximum device name length will bevloc will be set toand the device name</para>
    /// <para>will have no write access.</para>
    /// <para>Ifis more thanand vloc is set tothe attribute table size must be increased to have room for the longer device name (see</para>
    /// <para>and</para>
    /// <para>If vloc is:</para>
    /// <para>- p_value must point to non-volatile memory (flash) or be NULL.</para>
    /// <para>- If p_value is NULL, the device name will initially be empty.</para>
    /// <para>If vloc is:</para>
    /// <para>- p_value cannot be NULL.</para>
    /// <para>- If the device name is writable, p_value must point to volatile memory (RAM).</para>
    /// <para>::NRF_ERROR_INVALID_PARAM  One or more of the following is true:</para>
    /// <para>- Invalid device name location (vloc).</para>
    /// <para>- Invalid device name security mode.</para>
    /// <para>::NRF_ERROR_INVALID_LENGTH One or more of the following is true:</para>
    /// <para>- The device name length is invalid (must be between 0 and- The device name length is too long for the given Attribute Table.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED  Device name security mode is not supported.</para>
    /// </remarks>
    public unsafe partial class BleGapCfgDeviceNameT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleGapConnSecModeT.__Internal write_perm;
            internal byte vloc;
            internal __IntPtr p_value;
            internal ushort current_len;
            internal ushort max_len;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_cfg_device_name_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapCfgDeviceNameT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapCfgDeviceNameT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapCfgDeviceNameT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapCfgDeviceNameT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapCfgDeviceNameT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapCfgDeviceNameT(native.ToPointer(), skipVTables);
        }

        internal static BleGapCfgDeviceNameT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapCfgDeviceNameT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapCfgDeviceNameT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapCfgDeviceNameT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapCfgDeviceNameT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapCfgDeviceNameT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapCfgDeviceNameT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapCfgDeviceNameT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapCfgDeviceNameT(global::NrfBleDriver.BleGapCfgDeviceNameT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapCfgDeviceNameT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapCfgDeviceNameT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapCfgDeviceNameT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Write permissions.</summary>
        public global::NrfBleDriver.BleGapConnSecModeT WritePerm
        {
            get
            {
                return global::NrfBleDriver.BleGapConnSecModeT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->write_perm));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->write_perm = *(global::NrfBleDriver.BleGapConnSecModeT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Value location, see</summary>
        public byte Vloc
        {
            get
            {
                return ((__Internal*)__Instance)->vloc;
            }

            set
            {
                ((__Internal*)__Instance)->vloc = value;
            }
        }

        /// <summary>Pointer to where the value (device name) is stored or will be stored.</summary>
        public byte* PValue
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_value;
            }

            set
            {
                ((__Internal*)__Instance)->p_value = (__IntPtr) value;
            }
        }

        /// <summary>Current length in bytes of the memory pointed to by p_value.</summary>
        public ushort CurrentLen
        {
            get
            {
                return ((__Internal*)__Instance)->current_len;
            }

            set
            {
                ((__Internal*)__Instance)->current_len = value;
            }
        }

        /// <summary>Maximum length in bytes of the memory pointed to by p_value.</summary>
        public ushort MaxLen
        {
            get
            {
                return ((__Internal*)__Instance)->max_len;
            }

            set
            {
                ((__Internal*)__Instance)->max_len = value;
            }
        }
    }

    /// <summary>Configuration structure for GAP configurations.</summary>
    public unsafe partial struct BleGapCfgT
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapCfgRoleCountT.__Internal role_count_cfg;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapCfgDeviceNameT.__Internal device_name_cfg;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_cfg_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        private BleGapCfgT.__Internal __instance;
        internal BleGapCfgT.__Internal __Instance => __instance;

        internal static BleGapCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleGapCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapCfgT(native, skipVTables);
        }

        private BleGapCfgT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private BleGapCfgT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NrfBleDriver.BleGapCfgT.__Internal*) native;
        }

        public BleGapCfgT(global::NrfBleDriver.BleGapCfgT __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>Role count configuration, cfg_id is</summary>
        public global::NrfBleDriver.BleGapCfgRoleCountT RoleCountCfg
        {
            get
            {
                return global::NrfBleDriver.BleGapCfgRoleCountT.__CreateInstance(__instance.role_count_cfg);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.role_count_cfg = *(global::NrfBleDriver.BleGapCfgRoleCountT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Device name configuration, cfg_id is</summary>
        public global::NrfBleDriver.BleGapCfgDeviceNameT DeviceNameCfg
        {
            get
            {
                return global::NrfBleDriver.BleGapCfgDeviceNameT.__CreateInstance(__instance.device_name_cfg);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.device_name_cfg = *(global::NrfBleDriver.BleGapCfgDeviceNameT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>
    /// <para>Channel Map option.</para>
    /// <para>Used withto get the current channel map</para>
    /// <para>orto set a new channel map. When setting the</para>
    /// <para>channel map, it applies to all current and future connections. When getting the</para>
    /// <para>current channel map, it applies to a single connection and the connection handle</para>
    /// <para>must be supplied.</para>
    /// </summary>
    /// <remarks>
    /// <para>Setting the channel map may take some time, depending on connection parameters.</para>
    /// <para>The time taken may be different for each connection and the get operation will</para>
    /// <para>return the previous channel map until the new one has taken effect.</para>
    /// <para>After setting the channel map, by spec it can not be set again until at least 1 s has passed.</para>
    /// <para>See Bluetooth Specification Version 4.1 Volume 2, Part E, Section 7.3.46.</para>
    /// <para>::NRF_SUCCESS Get or set successful.</para>
    /// <para>::NRF_ERROR_BUSY Channel map was set again before enough time had passed.</para>
    /// <para>::NRF_ERROR_INVALID_STATE Invalid state to perform operation.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied for get.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED Returned by sd_ble_opt_set in peripheral-only SoftDevices.</para>
    /// </remarks>
    public unsafe partial class BleGapOptChMapT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal fixed byte ch_map[5];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_ch_map_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptChMapT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptChMapT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapOptChMapT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapOptChMapT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapOptChMapT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptChMapT(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptChMapT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapOptChMapT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapOptChMapT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptChMapT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapOptChMapT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapOptChMapT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapOptChMapT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptChMapT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapOptChMapT(global::NrfBleDriver.BleGapOptChMapT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptChMapT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapOptChMapT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapOptChMapT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle (only applicable for get)</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>Channel Map (37-bit).</summary>
        public byte[] ChMap
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->ch_map, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->ch_map[i] = value[i];
                }
            }
        }
    }

    /// <summary>Local connection latency option.</summary>
    /// <remarks>
    /// <para>Local connection latency is a feature which enables the slave to improve</para>
    /// <para>current consumption by ignoring the slave latency set by the peer. The</para>
    /// <para>local connection latency can only be set to a multiple of the slave latency,</para>
    /// <para>and cannot be longer than half of the supervision timeout.</para>
    /// <para>Used withto set the local connection latency. The</para>
    /// <para>is not supported for this option, but the actual</para>
    /// <para>local connection latency (unless set to NULL) is set as a return parameter</para>
    /// <para>when setting the option.</para>
    /// <para>The latency set will be truncated down to the closest slave latency event</para>
    /// <para>multiple, or the nearest multiple before half of the supervision timeout.</para>
    /// <para>The local connection latency is disabled by default, and needs to be enabled for new</para>
    /// <para>connections and whenever the connection is updated.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED Get is not supported.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.</para>
    /// </remarks>
    public unsafe partial class BleGapOptLocalConnLatencyT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal ushort requested_latency;
            internal __IntPtr p_actual_latency;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_local_conn_latency_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptLocalConnLatencyT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptLocalConnLatencyT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapOptLocalConnLatencyT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapOptLocalConnLatencyT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapOptLocalConnLatencyT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptLocalConnLatencyT(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptLocalConnLatencyT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapOptLocalConnLatencyT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapOptLocalConnLatencyT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptLocalConnLatencyT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapOptLocalConnLatencyT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapOptLocalConnLatencyT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapOptLocalConnLatencyT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptLocalConnLatencyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapOptLocalConnLatencyT(global::NrfBleDriver.BleGapOptLocalConnLatencyT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptLocalConnLatencyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapOptLocalConnLatencyT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapOptLocalConnLatencyT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>Requested local connection latency.</summary>
        public ushort RequestedLatency
        {
            get
            {
                return ((__Internal*)__Instance)->requested_latency;
            }

            set
            {
                ((__Internal*)__Instance)->requested_latency = value;
            }
        }

        /// <summary>Pointer to storage for the actual local connection latency (can be set to NULL to skip return value).</summary>
        public ushort* PActualLatency
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->p_actual_latency;
            }

            set
            {
                ((__Internal*)__Instance)->p_actual_latency = (__IntPtr) value;
            }
        }
    }

    /// <summary>Disable slave latency</summary>
    /// <remarks>
    /// <para>Used withto temporarily disable slave latency of a peripheral connection (seeAnd to re-enable it again.</para>
    /// <para>When disabled, the peripheral will ignore the slave_latency set by the central.</para>
    /// <para>Shall only be called on peripheral links.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_NOT_SUPPORTED Get is not supported.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.</para>
    /// </remarks>
    public unsafe partial class BleGapOptSlaveLatencyDisableT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal byte disable;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_slave_latency_disable_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptSlaveLatencyDisableT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptSlaveLatencyDisableT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapOptSlaveLatencyDisableT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapOptSlaveLatencyDisableT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapOptSlaveLatencyDisableT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptSlaveLatencyDisableT(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptSlaveLatencyDisableT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapOptSlaveLatencyDisableT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapOptSlaveLatencyDisableT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptSlaveLatencyDisableT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapOptSlaveLatencyDisableT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapOptSlaveLatencyDisableT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapOptSlaveLatencyDisableT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptSlaveLatencyDisableT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapOptSlaveLatencyDisableT(global::NrfBleDriver.BleGapOptSlaveLatencyDisableT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptSlaveLatencyDisableT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapOptSlaveLatencyDisableT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapOptSlaveLatencyDisableT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>Set to 1 to disable slave latency. Set to 0 enable it again.</summary>
        public byte Disable
        {
            get
            {
                return ((__Internal*)__Instance)->disable;
            }

            set
            {
                ((__Internal*)__Instance)->disable = value;
            }
        }
    }

    /// <summary>Passkey Option.</summary>
    /// <remarks>
    /// <para>Structure containing the passkey to be used during pairing. This can be used withto make the SoftDevice use a preprogrammed passkey for authentication</para>
    /// <para>instead of generating a random one.</para>
    /// <para>Repeated pairing attempts using the same preprogrammed passkey makes pairing vulnerable to MITM attacks.</para>
    /// <para>is not supported for this option.</para>
    /// </remarks>
    public unsafe partial class BleGapOptPasskeyT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr p_passkey;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_passkey_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptPasskeyT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptPasskeyT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapOptPasskeyT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapOptPasskeyT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapOptPasskeyT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptPasskeyT(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptPasskeyT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapOptPasskeyT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapOptPasskeyT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptPasskeyT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapOptPasskeyT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapOptPasskeyT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapOptPasskeyT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptPasskeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapOptPasskeyT(global::NrfBleDriver.BleGapOptPasskeyT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptPasskeyT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapOptPasskeyT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapOptPasskeyT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Pointer to 6-digit ASCII string (digit 0..9 only, no NULL termination) passkey to be used during pairing. If this is NULL, the SoftDevice will generate a random passkey if required.</summary>
        public byte* PPasskey
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_passkey;
            }
        }
    }

    /// <summary>Scan request report option.</summary>
    /// <remarks>
    /// <para>This can be used withto make the SoftDevice send</para>
    /// <para>events.</para>
    /// <para>Due to the limited space reserved for scan request report events,</para>
    /// <para>not all received scan requests will be reported.</para>
    /// <para>If whitelisting is used, only whitelisted requests are reported.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_INVALID_STATE When advertising is ongoing while the option is set.</para>
    /// </remarks>
    public unsafe partial class BleGapOptScanReqReportT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte enable;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_scan_req_report_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptScanReqReportT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptScanReqReportT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapOptScanReqReportT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapOptScanReqReportT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapOptScanReqReportT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptScanReqReportT(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptScanReqReportT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapOptScanReqReportT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapOptScanReqReportT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptScanReqReportT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapOptScanReqReportT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapOptScanReqReportT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapOptScanReqReportT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptScanReqReportT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapOptScanReqReportT(global::NrfBleDriver.BleGapOptScanReqReportT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptScanReqReportT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapOptScanReqReportT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapOptScanReqReportT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Enable scan request reports.</summary>
        public byte Enable
        {
            get
            {
                return ((__Internal*)__Instance)->enable;
            }

            set
            {
                ((__Internal*)__Instance)->enable = value;
            }
        }
    }

    /// <summary>Compatibility mode 1 option.</summary>
    /// <remarks>
    /// <para>This can be used withto enable and disable</para>
    /// <para>compatibility mode 1. Compatibility mode 1 is disabled by default.</para>
    /// <para>Compatibility mode 1 enables interoperability with devices that do not support a value of</para>
    /// <para>0 for the WinOffset parameter in the Link Layer CONNECT_IND packet. This applies to a</para>
    /// <para>limited set of legacy peripheral devices from another vendor. Enabling this compatibility</para>
    /// <para>mode will only have an effect if the local device will act as a central device and</para>
    /// <para>initiate a connection to a peripheral device. In that case it may lead to the connection</para>
    /// <para>creation taking up to one connection interval longer to complete for all connections.</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_INVALID_STATE When connection creation is ongoing while mode 1 is set.</para>
    /// </remarks>
    public unsafe partial class BleGapOptCompatMode1T : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte enable;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_compat_mode_1_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptCompatMode1T> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptCompatMode1T>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapOptCompatMode1T managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapOptCompatMode1T managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapOptCompatMode1T __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptCompatMode1T(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptCompatMode1T __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapOptCompatMode1T)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapOptCompatMode1T __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptCompatMode1T(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapOptCompatMode1T(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapOptCompatMode1T(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapOptCompatMode1T()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptCompatMode1T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapOptCompatMode1T(global::NrfBleDriver.BleGapOptCompatMode1T __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptCompatMode1T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapOptCompatMode1T.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapOptCompatMode1T.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Enable compatibility mode 1.</summary>
        public byte Enable
        {
            get
            {
                return ((__Internal*)__Instance)->enable;
            }

            set
            {
                ((__Internal*)__Instance)->enable = value;
            }
        }
    }

    /// <summary>Authenticated payload timeout option.</summary>
    /// <remarks>
    /// <para>This can be used withto change the Authenticated payload timeout to a value other</para>
    /// <para>than the default of</para>
    /// <para>The authenticated payload timeout event ::BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD will be generated</para>
    /// <para>if auth_payload_timeout time has elapsed without receiving a packet with a valid MIC on an encrypted</para>
    /// <para>link.</para>
    /// <para>The LE ping procedure will be initiated before the timer expires to give the peer a chance</para>
    /// <para>to reset the timer. In addition the stack will try to prioritize running of LE ping over other</para>
    /// <para>activities to increase chances of finishing LE ping before timer expires. To avoid side-effects</para>
    /// <para>on other activities, it is recommended to use high timeout values.</para>
    /// <para>Recommended timeout &gt; 2*(connInterval * (6 + connSlaveLatency)).</para>
    /// <para>::NRF_SUCCESS Set successfully.</para>
    /// <para>::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied. auth_payload_timeout was outside of allowed range.</para>
    /// <para>::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle parameter.</para>
    /// </remarks>
    public unsafe partial class BleGapOptAuthPayloadTimeoutT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal ushort auth_payload_timeout;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_auth_payload_timeout_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGapOptAuthPayloadTimeoutT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptAuthPayloadTimeoutT(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptAuthPayloadTimeoutT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGapOptAuthPayloadTimeoutT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGapOptAuthPayloadTimeoutT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptAuthPayloadTimeoutT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGapOptAuthPayloadTimeoutT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGapOptAuthPayloadTimeoutT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGapOptAuthPayloadTimeoutT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGapOptAuthPayloadTimeoutT(global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>Requested timeout in 10 ms unit, see</summary>
        public ushort AuthPayloadTimeout
        {
            get
            {
                return ((__Internal*)__Instance)->auth_payload_timeout;
            }

            set
            {
                ((__Internal*)__Instance)->auth_payload_timeout = value;
            }
        }
    }

    /// <summary>Option structure for GAP options.</summary>
    public unsafe partial struct BleGapOptT
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptChMapT.__Internal ch_map;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptLocalConnLatencyT.__Internal local_conn_latency;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptPasskeyT.__Internal passkey;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptScanReqReportT.__Internal scan_req_report;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptCompatMode1T.__Internal compat_mode_1;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT.__Internal auth_payload_timeout;

            [FieldOffset(0)]
            internal global::NrfBleDriver.BleGapOptSlaveLatencyDisableT.__Internal slave_latency_disable;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gap_opt_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        private BleGapOptT.__Internal __instance;
        internal BleGapOptT.__Internal __Instance => __instance;

        internal static BleGapOptT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGapOptT(native.ToPointer(), skipVTables);
        }

        internal static BleGapOptT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGapOptT(native, skipVTables);
        }

        private BleGapOptT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private BleGapOptT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::NrfBleDriver.BleGapOptT.__Internal*) native;
        }

        public BleGapOptT(global::NrfBleDriver.BleGapOptT __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>Parameters for the Channel Map option.</summary>
        public global::NrfBleDriver.BleGapOptChMapT ChMap
        {
            get
            {
                return global::NrfBleDriver.BleGapOptChMapT.__CreateInstance(__instance.ch_map);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.ch_map = *(global::NrfBleDriver.BleGapOptChMapT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Parameters for the Local connection latency option</summary>
        public global::NrfBleDriver.BleGapOptLocalConnLatencyT LocalConnLatency
        {
            get
            {
                return global::NrfBleDriver.BleGapOptLocalConnLatencyT.__CreateInstance(__instance.local_conn_latency);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.local_conn_latency = *(global::NrfBleDriver.BleGapOptLocalConnLatencyT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Parameters for the Passkey option.</summary>
        public global::NrfBleDriver.BleGapOptPasskeyT Passkey
        {
            get
            {
                return global::NrfBleDriver.BleGapOptPasskeyT.__CreateInstance(__instance.passkey);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.passkey = *(global::NrfBleDriver.BleGapOptPasskeyT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Parameters for the scan request report option.</summary>
        public global::NrfBleDriver.BleGapOptScanReqReportT ScanReqReport
        {
            get
            {
                return global::NrfBleDriver.BleGapOptScanReqReportT.__CreateInstance(__instance.scan_req_report);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.scan_req_report = *(global::NrfBleDriver.BleGapOptScanReqReportT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Parameters for the compatibility mode 1 option.</summary>
        public global::NrfBleDriver.BleGapOptCompatMode1T CompatMode1
        {
            get
            {
                return global::NrfBleDriver.BleGapOptCompatMode1T.__CreateInstance(__instance.compat_mode_1);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.compat_mode_1 = *(global::NrfBleDriver.BleGapOptCompatMode1T.__Internal*) value.__Instance;
            }
        }

        /// <summary>Parameters for the authenticated payload timeout option.</summary>
        public global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT AuthPayloadTimeout
        {
            get
            {
                return global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT.__CreateInstance(__instance.auth_payload_timeout);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.auth_payload_timeout = *(global::NrfBleDriver.BleGapOptAuthPayloadTimeoutT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Parameters for the Disable slave latency option</summary>
        public global::NrfBleDriver.BleGapOptSlaveLatencyDisableT SlaveLatencyDisable
        {
            get
            {
                return global::NrfBleDriver.BleGapOptSlaveLatencyDisableT.__CreateInstance(__instance.slave_latency_disable);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.slave_latency_disable = *(global::NrfBleDriver.BleGapOptSlaveLatencyDisableT.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ble_gap
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_addr_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAddrSet(__IntPtr adapter, __IntPtr p_addr);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_addr_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAddrGet(__IntPtr adapter, __IntPtr p_addr);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_whitelist_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapWhitelistSet(__IntPtr adapter, __IntPtr pp_wl_addrs, byte len);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_device_identities_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapDeviceIdentitiesSet(__IntPtr adapter, __IntPtr pp_id_keys, __IntPtr pp_local_irks, byte len);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_privacy_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapPrivacySet(__IntPtr adapter, __IntPtr p_privacy_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_privacy_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapPrivacyGet(__IntPtr adapter, __IntPtr p_privacy_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_adv_data_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAdvDataSet(__IntPtr adapter, byte* p_adv_data, byte dlen, byte* p_sr_data, byte srdlen);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_adv_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAdvStart(__IntPtr adapter, __IntPtr p_adv_params, byte conn_cfg_tag);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_adv_stop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAdvStop(__IntPtr adapter);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_conn_param_update", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapConnParamUpdate(__IntPtr adapter, ushort conn_handle, __IntPtr p_conn_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_disconnect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapDisconnect(__IntPtr adapter, ushort conn_handle, byte hci_status_code);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_tx_power_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapTxPowerSet(__IntPtr adapter, sbyte tx_power);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_appearance_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAppearanceSet(__IntPtr adapter, ushort appearance);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_appearance_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAppearanceGet(__IntPtr adapter, ushort* p_appearance);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_ppcp_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapPpcpSet(__IntPtr adapter, __IntPtr p_conn_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_ppcp_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapPpcpGet(__IntPtr adapter, __IntPtr p_conn_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_device_name_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapDeviceNameSet(__IntPtr adapter, __IntPtr p_write_perm, byte* p_dev_name, ushort len);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_device_name_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapDeviceNameGet(__IntPtr adapter, byte* p_dev_name, ushort* p_dev_name_len);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_authenticate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAuthenticate(__IntPtr adapter, ushort conn_handle, __IntPtr p_sec_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_sec_params_reply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapSecParamsReply(__IntPtr adapter, ushort conn_handle, byte sec_status, __IntPtr p_sec_params, __IntPtr p_sec_keyset);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_auth_key_reply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapAuthKeyReply(__IntPtr adapter, ushort conn_handle, byte key_type, byte* p_key);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_lesc_dhkey_reply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapLescDhkeyReply(__IntPtr adapter, ushort conn_handle, __IntPtr p_dhkey);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_keypress_notify", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapKeypressNotify(__IntPtr adapter, ushort conn_handle, byte kp_not);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_lesc_oob_data_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapLescOobDataGet(__IntPtr adapter, ushort conn_handle, __IntPtr p_pk_own, __IntPtr p_oobd_own);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_lesc_oob_data_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapLescOobDataSet(__IntPtr adapter, ushort conn_handle, __IntPtr p_oobd_own, __IntPtr p_oobd_peer);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_encrypt", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapEncrypt(__IntPtr adapter, ushort conn_handle, __IntPtr p_master_id, __IntPtr p_enc_info);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_sec_info_reply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapSecInfoReply(__IntPtr adapter, ushort conn_handle, __IntPtr p_enc_info, __IntPtr p_id_info, __IntPtr p_sign_info);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_conn_sec_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapConnSecGet(__IntPtr adapter, ushort conn_handle, __IntPtr p_conn_sec);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_rssi_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapRssiStart(__IntPtr adapter, ushort conn_handle, byte threshold_dbm, byte skip_count);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_rssi_stop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapRssiStop(__IntPtr adapter, ushort conn_handle);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_rssi_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapRssiGet(__IntPtr adapter, ushort conn_handle, sbyte* p_rssi);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_scan_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapScanStart(__IntPtr adapter, __IntPtr p_scan_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_scan_stop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapScanStop(__IntPtr adapter);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_connect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapConnect(__IntPtr adapter, __IntPtr p_peer_addr, __IntPtr p_scan_params, __IntPtr p_conn_params, byte conn_cfg_tag);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_connect_cancel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapConnectCancel(__IntPtr adapter);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_phy_update", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapPhyUpdate(__IntPtr adapter, ushort conn_handle, __IntPtr p_gap_phys);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gap_data_length_update", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGapDataLengthUpdate(__IntPtr adapter, ushort conn_handle, __IntPtr p_dl_params, __IntPtr p_dl_limitation);
        }

        public static uint SdBleGapAddrSet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapAddrT p_addr)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_addr is null ? __IntPtr.Zero : p_addr.__Instance;
            var __ret = __Internal.SdBleGapAddrSet(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleGapAddrGet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapAddrT p_addr)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_addr is null ? __IntPtr.Zero : p_addr.__Instance;
            var __ret = __Internal.SdBleGapAddrGet(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleGapWhitelistSet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapAddrT pp_wl_addrs, byte len)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var ____arg1 = pp_wl_addrs is null ? __IntPtr.Zero : pp_wl_addrs.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var __ret = __Internal.SdBleGapWhitelistSet(__arg0, __arg1, len);
            return __ret;
        }

        public static uint SdBleGapDeviceIdentitiesSet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapIdKeyT pp_id_keys, global::NrfBleDriver.BleGapIrkT pp_local_irks, byte len)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var ____arg1 = pp_id_keys is null ? __IntPtr.Zero : pp_id_keys.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ____arg2 = pp_local_irks is null ? __IntPtr.Zero : pp_local_irks.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var __ret = __Internal.SdBleGapDeviceIdentitiesSet(__arg0, __arg1, __arg2, len);
            return __ret;
        }

        public static uint SdBleGapPrivacySet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapPrivacyParamsT p_privacy_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_privacy_params is null ? __IntPtr.Zero : p_privacy_params.__Instance;
            var __ret = __Internal.SdBleGapPrivacySet(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleGapPrivacyGet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapPrivacyParamsT p_privacy_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_privacy_params is null ? __IntPtr.Zero : p_privacy_params.__Instance;
            var __ret = __Internal.SdBleGapPrivacyGet(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleGapAdvDataSet(global::NrfBleDriver.AdapterT adapter, byte* p_adv_data, byte dlen, byte* p_sr_data, byte srdlen)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapAdvDataSet(__arg0, p_adv_data, dlen, p_sr_data, srdlen);
            return __ret;
        }

        public static uint SdBleGapAdvStart(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapAdvParamsT p_adv_params, byte conn_cfg_tag)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_adv_params is null ? __IntPtr.Zero : p_adv_params.__Instance;
            var __ret = __Internal.SdBleGapAdvStart(__arg0, __arg1, conn_cfg_tag);
            return __ret;
        }

        public static uint SdBleGapAdvStop(global::NrfBleDriver.AdapterT adapter)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapAdvStop(__arg0);
            return __ret;
        }

        public static uint SdBleGapConnParamUpdate(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapConnParamsT p_conn_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_conn_params is null ? __IntPtr.Zero : p_conn_params.__Instance;
            var __ret = __Internal.SdBleGapConnParamUpdate(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGapDisconnect(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, byte hci_status_code)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapDisconnect(__arg0, conn_handle, hci_status_code);
            return __ret;
        }

        public static uint SdBleGapTxPowerSet(global::NrfBleDriver.AdapterT adapter, sbyte tx_power)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapTxPowerSet(__arg0, tx_power);
            return __ret;
        }

        public static uint SdBleGapAppearanceSet(global::NrfBleDriver.AdapterT adapter, ushort appearance)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapAppearanceSet(__arg0, appearance);
            return __ret;
        }

        public static uint SdBleGapAppearanceGet(global::NrfBleDriver.AdapterT adapter, ref ushort p_appearance)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (ushort* __p_appearance1 = &p_appearance)
            {
                var __arg1 = __p_appearance1;
                var __ret = __Internal.SdBleGapAppearanceGet(__arg0, __arg1);
                return __ret;
            }
        }

        public static uint SdBleGapPpcpSet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapConnParamsT p_conn_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_conn_params is null ? __IntPtr.Zero : p_conn_params.__Instance;
            var __ret = __Internal.SdBleGapPpcpSet(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleGapPpcpGet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapConnParamsT p_conn_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_conn_params is null ? __IntPtr.Zero : p_conn_params.__Instance;
            var __ret = __Internal.SdBleGapPpcpGet(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleGapDeviceNameSet(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapConnSecModeT p_write_perm, byte* p_dev_name, ushort len)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_write_perm is null ? __IntPtr.Zero : p_write_perm.__Instance;
            var __ret = __Internal.SdBleGapDeviceNameSet(__arg0, __arg1, p_dev_name, len);
            return __ret;
        }

        public static uint SdBleGapDeviceNameGet(global::NrfBleDriver.AdapterT adapter, byte* p_dev_name, ref ushort p_dev_name_len)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (ushort* __p_dev_name_len2 = &p_dev_name_len)
            {
                var __arg2 = __p_dev_name_len2;
                var __ret = __Internal.SdBleGapDeviceNameGet(__arg0, p_dev_name, __arg2);
                return __ret;
            }
        }

        public static uint SdBleGapAuthenticate(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapSecParamsT p_sec_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_sec_params is null ? __IntPtr.Zero : p_sec_params.__Instance;
            var __ret = __Internal.SdBleGapAuthenticate(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGapSecParamsReply(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, byte sec_status, global::NrfBleDriver.BleGapSecParamsT p_sec_params, global::NrfBleDriver.BleGapSecKeysetT p_sec_keyset)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg3 = p_sec_params is null ? __IntPtr.Zero : p_sec_params.__Instance;
            var __arg4 = p_sec_keyset is null ? __IntPtr.Zero : p_sec_keyset.__Instance;
            var __ret = __Internal.SdBleGapSecParamsReply(__arg0, conn_handle, sec_status, __arg3, __arg4);
            return __ret;
        }

        public static uint SdBleGapAuthKeyReply(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, byte key_type, byte* p_key)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapAuthKeyReply(__arg0, conn_handle, key_type, p_key);
            return __ret;
        }

        public static uint SdBleGapLescDhkeyReply(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapLescDhkeyT p_dhkey)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_dhkey is null ? __IntPtr.Zero : p_dhkey.__Instance;
            var __ret = __Internal.SdBleGapLescDhkeyReply(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGapKeypressNotify(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, byte kp_not)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapKeypressNotify(__arg0, conn_handle, kp_not);
            return __ret;
        }

        public static uint SdBleGapLescOobDataGet(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapLescP256PkT p_pk_own, global::NrfBleDriver.BleGapLescOobDataT p_oobd_own)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_pk_own is null ? __IntPtr.Zero : p_pk_own.__Instance;
            var __arg3 = p_oobd_own is null ? __IntPtr.Zero : p_oobd_own.__Instance;
            var __ret = __Internal.SdBleGapLescOobDataGet(__arg0, conn_handle, __arg2, __arg3);
            return __ret;
        }

        public static uint SdBleGapLescOobDataSet(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapLescOobDataT p_oobd_own, global::NrfBleDriver.BleGapLescOobDataT p_oobd_peer)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_oobd_own is null ? __IntPtr.Zero : p_oobd_own.__Instance;
            var __arg3 = p_oobd_peer is null ? __IntPtr.Zero : p_oobd_peer.__Instance;
            var __ret = __Internal.SdBleGapLescOobDataSet(__arg0, conn_handle, __arg2, __arg3);
            return __ret;
        }

        public static uint SdBleGapEncrypt(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapMasterIdT p_master_id, global::NrfBleDriver.BleGapEncInfoT p_enc_info)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_master_id is null ? __IntPtr.Zero : p_master_id.__Instance;
            var __arg3 = p_enc_info is null ? __IntPtr.Zero : p_enc_info.__Instance;
            var __ret = __Internal.SdBleGapEncrypt(__arg0, conn_handle, __arg2, __arg3);
            return __ret;
        }

        public static uint SdBleGapSecInfoReply(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapEncInfoT p_enc_info, global::NrfBleDriver.BleGapIrkT p_id_info, global::NrfBleDriver.BleGapSignInfoT p_sign_info)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_enc_info is null ? __IntPtr.Zero : p_enc_info.__Instance;
            var __arg3 = p_id_info is null ? __IntPtr.Zero : p_id_info.__Instance;
            var __arg4 = p_sign_info is null ? __IntPtr.Zero : p_sign_info.__Instance;
            var __ret = __Internal.SdBleGapSecInfoReply(__arg0, conn_handle, __arg2, __arg3, __arg4);
            return __ret;
        }

        public static uint SdBleGapConnSecGet(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapConnSecT p_conn_sec)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_conn_sec is null ? __IntPtr.Zero : p_conn_sec.__Instance;
            var __ret = __Internal.SdBleGapConnSecGet(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGapRssiStart(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, byte threshold_dbm, byte skip_count)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapRssiStart(__arg0, conn_handle, threshold_dbm, skip_count);
            return __ret;
        }

        public static uint SdBleGapRssiStop(global::NrfBleDriver.AdapterT adapter, ushort conn_handle)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapRssiStop(__arg0, conn_handle);
            return __ret;
        }

        public static uint SdBleGapRssiGet(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, sbyte* p_rssi)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapRssiGet(__arg0, conn_handle, p_rssi);
            return __ret;
        }

        public static uint SdBleGapScanStart(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapScanParamsT p_scan_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_scan_params is null ? __IntPtr.Zero : p_scan_params.__Instance;
            var __ret = __Internal.SdBleGapScanStart(__arg0, __arg1);
            return __ret;
        }

        public static uint SdBleGapScanStop(global::NrfBleDriver.AdapterT adapter)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapScanStop(__arg0);
            return __ret;
        }

        public static uint SdBleGapConnect(global::NrfBleDriver.AdapterT adapter, global::NrfBleDriver.BleGapAddrT p_peer_addr, global::NrfBleDriver.BleGapScanParamsT p_scan_params, global::NrfBleDriver.BleGapConnParamsT p_conn_params, byte conn_cfg_tag)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg1 = p_peer_addr is null ? __IntPtr.Zero : p_peer_addr.__Instance;
            var __arg2 = p_scan_params is null ? __IntPtr.Zero : p_scan_params.__Instance;
            var __arg3 = p_conn_params is null ? __IntPtr.Zero : p_conn_params.__Instance;
            var __ret = __Internal.SdBleGapConnect(__arg0, __arg1, __arg2, __arg3, conn_cfg_tag);
            return __ret;
        }

        public static uint SdBleGapConnectCancel(global::NrfBleDriver.AdapterT adapter)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGapConnectCancel(__arg0);
            return __ret;
        }

        public static uint SdBleGapPhyUpdate(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapPhysT p_gap_phys)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_gap_phys is null ? __IntPtr.Zero : p_gap_phys.__Instance;
            var __ret = __Internal.SdBleGapPhyUpdate(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGapDataLengthUpdate(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGapDataLengthParamsT p_dl_params, global::NrfBleDriver.BleGapDataLengthLimitationT p_dl_limitation)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_dl_params is null ? __IntPtr.Zero : p_dl_params.__Instance;
            var __arg3 = p_dl_limitation is null ? __IntPtr.Zero : p_dl_limitation.__Instance;
            var __ret = __Internal.SdBleGapDataLengthUpdate(__arg0, conn_handle, __arg2, __arg3);
            return __ret;
        }
    }
}
