// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace NrfBleDriver
{
    /// <summary>GATTC API SVC numbers.</summary>
    public enum BLE_GATTC_SVCS
    {
        /// <summary>Primary Service Discovery.</summary>
        SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER = 148,
        /// <summary>Relationship Discovery.</summary>
        SD_BLE_GATTC_RELATIONSHIPS_DISCOVER = 149,
        /// <summary>Characteristic Discovery.</summary>
        SD_BLE_GATTC_CHARACTERISTICS_DISCOVER = 150,
        /// <summary>Characteristic Descriptor Discovery.</summary>
        SD_BLE_GATTC_DESCRIPTORS_DISCOVER = 151,
        /// <summary>Attribute Information Discovery.</summary>
        SD_BLE_GATTC_ATTR_INFO_DISCOVER = 152,
        /// <summary>Read Characteristic Value by UUID.</summary>
        SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ = 153,
        /// <summary>Generic read.</summary>
        SD_BLE_GATTC_READ = 154,
        /// <summary>Read multiple Characteristic Values.</summary>
        SD_BLE_GATTC_CHAR_VALUES_READ = 155,
        /// <summary>Generic write.</summary>
        SD_BLE_GATTC_WRITE = 156,
        /// <summary>Handle Value Confirmation.</summary>
        SD_BLE_GATTC_HV_CONFIRM = 157,
        /// <summary>Exchange MTU Request.</summary>
        SD_BLE_GATTC_EXCHANGE_MTU_REQUEST = 158
    }

    /// <summary>GATT Client Event IDs.</summary>
    public enum BLE_GATTC_EVTS
    {
        /// <summary>Primary Service Discovery Response event.See</summary>
        BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP = 48,
        /// <summary>Relationship Discovery Response event.See</summary>
        BLE_GATTC_EVT_REL_DISC_RSP = 49,
        /// <summary>Characteristic Discovery Response event.See</summary>
        BLE_GATTC_EVT_CHAR_DISC_RSP = 50,
        /// <summary>Descriptor Discovery Response event.See</summary>
        BLE_GATTC_EVT_DESC_DISC_RSP = 51,
        /// <summary>Attribute Information Response event.See</summary>
        BLE_GATTC_EVT_ATTR_INFO_DISC_RSP = 52,
        /// <summary>Read By UUID Response event.See</summary>
        BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP = 53,
        /// <summary>Read Response event.See</summary>
        BLE_GATTC_EVT_READ_RSP = 54,
        /// <summary>Read multiple Response event.See</summary>
        BLE_GATTC_EVT_CHAR_VALS_READ_RSP = 55,
        /// <summary>Write Response event.See</summary>
        BLE_GATTC_EVT_WRITE_RSP = 56,
        /// <summary>Handle Value Notification or Indication event.Confirm indication withSee</summary>
        BLE_GATTC_EVT_HVX = 57,
        /// <summary>Exchange MTU Response event.See</summary>
        BLE_GATTC_EVT_EXCHANGE_MTU_RSP = 58,
        /// <summary>Timeout event.See</summary>
        BLE_GATTC_EVT_TIMEOUT = 59,
        /// <summary>Write without Response transmission complete.See</summary>
        BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE = 60
    }

    /// <summary>BLE GATTC connection configuration parameters, set with</summary>
    /// <summary>Operation Handle Range.</summary>
    /// <summary>GATT service.</summary>
    /// <summary>GATT include.</summary>
    /// <summary>GATT characteristic.</summary>
    /// <summary>GATT descriptor.</summary>
    /// <summary>Write Parameters.</summary>
    /// <summary>Attribute Information for 16-bit Attribute UUID.</summary>
    /// <summary>Attribute Information for 128-bit Attribute UUID.</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>GATT read by UUID handle value pair.</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>Event structure for</summary>
    /// <summary>GATTC event structure.</summary>
    /// <summary>BLE GATTC connection configuration parameters, set with</summary>
    public unsafe partial class BleGattcConnCfgT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte write_cmd_tx_queue_size;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_conn_cfg_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcConnCfgT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcConnCfgT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcConnCfgT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcConnCfgT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcConnCfgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcConnCfgT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcConnCfgT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcConnCfgT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcConnCfgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcConnCfgT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcConnCfgT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcConnCfgT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcConnCfgT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcConnCfgT(global::NrfBleDriver.BleGattcConnCfgT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcConnCfgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcConnCfgT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcConnCfgT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The guaranteed minimum number of Write without Response that can be queued for transmission.</para>
        /// <para>The default value is</para>
        /// </summary>
        public byte WriteCmdTxQueueSize
        {
            get
            {
                return ((__Internal*)__Instance)->write_cmd_tx_queue_size;
            }

            set
            {
                ((__Internal*)__Instance)->write_cmd_tx_queue_size = value;
            }
        }
    }

    /// <summary>Operation Handle Range.</summary>
    public unsafe partial class BleGattcHandleRangeT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal ushort start_handle;
            internal ushort end_handle;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_handle_range_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcHandleRangeT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcHandleRangeT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcHandleRangeT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcHandleRangeT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcHandleRangeT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcHandleRangeT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcHandleRangeT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcHandleRangeT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcHandleRangeT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcHandleRangeT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcHandleRangeT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcHandleRangeT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcHandleRangeT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcHandleRangeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcHandleRangeT(global::NrfBleDriver.BleGattcHandleRangeT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcHandleRangeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcHandleRangeT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcHandleRangeT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Start Handle.</summary>
        public ushort StartHandle
        {
            get
            {
                return ((__Internal*)__Instance)->start_handle;
            }

            set
            {
                ((__Internal*)__Instance)->start_handle = value;
            }
        }

        /// <summary>End Handle.</summary>
        public ushort EndHandle
        {
            get
            {
                return ((__Internal*)__Instance)->end_handle;
            }

            set
            {
                ((__Internal*)__Instance)->end_handle = value;
            }
        }
    }

    /// <summary>GATT service.</summary>
    public unsafe partial class BleGattcServiceT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleUuidT.__Internal uuid;
            internal global::NrfBleDriver.BleGattcHandleRangeT.__Internal handle_range;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_service_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcServiceT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcServiceT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcServiceT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcServiceT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcServiceT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcServiceT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcServiceT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcServiceT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcServiceT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcServiceT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcServiceT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcServiceT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcServiceT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcServiceT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcServiceT(global::NrfBleDriver.BleGattcServiceT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcServiceT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcServiceT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcServiceT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Service UUID.</summary>
        public global::NrfBleDriver.BleUuidT Uuid
        {
            get
            {
                return global::NrfBleDriver.BleUuidT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uuid));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uuid = *(global::NrfBleDriver.BleUuidT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Service Handle Range.</summary>
        public global::NrfBleDriver.BleGattcHandleRangeT HandleRange
        {
            get
            {
                return global::NrfBleDriver.BleGattcHandleRangeT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->handle_range));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->handle_range = *(global::NrfBleDriver.BleGattcHandleRangeT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>GATT include.</summary>
    public unsafe partial class BleGattcIncludeT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 10)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal global::NrfBleDriver.BleGattcServiceT.__Internal included_srvc;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_include_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcIncludeT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcIncludeT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcIncludeT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcIncludeT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcIncludeT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcIncludeT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcIncludeT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcIncludeT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcIncludeT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcIncludeT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcIncludeT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcIncludeT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcIncludeT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcIncludeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcIncludeT(global::NrfBleDriver.BleGattcIncludeT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcIncludeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcIncludeT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcIncludeT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Include Handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Handle of the included service.</summary>
        public global::NrfBleDriver.BleGattcServiceT IncludedSrvc
        {
            get
            {
                return global::NrfBleDriver.BleGattcServiceT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->included_srvc));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->included_srvc = *(global::NrfBleDriver.BleGattcServiceT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>GATT characteristic.</summary>
    public unsafe partial class BleGattcCharT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 10)]
        public partial struct __Internal
        {
            internal global::NrfBleDriver.BleUuidT.__Internal uuid;
            internal global::NrfBleDriver.BleGattCharPropsT.__Internal char_props;
            internal byte char_ext_props;
            internal ushort handle_decl;
            internal ushort handle_value;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_char_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcCharT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcCharT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcCharT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcCharT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcCharT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcCharT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcCharT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcCharT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcCharT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcCharT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcCharT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcCharT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcCharT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcCharT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcCharT(global::NrfBleDriver.BleGattcCharT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcCharT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcCharT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcCharT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Characteristic UUID.</summary>
        public global::NrfBleDriver.BleUuidT Uuid
        {
            get
            {
                return global::NrfBleDriver.BleUuidT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uuid));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uuid = *(global::NrfBleDriver.BleUuidT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Characteristic Properties.</summary>
        public global::NrfBleDriver.BleGattCharPropsT CharProps
        {
            get
            {
                return global::NrfBleDriver.BleGattCharPropsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->char_props));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->char_props = *(global::NrfBleDriver.BleGattCharPropsT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Extended properties present.</summary>
        public byte CharExtProps
        {
            get
            {
                return ((__Internal*)__Instance)->char_ext_props;
            }

            set
            {
                ((__Internal*)__Instance)->char_ext_props = value;
            }
        }

        /// <summary>Handle of the Characteristic Declaration.</summary>
        public ushort HandleDecl
        {
            get
            {
                return ((__Internal*)__Instance)->handle_decl;
            }

            set
            {
                ((__Internal*)__Instance)->handle_decl = value;
            }
        }

        /// <summary>Handle of the Characteristic Value.</summary>
        public ushort HandleValue
        {
            get
            {
                return ((__Internal*)__Instance)->handle_value;
            }

            set
            {
                ((__Internal*)__Instance)->handle_value = value;
            }
        }
    }

    /// <summary>GATT descriptor.</summary>
    public unsafe partial class BleGattcDescT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 6)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal global::NrfBleDriver.BleUuidT.__Internal uuid;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_desc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcDescT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcDescT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcDescT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcDescT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcDescT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcDescT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcDescT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcDescT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcDescT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcDescT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcDescT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcDescT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcDescT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcDescT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcDescT(global::NrfBleDriver.BleGattcDescT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcDescT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcDescT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcDescT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Descriptor Handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Descriptor UUID.</summary>
        public global::NrfBleDriver.BleUuidT Uuid
        {
            get
            {
                return global::NrfBleDriver.BleUuidT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uuid));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uuid = *(global::NrfBleDriver.BleUuidT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Write Parameters.</summary>
    public unsafe partial class BleGattcWriteParamsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal byte write_op;
            internal byte flags;
            internal ushort handle;
            internal ushort offset;
            internal ushort len;
            internal __IntPtr p_value;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_write_params_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcWriteParamsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcWriteParamsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcWriteParamsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcWriteParamsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcWriteParamsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcWriteParamsT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcWriteParamsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcWriteParamsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcWriteParamsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcWriteParamsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcWriteParamsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcWriteParamsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcWriteParamsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcWriteParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcWriteParamsT(global::NrfBleDriver.BleGattcWriteParamsT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcWriteParamsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcWriteParamsT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcWriteParamsT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Write Operation to be performed, see</summary>
        public byte WriteOp
        {
            get
            {
                return ((__Internal*)__Instance)->write_op;
            }

            set
            {
                ((__Internal*)__Instance)->write_op = value;
            }
        }

        /// <summary>Flags, see</summary>
        public byte Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        /// <summary>Handle to the attribute to be written.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Offset in bytes.</summary>
        /// <remarks>For WRITE_CMD and WRITE_REQ, offset must be 0.</remarks>
        public ushort Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }

        /// <summary>Length of data in bytes.</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        /// <summary>Pointer to the value data.</summary>
        public byte* PValue
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_value;
            }
            set
            {
                ((__Internal*)__Instance)->p_value = (IntPtr)value;
            }
        }
    }

    /// <summary>Attribute Information for 16-bit Attribute UUID.</summary>
    public unsafe partial class BleGattcAttrInfo16T : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 6)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal global::NrfBleDriver.BleUuidT.__Internal uuid;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_attr_info16_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcAttrInfo16T> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcAttrInfo16T>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcAttrInfo16T managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcAttrInfo16T managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcAttrInfo16T __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcAttrInfo16T(native.ToPointer(), skipVTables);
        }

        internal static BleGattcAttrInfo16T __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcAttrInfo16T)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcAttrInfo16T __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcAttrInfo16T(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcAttrInfo16T(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcAttrInfo16T(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcAttrInfo16T()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcAttrInfo16T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcAttrInfo16T(global::NrfBleDriver.BleGattcAttrInfo16T __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcAttrInfo16T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcAttrInfo16T.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcAttrInfo16T.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>16-bit Attribute UUID.</summary>
        public global::NrfBleDriver.BleUuidT Uuid
        {
            get
            {
                return global::NrfBleDriver.BleUuidT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uuid));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uuid = *(global::NrfBleDriver.BleUuidT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Attribute Information for 128-bit Attribute UUID.</summary>
    public unsafe partial class BleGattcAttrInfo128T : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 18)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal global::NrfBleDriver.BleUuid128T.__Internal uuid;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_attr_info128_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcAttrInfo128T> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcAttrInfo128T>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcAttrInfo128T managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcAttrInfo128T managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcAttrInfo128T __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcAttrInfo128T(native.ToPointer(), skipVTables);
        }

        internal static BleGattcAttrInfo128T __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcAttrInfo128T)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcAttrInfo128T __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcAttrInfo128T(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcAttrInfo128T(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcAttrInfo128T(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcAttrInfo128T()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcAttrInfo128T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcAttrInfo128T(global::NrfBleDriver.BleGattcAttrInfo128T __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcAttrInfo128T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcAttrInfo128T.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcAttrInfo128T.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>128-bit Attribute UUID.</summary>
        public global::NrfBleDriver.BleUuid128T Uuid
        {
            get
            {
                return global::NrfBleDriver.BleUuid128T.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uuid));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uuid = *(global::NrfBleDriver.BleUuid128T.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtPrimSrvcDiscRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 10)]
        public partial struct __Internal
        {
            internal ushort count;
            internal fixed byte services[8];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_prim_srvc_disc_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtPrimSrvcDiscRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtPrimSrvcDiscRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtPrimSrvcDiscRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtPrimSrvcDiscRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtPrimSrvcDiscRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtPrimSrvcDiscRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtPrimSrvcDiscRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtPrimSrvcDiscRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtPrimSrvcDiscRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtPrimSrvcDiscRspT(global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Service count.</summary>
        public ushort Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        /// <summary>Service data.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public global::NrfBleDriver.BleGattcServiceT[] Services
        {
            get
            {
                global::NrfBleDriver.BleGattcServiceT[] __value = null;
                if (((__Internal*)__Instance)->services != null)
                {
                    __value = new global::NrfBleDriver.BleGattcServiceT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::NrfBleDriver.BleGattcServiceT.__GetOrCreateInstance((IntPtr)((global::NrfBleDriver.BleGattcServiceT.__Internal*)&(((__Internal*)__Instance)->services[i * sizeof(global::NrfBleDriver.BleGattcServiceT.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::NrfBleDriver.BleGattcServiceT.__Internal*) &((__Internal*)__Instance)->services[i * sizeof(global::NrfBleDriver.BleGattcServiceT.__Internal)] = *(global::NrfBleDriver.BleGattcServiceT.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtRelDiscRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal ushort count;
            internal fixed byte includes[10];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_rel_disc_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtRelDiscRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtRelDiscRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtRelDiscRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtRelDiscRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtRelDiscRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtRelDiscRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtRelDiscRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtRelDiscRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtRelDiscRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtRelDiscRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtRelDiscRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtRelDiscRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtRelDiscRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtRelDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtRelDiscRspT(global::NrfBleDriver.BleGattcEvtRelDiscRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtRelDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtRelDiscRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtRelDiscRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Include count.</summary>
        public ushort Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        /// <summary>Include data.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public global::NrfBleDriver.BleGattcIncludeT[] Includes
        {
            get
            {
                global::NrfBleDriver.BleGattcIncludeT[] __value = null;
                if (((__Internal*)__Instance)->includes != null)
                {
                    __value = new global::NrfBleDriver.BleGattcIncludeT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::NrfBleDriver.BleGattcIncludeT.__GetOrCreateInstance((IntPtr)((global::NrfBleDriver.BleGattcIncludeT.__Internal*)&(((__Internal*)__Instance)->includes[i * sizeof(global::NrfBleDriver.BleGattcIncludeT.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::NrfBleDriver.BleGattcIncludeT.__Internal*) &((__Internal*)__Instance)->includes[i * sizeof(global::NrfBleDriver.BleGattcIncludeT.__Internal)] = *(global::NrfBleDriver.BleGattcIncludeT.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtCharDiscRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal ushort count;
            internal fixed byte chars[10];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_char_disc_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtCharDiscRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtCharDiscRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtCharDiscRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtCharDiscRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtCharDiscRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtCharDiscRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtCharDiscRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtCharDiscRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtCharDiscRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtCharDiscRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtCharDiscRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtCharDiscRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtCharDiscRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtCharDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtCharDiscRspT(global::NrfBleDriver.BleGattcEvtCharDiscRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtCharDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtCharDiscRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtCharDiscRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Characteristic count.</summary>
        public ushort Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        /// <summary>Characteristic data.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public global::NrfBleDriver.BleGattcCharT[] Chars
        {
            get
            {
                global::NrfBleDriver.BleGattcCharT[] __value = null;
                if (((__Internal*)__Instance)->chars != null)
                {
                    __value = new global::NrfBleDriver.BleGattcCharT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::NrfBleDriver.BleGattcCharT.__GetOrCreateInstance((IntPtr)((global::NrfBleDriver.BleGattcCharT.__Internal*)&(((__Internal*)__Instance)->chars[i * sizeof(global::NrfBleDriver.BleGattcCharT.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::NrfBleDriver.BleGattcCharT.__Internal*) &((__Internal*)__Instance)->chars[i * sizeof(global::NrfBleDriver.BleGattcCharT.__Internal)] = *(global::NrfBleDriver.BleGattcCharT.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtDescDiscRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort count;
            internal fixed byte descs[6];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_desc_disc_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtDescDiscRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtDescDiscRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtDescDiscRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtDescDiscRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtDescDiscRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtDescDiscRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtDescDiscRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtDescDiscRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtDescDiscRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtDescDiscRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtDescDiscRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtDescDiscRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtDescDiscRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtDescDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtDescDiscRspT(global::NrfBleDriver.BleGattcEvtDescDiscRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtDescDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtDescDiscRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtDescDiscRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Descriptor count.</summary>
        public ushort Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        /// <summary>Descriptor data.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public global::NrfBleDriver.BleGattcDescT[] Descs
        {
            get
            {
                global::NrfBleDriver.BleGattcDescT[] __value = null;
                if (((__Internal*)__Instance)->descs != null)
                {
                    __value = new global::NrfBleDriver.BleGattcDescT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::NrfBleDriver.BleGattcDescT.__GetOrCreateInstance((IntPtr)((global::NrfBleDriver.BleGattcDescT.__Internal*)&(((__Internal*)__Instance)->descs[i * sizeof(global::NrfBleDriver.BleGattcDescT.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::NrfBleDriver.BleGattcDescT.__Internal*) &((__Internal*)__Instance)->descs[i * sizeof(global::NrfBleDriver.BleGattcDescT.__Internal)] = *(global::NrfBleDriver.BleGattcDescT.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtAttrInfoDiscRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 22)]
        public partial struct __Internal
        {
            internal ushort count;
            internal byte format;
            internal global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.Info.__Internal info;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_attr_info_disc_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Info
        {
            [StructLayout(LayoutKind.Explicit, Size = 18)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal fixed byte attr_info16[6];

                [FieldOffset(0)]
                internal fixed byte attr_info128[18];

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-info>@ble_gattc_evt_attr_info_disc_rsp_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Info.__Internal __instance;
            internal Info.__Internal __Instance => __instance;

            internal static Info __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Info(native.ToPointer(), skipVTables);
            }

            internal static Info __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Info(native, skipVTables);
            }

            private Info(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Info(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.Info.__Internal*) native;
            }

            public Info(global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.Info __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /*/// <summary>Attribute information for 16-bit Attribute UUID.</summary>
            /// <remarks>
            /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
            /// <para>Seefor more information on how to use event structures with variable length array members.</para>
            /// </remarks>
            public global::NrfBleDriver.BleGattcAttrInfo16T[] AttrInfo16
            {
                get
                {
                    fixed (global::NrfBleDriver.BleGattcAttrInfo16T __arrPtr = __instance.attr_info16)
                    {
                        global::NrfBleDriver.BleGattcAttrInfo16T[] __value = null;
                        if (__arrPtr != null)
                        {
                            __value = new global::NrfBleDriver.BleGattcAttrInfo16T[1];
                            for (int i = 0; i < 1; i++)
                                __value[i] = global::NrfBleDriver.BleGattcAttrInfo16T.__GetOrCreateInstance((IntPtr)((global::NrfBleDriver.BleGattcAttrInfo16T.__Internal*)&(__arrPtr[i * sizeof(global::NrfBleDriver.BleGattcAttrInfo16T.__Internal)])), true, true);
                        }
                        return __value;
                    }
                }

                set
                {
                    fixed (global::NrfBleDriver.BleGattcAttrInfo16T __arrPtr = __instance.attr_info16)
                    {
                        if (value != null)
                        {
                            if (value.Length != 1)
                                throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                            for (int i = 0; i < 1; i++)
                                *(global::NrfBleDriver.BleGattcAttrInfo16T.__Internal*) &__arrPtr[i * sizeof(global::NrfBleDriver.BleGattcAttrInfo16T.__Internal)] = *(global::NrfBleDriver.BleGattcAttrInfo16T.__Internal*)value[i].__Instance;
                        }
                    }
                }
            }

            /// <summary>Attribute information for 128-bit Attribute UUID.</summary>
            /// <remarks>
            /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
            /// <para>Seefor more information on how to use event structures with variable length array members.</para>
            /// </remarks>
            public global::NrfBleDriver.BleGattcAttrInfo128T[] AttrInfo128
            {
                get
                {
                    fixed (global::NrfBleDriver.BleGattcAttrInfo128T __arrPtr = __instance.attr_info128)
                    {
                        global::NrfBleDriver.BleGattcAttrInfo128T[] __value = null;
                        if (__arrPtr != null)
                        {
                            __value = new global::NrfBleDriver.BleGattcAttrInfo128T[1];
                            for (int i = 0; i < 1; i++)
                                __value[i] = global::NrfBleDriver.BleGattcAttrInfo128T.__GetOrCreateInstance((IntPtr)((global::NrfBleDriver.BleGattcAttrInfo128T.__Internal*)&(__arrPtr[i * sizeof(global::NrfBleDriver.BleGattcAttrInfo128T.__Internal)])), true, true);
                        }
                        return __value;
                    }
                }

                set
                {
                    fixed (global::NrfBleDriver.BleGattcAttrInfo128T __arrPtr = __instance.attr_info128)
                    {
                        if (value != null)
                        {
                            if (value.Length != 1)
                                throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                            for (int i = 0; i < 1; i++)
                                *(global::NrfBleDriver.BleGattcAttrInfo128T.__Internal*) &__arrPtr[i * sizeof(global::NrfBleDriver.BleGattcAttrInfo128T.__Internal)] = *(global::NrfBleDriver.BleGattcAttrInfo128T.__Internal*)value[i].__Instance;
                        }
                    }
                }
            }*/
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtAttrInfoDiscRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtAttrInfoDiscRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtAttrInfoDiscRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtAttrInfoDiscRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtAttrInfoDiscRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtAttrInfoDiscRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtAttrInfoDiscRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtAttrInfoDiscRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtAttrInfoDiscRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtAttrInfoDiscRspT(global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute count.</summary>
        public ushort Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        /// <summary>Attribute information format, see</summary>
        public byte Format
        {
            get
            {
                return ((__Internal*)__Instance)->format;
            }

            set
            {
                ((__Internal*)__Instance)->format = value;
            }
        }

        /// <summary>Attribute information union.</summary>
        public global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.Info info
        {
            get
            {
                return global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.Info.__CreateInstance(((__Internal*)__Instance)->info);
            }

            set
            {
                ((__Internal*)__Instance)->info = value.__Instance;
            }
        }
    }

    /// <summary>GATT read by UUID handle value pair.</summary>
    public unsafe partial class BleGattcHandleValueT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal __IntPtr p_value;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_handle_value_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcHandleValueT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcHandleValueT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcHandleValueT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcHandleValueT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcHandleValueT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcHandleValueT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcHandleValueT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcHandleValueT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcHandleValueT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcHandleValueT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcHandleValueT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcHandleValueT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcHandleValueT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcHandleValueT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcHandleValueT(global::NrfBleDriver.BleGattcHandleValueT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcHandleValueT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcHandleValueT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcHandleValueT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute Handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Pointer to the Attribute Value, length is available in</summary>
        public byte* PValue
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_value;
            }

            set
            {
                ((__Internal*)__Instance)->p_value = (__IntPtr) value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtCharValByUuidReadRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 6)]
        public partial struct __Internal
        {
            internal ushort count;
            internal ushort value_len;
            internal fixed byte handle_value[1];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_char_val_by_uuid_read_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtCharValByUuidReadRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtCharValByUuidReadRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtCharValByUuidReadRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtCharValByUuidReadRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtCharValByUuidReadRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtCharValByUuidReadRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtCharValByUuidReadRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtCharValByUuidReadRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtCharValByUuidReadRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtCharValByUuidReadRspT(global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Handle-Value Pair Count.</summary>
        public ushort Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        /// <summary>Length of the value in Handle-Value(s) list.</summary>
        public ushort ValueLen
        {
            get
            {
                return ((__Internal*)__Instance)->value_len;
            }

            set
            {
                ((__Internal*)__Instance)->value_len = value;
            }
        }

        /// <summary>Handle-Value(s) list. To iterate through the list use</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public byte[] HandleValue
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->handle_value, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->handle_value[i] = value[i];
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtReadRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal ushort offset;
            internal ushort len;
            internal fixed byte data[1];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_read_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtReadRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtReadRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtReadRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtReadRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtReadRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtReadRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtReadRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtReadRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtReadRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtReadRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtReadRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtReadRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtReadRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtReadRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtReadRspT(global::NrfBleDriver.BleGattcEvtReadRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtReadRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtReadRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtReadRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute Handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Offset of the attribute data.</summary>
        public ushort Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }

        /// <summary>Attribute data length.</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        /// <summary>Attribute data.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public byte[] Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->data, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->data[i] = value[i];
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtCharValsReadRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal ushort len;
            internal fixed byte values[1];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_char_vals_read_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtCharValsReadRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtCharValsReadRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtCharValsReadRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtCharValsReadRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtCharValsReadRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtCharValsReadRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtCharValsReadRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtCharValsReadRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtCharValsReadRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtCharValsReadRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtCharValsReadRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtCharValsReadRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtCharValsReadRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtCharValsReadRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtCharValsReadRspT(global::NrfBleDriver.BleGattcEvtCharValsReadRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtCharValsReadRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtCharValsReadRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtCharValsReadRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Concatenated Attribute values length.</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        /// <summary>Attribute values.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public byte[] Values
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->values, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->values[i] = value[i];
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtWriteRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 10)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal byte write_op;
            internal ushort offset;
            internal ushort len;
            internal fixed byte data[1];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_write_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtWriteRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtWriteRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtWriteRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtWriteRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtWriteRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtWriteRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtWriteRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtWriteRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtWriteRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtWriteRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtWriteRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtWriteRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtWriteRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtWriteRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtWriteRspT(global::NrfBleDriver.BleGattcEvtWriteRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtWriteRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtWriteRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtWriteRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Attribute Handle.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Type of write operation, see</summary>
        public byte WriteOp
        {
            get
            {
                return ((__Internal*)__Instance)->write_op;
            }

            set
            {
                ((__Internal*)__Instance)->write_op = value;
            }
        }

        /// <summary>Data offset.</summary>
        public ushort Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }

        /// <summary>Data length.</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        /// <summary>Data.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public byte[] Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->data, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->data[i] = value[i];
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtHvxT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ushort handle;
            internal byte type;
            internal ushort len;
            internal fixed byte data[1];

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_hvx_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtHvxT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtHvxT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtHvxT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtHvxT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtHvxT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtHvxT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtHvxT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtHvxT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtHvxT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtHvxT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtHvxT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtHvxT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtHvxT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtHvxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtHvxT(global::NrfBleDriver.BleGattcEvtHvxT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtHvxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtHvxT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtHvxT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Handle to which the HVx operation applies.</summary>
        public ushort Handle
        {
            get
            {
                return ((__Internal*)__Instance)->handle;
            }

            set
            {
                ((__Internal*)__Instance)->handle = value;
            }
        }

        /// <summary>Indication or Notification, see</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Attribute data length.</summary>
        public ushort Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        /// <summary>Attribute data.</summary>
        /// <remarks>
        /// <para>This is a variable length array. The size of 1 indicated is only a placeholder for compilation.</para>
        /// <para>Seefor more information on how to use event structures with variable length array members.</para>
        /// </remarks>
        public byte[] Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->data, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->data[i] = value[i];
                }
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtExchangeMtuRspT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal ushort server_rx_mtu;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_exchange_mtu_rsp_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtExchangeMtuRspT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtExchangeMtuRspT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtExchangeMtuRspT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtExchangeMtuRspT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtExchangeMtuRspT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtExchangeMtuRspT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtExchangeMtuRspT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtExchangeMtuRspT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtExchangeMtuRspT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtExchangeMtuRspT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtExchangeMtuRspT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtExchangeMtuRspT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtExchangeMtuRspT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtExchangeMtuRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtExchangeMtuRspT(global::NrfBleDriver.BleGattcEvtExchangeMtuRspT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtExchangeMtuRspT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtExchangeMtuRspT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtExchangeMtuRspT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Server RX MTU size.</summary>
        public ushort ServerRxMtu
        {
            get
            {
                return ((__Internal*)__Instance)->server_rx_mtu;
            }

            set
            {
                ((__Internal*)__Instance)->server_rx_mtu = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtTimeoutT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte src;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_timeout_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtTimeoutT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtTimeoutT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtTimeoutT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtTimeoutT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtTimeoutT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtTimeoutT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtTimeoutT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtTimeoutT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtTimeoutT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtTimeoutT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtTimeoutT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtTimeoutT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtTimeoutT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtTimeoutT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtTimeoutT(global::NrfBleDriver.BleGattcEvtTimeoutT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtTimeoutT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtTimeoutT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtTimeoutT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Timeout source, see</summary>
        public byte Src
        {
            get
            {
                return ((__Internal*)__Instance)->src;
            }

            set
            {
                ((__Internal*)__Instance)->src = value;
            }
        }
    }

    /// <summary>Event structure for</summary>
    public unsafe partial class BleGattcEvtWriteCmdTxCompleteT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte count;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_write_cmd_tx_complete_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtWriteCmdTxCompleteT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtWriteCmdTxCompleteT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtWriteCmdTxCompleteT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtWriteCmdTxCompleteT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtWriteCmdTxCompleteT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtWriteCmdTxCompleteT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtWriteCmdTxCompleteT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtWriteCmdTxCompleteT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtWriteCmdTxCompleteT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtWriteCmdTxCompleteT(global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Number of write without response transmissions completed.</summary>
        public byte Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }
    }

    /// <summary>GATTC event structure.</summary>
    public unsafe partial class BleGattcEvtT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal ushort conn_handle;
            internal ushort gatt_status;
            internal ushort error_handle;
            internal global::NrfBleDriver.BleGattcEvtT.Params.__Internal @params;

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0ble_gattc_evt_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public unsafe partial struct Params
        {
            [StructLayout(LayoutKind.Explicit, Size = 22)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT.__Internal prim_srvc_disc_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtRelDiscRspT.__Internal rel_disc_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtCharDiscRspT.__Internal char_disc_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtDescDiscRspT.__Internal desc_disc_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT.__Internal char_val_by_uuid_read_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtReadRspT.__Internal read_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtCharValsReadRspT.__Internal char_vals_read_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtWriteRspT.__Internal write_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtHvxT.__Internal hvx;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtExchangeMtuRspT.__Internal exchange_mtu_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtTimeoutT.__Internal timeout;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.__Internal attr_info_disc_rsp;

                [FieldOffset(0)]
                internal global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT.__Internal write_cmd_tx_complete;

                [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "??0<unnamed-type-params>@ble_gattc_evt_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Params.__Internal __instance;
            internal Params.__Internal __Instance => __instance;

            internal static Params __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Params(native.ToPointer(), skipVTables);
            }

            internal static Params __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Params(native, skipVTables);
            }

            private Params(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Params(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::NrfBleDriver.BleGattcEvtT.Params.__Internal*) native;
            }

            public Params(global::NrfBleDriver.BleGattcEvtT.Params __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>Primary Service Discovery Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT PrimSrvcDiscRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT.__CreateInstance(__instance.prim_srvc_disc_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.prim_srvc_disc_rsp = *(global::NrfBleDriver.BleGattcEvtPrimSrvcDiscRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Relationship Discovery Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtRelDiscRspT RelDiscRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtRelDiscRspT.__CreateInstance(__instance.rel_disc_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.rel_disc_rsp = *(global::NrfBleDriver.BleGattcEvtRelDiscRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Characteristic Discovery Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtCharDiscRspT CharDiscRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtCharDiscRspT.__CreateInstance(__instance.char_disc_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.char_disc_rsp = *(global::NrfBleDriver.BleGattcEvtCharDiscRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Descriptor Discovery Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtDescDiscRspT DescDiscRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtDescDiscRspT.__CreateInstance(__instance.desc_disc_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.desc_disc_rsp = *(global::NrfBleDriver.BleGattcEvtDescDiscRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Characteristic Value Read by UUID Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT CharValByUuidReadRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT.__CreateInstance(__instance.char_val_by_uuid_read_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.char_val_by_uuid_read_rsp = *(global::NrfBleDriver.BleGattcEvtCharValByUuidReadRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Read Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtReadRspT ReadRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtReadRspT.__CreateInstance(__instance.read_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.read_rsp = *(global::NrfBleDriver.BleGattcEvtReadRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Characteristic Values Read Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtCharValsReadRspT CharValsReadRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtCharValsReadRspT.__CreateInstance(__instance.char_vals_read_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.char_vals_read_rsp = *(global::NrfBleDriver.BleGattcEvtCharValsReadRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Write Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtWriteRspT WriteRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtWriteRspT.__CreateInstance(__instance.write_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.write_rsp = *(global::NrfBleDriver.BleGattcEvtWriteRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Handle Value Notification/Indication Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtHvxT Hvx
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtHvxT.__CreateInstance(__instance.hvx);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.hvx = *(global::NrfBleDriver.BleGattcEvtHvxT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Exchange MTU Response Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtExchangeMtuRspT ExchangeMtuRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtExchangeMtuRspT.__CreateInstance(__instance.exchange_mtu_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.exchange_mtu_rsp = *(global::NrfBleDriver.BleGattcEvtExchangeMtuRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Timeout Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtTimeoutT Timeout
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtTimeoutT.__CreateInstance(__instance.timeout);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.timeout = *(global::NrfBleDriver.BleGattcEvtTimeoutT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Attribute Information Discovery Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT AttrInfoDiscRsp
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.__CreateInstance(__instance.attr_info_disc_rsp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.attr_info_disc_rsp = *(global::NrfBleDriver.BleGattcEvtAttrInfoDiscRspT.__Internal*) value.__Instance;
                }
            }

            /// <summary>Write without Response transmission complete Event Parameters.</summary>
            public global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT WriteCmdTxComplete
            {
                get
                {
                    return global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT.__CreateInstance(__instance.write_cmd_tx_complete);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.write_cmd_tx_complete = *(global::NrfBleDriver.BleGattcEvtWriteCmdTxCompleteT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NrfBleDriver.BleGattcEvtT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::NrfBleDriver.BleGattcEvtT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::NrfBleDriver.BleGattcEvtT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BleGattcEvtT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BleGattcEvtT(native.ToPointer(), skipVTables);
        }

        internal static BleGattcEvtT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BleGattcEvtT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BleGattcEvtT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BleGattcEvtT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BleGattcEvtT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BleGattcEvtT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BleGattcEvtT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public BleGattcEvtT(global::NrfBleDriver.BleGattcEvtT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NrfBleDriver.BleGattcEvtT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::NrfBleDriver.BleGattcEvtT.__Internal*) __Instance) = *((global::NrfBleDriver.BleGattcEvtT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Connection Handle on which event occurred.</summary>
        public ushort ConnHandle
        {
            get
            {
                return ((__Internal*)__Instance)->conn_handle;
            }

            set
            {
                ((__Internal*)__Instance)->conn_handle = value;
            }
        }

        /// <summary>GATT status code for the operation, see</summary>
        public ushort GattStatus
        {
            get
            {
                return ((__Internal*)__Instance)->gatt_status;
            }

            set
            {
                ((__Internal*)__Instance)->gatt_status = value;
            }
        }

        /// <summary>In case of error: The handle causing the error. In all other cases</summary>
        public ushort ErrorHandle
        {
            get
            {
                return ((__Internal*)__Instance)->error_handle;
            }

            set
            {
                ((__Internal*)__Instance)->error_handle = value;
            }
        }

        /// <summary>Event Parameters.</summary>
        /// <remarks>Only valid if==</remarks>
        public global::NrfBleDriver.BleGattcEvtT.Params @params
        {
            get
            {
                return global::NrfBleDriver.BleGattcEvtT.Params.__CreateInstance(((__Internal*)__Instance)->@params);
            }

            set
            {
                ((__Internal*)__Instance)->@params = value.__Instance;
            }
        }
    }

    public unsafe partial class ble_gattc
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_primary_services_discover", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcPrimaryServicesDiscover(__IntPtr adapter, ushort conn_handle, ushort start_handle, __IntPtr p_srvc_uuid);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_relationships_discover", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcRelationshipsDiscover(__IntPtr adapter, ushort conn_handle, __IntPtr p_handle_range);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_characteristics_discover", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcCharacteristicsDiscover(__IntPtr adapter, ushort conn_handle, __IntPtr p_handle_range);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_descriptors_discover", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcDescriptorsDiscover(__IntPtr adapter, ushort conn_handle, __IntPtr p_handle_range);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_char_value_by_uuid_read", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcCharValueByUuidRead(__IntPtr adapter, ushort conn_handle, __IntPtr p_uuid, __IntPtr p_handle_range);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_read", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcRead(__IntPtr adapter, ushort conn_handle, ushort handle, ushort offset);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_char_values_read", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcCharValuesRead(__IntPtr adapter, ushort conn_handle, ushort* p_handles, ushort handle_count);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_write", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcWrite(__IntPtr adapter, ushort conn_handle, __IntPtr p_write_params);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_hv_confirm", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcHvConfirm(__IntPtr adapter, ushort conn_handle, ushort handle);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_attr_info_discover", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcAttrInfoDiscover(__IntPtr adapter, ushort conn_handle, __IntPtr p_handle_range);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "sd_ble_gattc_exchange_mtu_request", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcExchangeMtuRequest(__IntPtr adapter, ushort conn_handle, ushort client_rx_mtu);

            [SuppressUnmanagedCodeSecurity, DllImport("NrfBleDriver", EntryPoint = "?sd_ble_gattc_evt_char_val_by_uuid_read_rsp_iter@@YAIPEAUble_gattc_evt_t@@PEAUble_gattc_handle_value_t@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint SdBleGattcEvtCharValByUuidReadRspIter(__IntPtr p_gattc_evt, __IntPtr p_iter);
        }

        public static uint SdBleGattcPrimaryServicesDiscover(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort start_handle, global::NrfBleDriver.BleUuidT p_srvc_uuid)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg3 = p_srvc_uuid is null ? __IntPtr.Zero : p_srvc_uuid.__Instance;
            var __ret = __Internal.SdBleGattcPrimaryServicesDiscover(__arg0, conn_handle, start_handle, __arg3);
            return __ret;
        }

        public static uint SdBleGattcRelationshipsDiscover(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGattcHandleRangeT p_handle_range)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_handle_range is null ? __IntPtr.Zero : p_handle_range.__Instance;
            var __ret = __Internal.SdBleGattcRelationshipsDiscover(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGattcCharacteristicsDiscover(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGattcHandleRangeT p_handle_range)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_handle_range is null ? __IntPtr.Zero : p_handle_range.__Instance;
            var __ret = __Internal.SdBleGattcCharacteristicsDiscover(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGattcDescriptorsDiscover(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGattcHandleRangeT p_handle_range)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_handle_range is null ? __IntPtr.Zero : p_handle_range.__Instance;
            var __ret = __Internal.SdBleGattcDescriptorsDiscover(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGattcCharValueByUuidRead(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleUuidT p_uuid, global::NrfBleDriver.BleGattcHandleRangeT p_handle_range)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_uuid is null ? __IntPtr.Zero : p_uuid.__Instance;
            var __arg3 = p_handle_range is null ? __IntPtr.Zero : p_handle_range.__Instance;
            var __ret = __Internal.SdBleGattcCharValueByUuidRead(__arg0, conn_handle, __arg2, __arg3);
            return __ret;
        }

        public static uint SdBleGattcRead(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort handle, ushort offset)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGattcRead(__arg0, conn_handle, handle, offset);
            return __ret;
        }

        public static uint SdBleGattcCharValuesRead(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ref ushort p_handles, ushort handle_count)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            fixed (ushort* __p_handles2 = &p_handles)
            {
                var __arg2 = __p_handles2;
                var __ret = __Internal.SdBleGattcCharValuesRead(__arg0, conn_handle, __arg2, handle_count);
                return __ret;
            }
        }

        public static uint SdBleGattcWrite(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGattcWriteParamsT p_write_params)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_write_params is null ? __IntPtr.Zero : p_write_params.__Instance;
            var __ret = __Internal.SdBleGattcWrite(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGattcHvConfirm(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort handle)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGattcHvConfirm(__arg0, conn_handle, handle);
            return __ret;
        }

        public static uint SdBleGattcAttrInfoDiscover(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, global::NrfBleDriver.BleGattcHandleRangeT p_handle_range)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __arg2 = p_handle_range is null ? __IntPtr.Zero : p_handle_range.__Instance;
            var __ret = __Internal.SdBleGattcAttrInfoDiscover(__arg0, conn_handle, __arg2);
            return __ret;
        }

        public static uint SdBleGattcExchangeMtuRequest(global::NrfBleDriver.AdapterT adapter, ushort conn_handle, ushort client_rx_mtu)
        {
            var __arg0 = adapter is null ? __IntPtr.Zero : adapter.__Instance;
            var __ret = __Internal.SdBleGattcExchangeMtuRequest(__arg0, conn_handle, client_rx_mtu);
            return __ret;
        }

        /// <summary>Iterate through Handle-Value(s) list inevent.</summary>
        /// <param name="p_gattc_evt">Pointer to event buffer containingevent.</param>
        /// <param name="p_iter">
        /// <para>Iterator, points tostructure that will be filled in with</para>
        /// <para>the next Handle-Value pair in each iteration. If the function returns other than</para>
        /// <para>it will not be changed.</para>
        /// <para>- To start iteration, initialize the structure to zero.</para>
        /// <para>- To continue, pass the value from previous iteration.</para>
        /// </param>
        /// <remarks>
        /// <para>If the buffer contains different event, behavior is undefined.</para>
        /// <para>::NRF_SUCCESS Successfully retrieved the next Handle-Value pair.</para>
        /// <para>::NRF_ERROR_NOT_FOUND No more Handle-Value pairs available in the list.</para>
        /// </remarks>
        public static uint SdBleGattcEvtCharValByUuidReadRspIter(global::NrfBleDriver.BleGattcEvtT p_gattc_evt, global::NrfBleDriver.BleGattcHandleValueT p_iter)
        {
            var __arg0 = p_gattc_evt is null ? __IntPtr.Zero : p_gattc_evt.__Instance;
            var __arg1 = p_iter is null ? __IntPtr.Zero : p_iter.__Instance;
            var __ret = __Internal.SdBleGattcEvtCharValByUuidReadRspIter(__arg0, __arg1);
            return __ret;
        }
    }
}
